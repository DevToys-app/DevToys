const t = function () { if ("undefined" != typeof globalThis) return globalThis; if ("undefined" != typeof global) return global; if ("undefined" != typeof self) return self; if ("undefined" != typeof window) return window; try { return new Function("return this")() } catch (t) { return {} } }(); void 0 === t.trustedTypes && (t.trustedTypes = { createPolicy: (t, e) => e }); const e = { configurable: !1, enumerable: !1, writable: !1 }; void 0 === t.FAST && Reflect.defineProperty(t, "FAST", Object.assign({ value: Object.create(null) }, e)); const i = t.FAST; if (void 0 === i.getById) { const t = Object.create(null); Reflect.defineProperty(i, "getById", Object.assign({ value(e, i) { let o = t[e]; return void 0 === o && (o = i ? t[e] = i() : null), o } }, e)) } const o = Object.freeze([]); function s() { const t = new WeakMap; return function (e) { let i = t.get(e); if (void 0 === i) { let o = Reflect.getPrototypeOf(e); for (; void 0 === i && null !== o;)i = t.get(o), o = Reflect.getPrototypeOf(o); i = void 0 === i ? [] : i.slice(0), t.set(e, i) } return i } } const n = t.FAST.getById(1, () => { const e = [], i = []; function o() { if (i.length) throw i.shift() } function s(t) { try { t.call() } catch (t) { i.push(t), setTimeout(o, 0) } } function n() { let t = 0; for (; t < e.length;)if (s(e[t]), t++, t > 1024) { for (let i = 0, o = e.length - t; i < o; i++)e[i] = e[i + t]; e.length -= t, t = 0 } e.length = 0 } return Object.freeze({ enqueue: function (i) { e.length < 1 && t.requestAnimationFrame(n), e.push(i) }, process: n }) }), r = t.trustedTypes.createPolicy("fast-html", { createHTML: t => t }); let a = r; const l = "fast-" + Math.random().toString(36).substring(2, 8), c = l + "{", h = "}" + l, d = Object.freeze({ supportsAdoptedStyleSheets: Array.isArray(document.adoptedStyleSheets) && "replace" in CSSStyleSheet.prototype, setHTMLPolicy(t) { if (a !== r) throw new Error("The HTML policy can only be set once."); a = t }, createHTML: t => a.createHTML(t), isMarker: t => t && 8 === t.nodeType && t.data.startsWith(l), extractDirectiveIndexFromMarker: t => parseInt(t.data.replace(l + ":", "")), createInterpolationPlaceholder: t => `${c}${t}${h}`, createCustomAttributePlaceholder(t, e) { return `${t}="${this.createInterpolationPlaceholder(e)}"` }, createBlockPlaceholder: t => `\x3c!--${l}:${t}--\x3e`, queueUpdate: n.enqueue, processUpdates: n.process, nextUpdate: () => new Promise(n.enqueue), setAttribute(t, e, i) { null == i ? t.removeAttribute(e) : t.setAttribute(e, i) }, setBooleanAttribute(t, e, i) { i ? t.setAttribute(e, "") : t.removeAttribute(e) }, removeChildNodes(t) { for (let e = t.firstChild; null !== e; e = t.firstChild)t.removeChild(e) }, createTemplateWalker: t => document.createTreeWalker(t, 133, null, !1) }); class u { constructor(t, e) { this.sub1 = void 0, this.sub2 = void 0, this.spillover = void 0, this.source = t, this.sub1 = e } has(t) { return void 0 === this.spillover ? this.sub1 === t || this.sub2 === t : -1 !== this.spillover.indexOf(t) } subscribe(t) { const e = this.spillover; if (void 0 === e) { if (this.has(t)) return; if (void 0 === this.sub1) return void (this.sub1 = t); if (void 0 === this.sub2) return void (this.sub2 = t); this.spillover = [this.sub1, this.sub2, t], this.sub1 = void 0, this.sub2 = void 0 } else { -1 === e.indexOf(t) && e.push(t) } } unsubscribe(t) { const e = this.spillover; if (void 0 === e) this.sub1 === t ? this.sub1 = void 0 : this.sub2 === t && (this.sub2 = void 0); else { const i = e.indexOf(t); -1 !== i && e.splice(i, 1) } } notify(t) { const e = this.spillover, i = this.source; if (void 0 === e) { const e = this.sub1, o = this.sub2; void 0 !== e && e.handleChange(i, t), void 0 !== o && o.handleChange(i, t) } else for (let o = 0, s = e.length; o < s; ++o)e[o].handleChange(i, t) } } class p { constructor(t) { this.subscribers = {}, this.sourceSubscribers = null, this.source = t } notify(t) { var e; const i = this.subscribers[t]; void 0 !== i && i.notify(t), null === (e = this.sourceSubscribers) || void 0 === e || e.notify(t) } subscribe(t, e) { var i; if (e) { let i = this.subscribers[e]; void 0 === i && (this.subscribers[e] = i = new u(this.source)), i.subscribe(t) } else this.sourceSubscribers = null !== (i = this.sourceSubscribers) && void 0 !== i ? i : new u(this.source), this.sourceSubscribers.subscribe(t) } unsubscribe(t, e) { var i; if (e) { const i = this.subscribers[e]; void 0 !== i && i.unsubscribe(t) } else null === (i = this.sourceSubscribers) || void 0 === i || i.unsubscribe(t) } } const g = i.getById(2, () => { const t = /(:|&&|\|\||if)/, e = new WeakMap, i = d.queueUpdate; let o = void 0, n = t => { throw new Error("Must call enableArrayObservation before observing arrays.") }; function r(t) { let i = t.$fastController || e.get(t); return void 0 === i && (Array.isArray(t) ? i = n(t) : e.set(t, i = new p(t))), i } const a = s(); class l { constructor(t) { this.name = t, this.field = "_" + t, this.callback = t + "Changed" } getValue(t) { return void 0 !== o && o.watch(t, this.name), t[this.field] } setValue(t, e) { const i = this.field, o = t[i]; if (o !== e) { t[i] = e; const s = t[this.callback]; "function" == typeof s && s.call(t, o, e), r(t).notify(this.name) } } } class c extends u { constructor(t, e, i = !1) { super(t, e), this.binding = t, this.isVolatileBinding = i, this.needsRefresh = !0, this.needsQueue = !0, this.first = this, this.last = null, this.propertySource = void 0, this.propertyName = void 0, this.notifier = void 0, this.next = void 0 } observe(t, e) { this.needsRefresh && null !== this.last && this.disconnect(); const i = o; o = this.needsRefresh ? this : void 0, this.needsRefresh = this.isVolatileBinding; const s = this.binding(t, e); return o = i, s } disconnect() { if (null !== this.last) { let t = this.first; for (; void 0 !== t;)t.notifier.unsubscribe(this, t.propertyName), t = t.next; this.last = null, this.needsRefresh = this.needsQueue = !0 } } watch(t, e) { const i = this.last, s = r(t), n = null === i ? this.first : {}; if (n.propertySource = t, n.propertyName = e, n.notifier = s, s.subscribe(this, e), null !== i) { if (!this.needsRefresh) { let e; o = void 0, e = i.propertySource[i.propertyName], o = this, t === e && (this.needsRefresh = !0) } i.next = n } this.last = n } handleChange() { this.needsQueue && (this.needsQueue = !1, i(this)) } call() { null !== this.last && (this.needsQueue = !0, this.notify(this)) } records() { let t = this.first; return { next: () => { const e = t; return void 0 === e ? { value: void 0, done: !0 } : (t = t.next, { value: e, done: !1 }) }, [Symbol.iterator]: function () { return this } } } } return Object.freeze({ setArrayObserverFactory(t) { n = t }, getNotifier: r, track(t, e) { void 0 !== o && o.watch(t, e) }, trackVolatile() { void 0 !== o && (o.needsRefresh = !0) }, notify(t, e) { r(t).notify(e) }, defineProperty(t, e) { "string" == typeof e && (e = new l(e)), a(t).push(e), Reflect.defineProperty(t, e.name, { enumerable: !0, get: function () { return e.getValue(this) }, set: function (t) { e.setValue(this, t) } }) }, getAccessors: a, binding(t, e, i = this.isVolatileBinding(t)) { return new c(t, e, i) }, isVolatileBinding: e => t.test(e.toString()) }) }); function f(t, e) { g.defineProperty(t, e) } const m = i.getById(3, () => { let t = null; return { get: () => t, set(e) { t = e } } }); class v { constructor() { this.index = 0, this.length = 0, this.parent = null, this.parentContext = null } get event() { return m.get() } get isEven() { return this.index % 2 == 0 } get isOdd() { return this.index % 2 != 0 } get isFirst() { return 0 === this.index } get isInMiddle() { return !this.isFirst && !this.isLast } get isLast() { return this.index === this.length - 1 } static setEvent(t) { m.set(t) } } g.defineProperty(v.prototype, "index"), g.defineProperty(v.prototype, "length"); const b = Object.seal(new v); class y { constructor() { this.targetIndex = 0 } } class x extends y { constructor() { super(...arguments), this.createPlaceholder = d.createInterpolationPlaceholder } } class $ extends y { constructor(t, e, i) { super(), this.name = t, this.behavior = e, this.options = i } createPlaceholder(t) { return d.createCustomAttributePlaceholder(this.name, t) } createBehavior(t) { return new this.behavior(t, this.options) } } function w(t, e) { this.source = t, this.context = e, null === this.bindingObserver && (this.bindingObserver = g.binding(this.binding, this, this.isBindingVolatile)), this.updateTarget(this.bindingObserver.observe(t, e)) } function k(t, e) { this.source = t, this.context = e, this.target.addEventListener(this.targetName, this) } function C() { this.bindingObserver.disconnect(), this.source = null, this.context = null } function I() { this.bindingObserver.disconnect(), this.source = null, this.context = null; const t = this.target.$fastView; void 0 !== t && t.isComposed && (t.unbind(), t.needsBindOnly = !0) } function F() { this.target.removeEventListener(this.targetName, this), this.source = null, this.context = null } function D(t) { d.setAttribute(this.target, this.targetName, t) } function T(t) { d.setBooleanAttribute(this.target, this.targetName, t) } function S(t) { if (null == t && (t = ""), t.create) { this.target.textContent = ""; let e = this.target.$fastView; void 0 === e ? e = t.create() : this.target.$fastTemplate !== t && (e.isComposed && (e.remove(), e.unbind()), e = t.create()), e.isComposed ? e.needsBindOnly && (e.needsBindOnly = !1, e.bind(this.source, this.context)) : (e.isComposed = !0, e.bind(this.source, this.context), e.insertBefore(this.target), this.target.$fastView = e, this.target.$fastTemplate = t) } else { const e = this.target.$fastView; void 0 !== e && e.isComposed && (e.isComposed = !1, e.remove(), e.needsBindOnly ? e.needsBindOnly = !1 : e.unbind()), this.target.textContent = t } } function O(t) { this.target[this.targetName] = t } function E(t) { const e = this.classVersions || Object.create(null), i = this.target; let o = this.version || 0; if (null != t && t.length) { const s = t.split(/\s+/); for (let t = 0, n = s.length; t < n; ++t) { const n = s[t]; "" !== n && (e[n] = o, i.classList.add(n)) } } if (this.classVersions = e, this.version = o + 1, 0 !== o) { o -= 1; for (const t in e) e[t] === o && i.classList.remove(t) } } class V extends x { constructor(t) { super(), this.binding = t, this.bind = w, this.unbind = C, this.updateTarget = D, this.isBindingVolatile = g.isVolatileBinding(this.binding) } get targetName() { return this.originalTargetName } set targetName(t) { if (this.originalTargetName = t, void 0 !== t) switch (t[0]) { case ":": if (this.cleanedTargetName = t.substr(1), this.updateTarget = O, "innerHTML" === this.cleanedTargetName) { const t = this.binding; this.binding = (e, i) => d.createHTML(t(e, i)) } break; case "?": this.cleanedTargetName = t.substr(1), this.updateTarget = T; break; case "@": this.cleanedTargetName = t.substr(1), this.bind = k, this.unbind = F; break; default: this.cleanedTargetName = t, "class" === t && (this.updateTarget = E) } } targetAtContent() { this.updateTarget = S, this.unbind = I } createBehavior(t) { return new R(t, this.binding, this.isBindingVolatile, this.bind, this.unbind, this.updateTarget, this.cleanedTargetName) } } class R { constructor(t, e, i, o, s, n, r) { this.source = null, this.context = null, this.bindingObserver = null, this.target = t, this.binding = e, this.isBindingVolatile = i, this.bind = o, this.unbind = s, this.updateTarget = n, this.targetName = r } handleChange() { this.updateTarget(this.bindingObserver.observe(this.source, this.context)) } handleEvent(t) { v.setEvent(t); const e = this.binding(this.source, this.context); v.setEvent(null), !0 !== e && t.preventDefault() } } let A = null; class L { addFactory(t) { t.targetIndex = this.targetIndex, this.behaviorFactories.push(t) } captureContentBinding(t) { t.targetAtContent(), this.addFactory(t) } reset() { this.behaviorFactories = [], this.targetIndex = -1 } release() { A = this } static borrow(t) { const e = A || new L; return e.directives = t, e.reset(), A = null, e } } function P(t) { if (1 === t.length) return t[0]; let e; const i = t.length, o = t.map(t => "string" == typeof t ? () => t : (e = t.targetName || e, t.binding)), s = new V((t, e) => { let s = ""; for (let n = 0; n < i; ++n)s += o[n](t, e); return s }); return s.targetName = e, s } const z = h.length; function H(t, e) { const i = e.split(c); if (1 === i.length) return null; const o = []; for (let e = 0, s = i.length; e < s; ++e) { const s = i[e], n = s.indexOf(h); let r; if (-1 === n) r = s; else { const e = parseInt(s.substring(0, n)); o.push(t.directives[e]), r = s.substring(n + z) } "" !== r && o.push(r) } return o } function M(t, e, i = !1) { const o = e.attributes; for (let s = 0, n = o.length; s < n; ++s) { const r = o[s], a = r.value, l = H(t, a); let c = null; null === l ? i && (c = new V(() => a), c.targetName = r.name) : c = P(l), null !== c && (e.removeAttributeNode(r), s--, n--, t.addFactory(c)) } } function B(t, e, i) { const o = H(t, e.textContent); if (null !== o) { let s = e; for (let n = 0, r = o.length; n < r; ++n) { const r = o[n], a = 0 === n ? e : s.parentNode.insertBefore(document.createTextNode(""), s.nextSibling); "string" == typeof r ? a.textContent = r : (a.textContent = " ", t.captureContentBinding(r)), s = a, t.targetIndex++, a !== e && i.nextNode() } t.targetIndex-- } } const N = document.createRange(); class j { constructor(t, e) { this.fragment = t, this.behaviors = e, this.source = null, this.context = null, this.firstChild = t.firstChild, this.lastChild = t.lastChild } appendTo(t) { t.appendChild(this.fragment) } insertBefore(t) { if (this.fragment.hasChildNodes()) t.parentNode.insertBefore(this.fragment, t); else { const e = this.lastChild; if (t.previousSibling === e) return; const i = t.parentNode; let o, s = this.firstChild; for (; s !== e;)o = s.nextSibling, i.insertBefore(s, t), s = o; i.insertBefore(e, t) } } remove() { const t = this.fragment, e = this.lastChild; let i, o = this.firstChild; for (; o !== e;)i = o.nextSibling, t.appendChild(o), o = i; t.appendChild(e) } dispose() { const t = this.firstChild.parentNode, e = this.lastChild; let i, o = this.firstChild; for (; o !== e;)i = o.nextSibling, t.removeChild(o), o = i; t.removeChild(e); const s = this.behaviors, n = this.source; for (let t = 0, e = s.length; t < e; ++t)s[t].unbind(n) } bind(t, e) { const i = this.behaviors; if (this.source !== t) if (null !== this.source) { const o = this.source; this.source = t, this.context = e; for (let s = 0, n = i.length; s < n; ++s) { const n = i[s]; n.unbind(o), n.bind(t, e) } } else { this.source = t, this.context = e; for (let o = 0, s = i.length; o < s; ++o)i[o].bind(t, e) } } unbind() { if (null === this.source) return; const t = this.behaviors, e = this.source; for (let i = 0, o = t.length; i < o; ++i)t[i].unbind(e); this.source = null } static disposeContiguousBatch(t) { if (0 !== t.length) { N.setStartBefore(t[0].firstChild), N.setEndAfter(t[t.length - 1].lastChild), N.deleteContents(); for (let e = 0, i = t.length; e < i; ++e) { const i = t[e], o = i.behaviors, s = i.source; for (let t = 0, e = o.length; t < e; ++t)o[t].unbind(s) } } } } class U { constructor(t, e) { this.behaviorCount = 0, this.hasHostBehaviors = !1, this.fragment = null, this.targetOffset = 0, this.viewBehaviorFactories = null, this.hostBehaviorFactories = null, this.html = t, this.directives = e } create(t) { if (null === this.fragment) { let t; const e = this.html; if ("string" == typeof e) { t = document.createElement("template"), t.innerHTML = d.createHTML(e); const i = t.content.firstElementChild; null !== i && "TEMPLATE" === i.tagName && (t = i) } else t = e; const i = function (t, e) { const i = t.content; document.adoptNode(i); const o = L.borrow(e); M(o, t, !0); const s = o.behaviorFactories; o.reset(); const n = d.createTemplateWalker(i); let r; for (; r = n.nextNode();)switch (o.targetIndex++, r.nodeType) { case 1: M(o, r); break; case 3: B(o, r, n); break; case 8: d.isMarker(r) && o.addFactory(e[d.extractDirectiveIndexFromMarker(r)]) }let a = 0; (d.isMarker(i.firstChild) || 1 === i.childNodes.length && e.length) && (i.insertBefore(document.createComment(""), i.firstChild), a = -1); const l = o.behaviorFactories; return o.release(), { fragment: i, viewBehaviorFactories: l, hostBehaviorFactories: s, targetOffset: a } }(t, this.directives); this.fragment = i.fragment, this.viewBehaviorFactories = i.viewBehaviorFactories, this.hostBehaviorFactories = i.hostBehaviorFactories, this.targetOffset = i.targetOffset, this.behaviorCount = this.viewBehaviorFactories.length + this.hostBehaviorFactories.length, this.hasHostBehaviors = this.hostBehaviorFactories.length > 0 } const e = this.fragment.cloneNode(!0), i = this.viewBehaviorFactories, o = new Array(this.behaviorCount), s = d.createTemplateWalker(e); let n = 0, r = this.targetOffset, a = s.nextNode(); for (let t = i.length; n < t; ++n) { const t = i[n], e = t.targetIndex; for (; null !== a;) { if (r === e) { o[n] = t.createBehavior(a); break } a = s.nextNode(), r++ } } if (this.hasHostBehaviors) { const e = this.hostBehaviorFactories; for (let i = 0, s = e.length; i < s; ++i, ++n)o[n] = e[i].createBehavior(t) } return new j(e, o) } render(t, e, i) { "string" == typeof e && (e = document.getElementById(e)), void 0 === i && (i = e); const o = this.create(i); return o.bind(t, b), o.appendTo(e), o } } const q = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/; function _(t, ...e) { const i = []; let o = ""; for (let s = 0, n = t.length - 1; s < n; ++s) { const n = t[s]; let r = e[s]; if (o += n, r instanceof U) { const t = r; r = () => t } if ("function" == typeof r && (r = new V(r)), r instanceof x) { const t = q.exec(n); null !== t && (r.targetName = t[2]) } r instanceof y ? (o += r.createPlaceholder(i.length), i.push(r)) : o += r } return o += t[t.length - 1], new U(o, i) } class G { constructor() { this.targets = new WeakSet } addStylesTo(t) { this.targets.add(t) } removeStylesFrom(t) { this.targets.delete(t) } isAttachedTo(t) { return this.targets.has(t) } withBehaviors(...t) { return this.behaviors = null === this.behaviors ? t : this.behaviors.concat(t), this } } function W(t) { return t.map(t => t instanceof G ? W(t.styles) : [t]).reduce((t, e) => t.concat(e), []) } function K(t) { return t.map(t => t instanceof G ? t.behaviors : null).reduce((t, e) => null === e ? t : (null === t && (t = []), t.concat(e)), null) } G.create = (() => { if (d.supportsAdoptedStyleSheets) { const t = new Map; return e => new X(e, t) } return t => new Q(t) })(); class X extends G { constructor(t, e) { super(), this.styles = t, this.styleSheetCache = e, this._styleSheets = void 0, this.behaviors = K(t) } get styleSheets() { if (void 0 === this._styleSheets) { const t = this.styles, e = this.styleSheetCache; this._styleSheets = W(t).map(t => { if (t instanceof CSSStyleSheet) return t; let i = e.get(t); return void 0 === i && (i = new CSSStyleSheet, i.replaceSync(t), e.set(t, i)), i }) } return this._styleSheets } addStylesTo(t) { t.adoptedStyleSheets = [...t.adoptedStyleSheets, ...this.styleSheets], super.addStylesTo(t) } removeStylesFrom(t) { const e = this.styleSheets; t.adoptedStyleSheets = t.adoptedStyleSheets.filter(t => -1 === e.indexOf(t)), super.removeStylesFrom(t) } } let Y = 0; class Q extends G { constructor(t) { super(), this.styles = t, this.behaviors = null, this.behaviors = K(t), this.styleSheets = W(t), this.styleClass = "fast-style-class-" + ++Y } addStylesTo(t) { const e = this.styleSheets, i = this.styleClass; t = this.normalizeTarget(t); for (let o = 0; o < e.length; o++) { const s = document.createElement("style"); s.innerHTML = e[o], s.className = i, t.append(s) } super.addStylesTo(t) } removeStylesFrom(t) { const e = (t = this.normalizeTarget(t)).querySelectorAll("." + this.styleClass); for (let i = 0, o = e.length; i < o; ++i)t.removeChild(e[i]); super.removeStylesFrom(t) } isAttachedTo(t) { return super.isAttachedTo(this.normalizeTarget(t)) } normalizeTarget(t) { return t === document ? document.body : t } } const Z = Object.freeze({ locate: s() }), J = { toView: t => t ? "true" : "false", fromView: t => null != t && "false" !== t && !1 !== t && 0 !== t }, tt = { toView(t) { if (null == t) return null; const e = 1 * t; return isNaN(e) ? null : e.toString() }, fromView(t) { if (null == t) return null; const e = 1 * t; return isNaN(e) ? null : e } }; class et { constructor(t, e, i = e.toLowerCase(), o = "reflect", s) { this.guards = new Set, this.Owner = t, this.name = e, this.attribute = i, this.mode = o, this.converter = s, this.fieldName = "_" + e, this.callbackName = e + "Changed", this.hasCallback = this.callbackName in t.prototype, "boolean" === o && void 0 === s && (this.converter = J) } setValue(t, e) { const i = t[this.fieldName], o = this.converter; void 0 !== o && (e = o.fromView(e)), i !== e && (t[this.fieldName] = e, this.tryReflectToAttribute(t), this.hasCallback && t[this.callbackName](i, e), t.$fastController.notify(this.name)) } getValue(t) { return g.track(t, this.name), t[this.fieldName] } onAttributeChangedCallback(t, e) { this.guards.has(t) || (this.guards.add(t), this.setValue(t, e), this.guards.delete(t)) } tryReflectToAttribute(t) { const e = this.mode, i = this.guards; i.has(t) || "fromView" === e || d.queueUpdate(() => { i.add(t); const o = t[this.fieldName]; switch (e) { case "reflect": const e = this.converter; d.setAttribute(t, this.attribute, void 0 !== e ? e.toView(o) : o); break; case "boolean": d.setBooleanAttribute(t, this.attribute, o) }i.delete(t) }) } static collect(t, ...e) { const i = []; e.push(Z.locate(t)); for (let o = 0, s = e.length; o < s; ++o) { const s = e[o]; if (void 0 !== s) for (let e = 0, o = s.length; e < o; ++e) { const o = s[e]; "string" == typeof o ? i.push(new et(t, o)) : i.push(new et(t, o.property, o.attribute, o.mode, o.converter)) } } return i } } function it(t, e) { let i; function o(t, e) { arguments.length > 1 && (i.property = e), Z.locate(t.constructor).push(i) } return arguments.length > 1 ? (i = {}, void o(t, e)) : (i = void 0 === t ? {} : t, o) } const ot = { mode: "open" }, st = {}, nt = i.getById(4, () => { const t = new Map; return Object.freeze({ register: e => !t.has(e.type) && (t.set(e.type, e), !0), getByType: e => t.get(e) }) }); class rt { constructor(t, e = t.definition) { "string" == typeof e && (e = { name: e }), this.type = t, this.name = e.name, this.template = e.template; const i = et.collect(t, e.attributes), o = new Array(i.length), s = {}, n = {}; for (let t = 0, e = i.length; t < e; ++t) { const e = i[t]; o[t] = e.attribute, s[e.name] = e, n[e.attribute] = e } this.attributes = i, this.observedAttributes = o, this.propertyLookup = s, this.attributeLookup = n, this.shadowOptions = void 0 === e.shadowOptions ? ot : null === e.shadowOptions ? void 0 : Object.assign(Object.assign({}, ot), e.shadowOptions), this.elementOptions = void 0 === e.elementOptions ? st : Object.assign(Object.assign({}, st), e.elementOptions), this.styles = void 0 === e.styles ? void 0 : Array.isArray(e.styles) ? G.create(e.styles) : e.styles instanceof G ? e.styles : G.create([e.styles]) } get isDefined() { return !!nt.getByType(this.type) } define(t = customElements) { const e = this.type; if (nt.register(this)) { const t = this.attributes, i = e.prototype; for (let e = 0, o = t.length; e < o; ++e)g.defineProperty(i, t[e]); Reflect.defineProperty(e, "observedAttributes", { value: this.observedAttributes, enumerable: !0 }) } return t.get(this.name) || t.define(this.name, e, this.elementOptions), this } } rt.forType = nt.getByType; const at = new WeakMap, lt = { bubbles: !0, composed: !0, cancelable: !0 }; function ct(t) { return t.shadowRoot || at.get(t) || null } class ht extends p { constructor(t, e) { super(t), this.boundObservables = null, this.behaviors = null, this.needsInitialization = !0, this._template = null, this._styles = null, this._isConnected = !1, this.$fastController = this, this.view = null, this.element = t, this.definition = e; const i = e.shadowOptions; if (void 0 !== i) { const e = t.attachShadow(i); "closed" === i.mode && at.set(t, e) } const o = g.getAccessors(t); if (o.length > 0) { const e = this.boundObservables = Object.create(null); for (let i = 0, s = o.length; i < s; ++i) { const s = o[i].name, n = t[s]; void 0 !== n && (delete t[s], e[s] = n) } } } get isConnected() { return g.track(this, "isConnected"), this._isConnected } setIsConnected(t) { this._isConnected = t, g.notify(this, "isConnected") } get template() { return this._template } set template(t) { this._template !== t && (this._template = t, this.needsInitialization || this.renderTemplate(t)) } get styles() { return this._styles } set styles(t) { this._styles !== t && (null !== this._styles && this.removeStyles(this._styles), this._styles = t, this.needsInitialization || null === t || this.addStyles(t)) } addStyles(t) { const e = ct(this.element) || this.element.getRootNode(); if (t instanceof HTMLStyleElement) e.append(t); else if (!t.isAttachedTo(e)) { const i = t.behaviors; t.addStylesTo(e), null !== i && this.addBehaviors(i) } } removeStyles(t) { const e = ct(this.element) || this.element.getRootNode(); if (t instanceof HTMLStyleElement) e.removeChild(t); else if (t.isAttachedTo(e)) { const i = t.behaviors; t.removeStylesFrom(e), null !== i && this.removeBehaviors(i) } } addBehaviors(t) { const e = this.behaviors || (this.behaviors = new Map), i = t.length, o = []; for (let s = 0; s < i; ++s) { const i = t[s]; e.has(i) ? e.set(i, e.get(i) + 1) : (e.set(i, 1), o.push(i)) } if (this._isConnected) { const t = this.element; for (let e = 0; e < o.length; ++e)o[e].bind(t, b) } } removeBehaviors(t, e = !1) { const i = this.behaviors; if (null === i) return; const o = t.length, s = []; for (let n = 0; n < o; ++n) { const o = t[n]; if (i.has(o)) { const t = i.get(o) - 1; 0 === t || e ? i.delete(o) && s.push(o) : i.set(o, t) } } if (this._isConnected) { const t = this.element; for (let e = 0; e < s.length; ++e)s[e].unbind(t) } } onConnectedCallback() { if (this._isConnected) return; const t = this.element; this.needsInitialization ? this.finishInitialization() : null !== this.view && this.view.bind(t, b); const e = this.behaviors; if (null !== e) for (const [i] of e) i.bind(t, b); this.setIsConnected(!0) } onDisconnectedCallback() { if (!this._isConnected) return; this.setIsConnected(!1); const t = this.view; null !== t && t.unbind(); const e = this.behaviors; if (null !== e) { const t = this.element; for (const [i] of e) i.unbind(t) } } onAttributeChangedCallback(t, e, i) { const o = this.definition.attributeLookup[t]; void 0 !== o && o.onAttributeChangedCallback(this.element, i) } emit(t, e, i) { return !!this._isConnected && this.element.dispatchEvent(new CustomEvent(t, Object.assign(Object.assign({ detail: e }, lt), i))) } finishInitialization() { const t = this.element, e = this.boundObservables; if (null !== e) { const i = Object.keys(e); for (let o = 0, s = i.length; o < s; ++o) { const s = i[o]; t[s] = e[s] } this.boundObservables = null } const i = this.definition; null === this._template && (this.element.resolveTemplate ? this._template = this.element.resolveTemplate() : i.template && (this._template = i.template || null)), null !== this._template && this.renderTemplate(this._template), null === this._styles && (this.element.resolveStyles ? this._styles = this.element.resolveStyles() : i.styles && (this._styles = i.styles || null)), null !== this._styles && this.addStyles(this._styles), this.needsInitialization = !1 } renderTemplate(t) { const e = this.element, i = ct(e) || e; null !== this.view ? (this.view.dispose(), this.view = null) : this.needsInitialization || d.removeChildNodes(i), t && (this.view = t.render(e, i, e)) } static forCustomElement(t) { const e = t.$fastController; if (void 0 !== e) return e; const i = rt.forType(t.constructor); if (void 0 === i) throw new Error("Missing FASTElement definition."); return t.$fastController = new ht(t, i) } } function dt(t) { return class extends t { constructor() { super(), ht.forCustomElement(this) } $emit(t, e, i) { return this.$fastController.emit(t, e, i) } connectedCallback() { this.$fastController.onConnectedCallback() } disconnectedCallback() { this.$fastController.onDisconnectedCallback() } attributeChangedCallback(t, e, i) { this.$fastController.onAttributeChangedCallback(t, e, i) } } } const ut = Object.assign(dt(HTMLElement), { from: t => dt(t), define: (t, e) => new rt(t, e).define().type }); class pt { createCSS() { return "" } createBehavior() { } } function gt(t, e) { const i = []; let o = ""; const s = []; for (let n = 0, r = t.length - 1; n < r; ++n) { o += t[n]; let r = e[n]; if (r instanceof pt) { const t = r.createBehavior(); r = r.createCSS(), t && s.push(t) } r instanceof G || r instanceof CSSStyleSheet ? ("" !== o.trim() && (i.push(o), o = ""), i.push(r)) : o += r } return o += t[t.length - 1], "" !== o.trim() && i.push(o), { styles: i, behaviors: s } } function ft(t, ...e) { const { styles: i, behaviors: o } = gt(t, e), s = G.create(i); return o.length && s.withBehaviors(...o), s } class mt extends pt { constructor(t, e) { super(), this.behaviors = e, this.css = ""; const i = t.reduce((t, e) => ("string" == typeof e ? this.css += e : t.push(e), t), []); i.length && (this.styles = G.create(i)) } createBehavior() { return this } createCSS() { return this.css } bind(t) { this.styles && t.$fastController.addStyles(this.styles), this.behaviors.length && t.$fastController.addBehaviors(this.behaviors) } unbind(t) { this.styles && t.$fastController.removeStyles(this.styles), this.behaviors.length && t.$fastController.removeBehaviors(this.behaviors) } } function vt(t, ...e) { const { styles: i, behaviors: o } = gt(t, e); return new mt(i, o) } function bt(t, e, i) { return { index: t, removed: e, addedCount: i } } function yt(t, e, i, s, n, r) { let a = 0, l = 0; const c = Math.min(i - e, r - n); if (0 === e && 0 === n && (a = function (t, e, i) { for (let o = 0; o < i; ++o)if (t[o] !== e[o]) return o; return i }(t, s, c)), i === t.length && r === s.length && (l = function (t, e, i) { let o = t.length, s = e.length, n = 0; for (; n < i && t[--o] === e[--s];)n++; return n }(t, s, c - a)), n += a, r -= l, (i -= l) - (e += a) == 0 && r - n == 0) return o; if (e === i) { const t = bt(e, [], 0); for (; n < r;)t.removed.push(s[n++]); return [t] } if (n === r) return [bt(e, [], i - e)]; const h = function (t) { let e = t.length - 1, i = t[0].length - 1, o = t[e][i]; const s = []; for (; e > 0 || i > 0;) { if (0 === e) { s.push(2), i--; continue } if (0 === i) { s.push(3), e--; continue } const n = t[e - 1][i - 1], r = t[e - 1][i], a = t[e][i - 1]; let l; l = r < a ? r < n ? r : n : a < n ? a : n, l === n ? (n === o ? s.push(0) : (s.push(1), o = n), e--, i--) : l === r ? (s.push(3), e--, o = r) : (s.push(2), i--, o = a) } return s.reverse(), s }(function (t, e, i, o, s, n) { const r = n - s + 1, a = i - e + 1, l = new Array(r); let c, h; for (let t = 0; t < r; ++t)l[t] = new Array(a), l[t][0] = t; for (let t = 0; t < a; ++t)l[0][t] = t; for (let i = 1; i < r; ++i)for (let n = 1; n < a; ++n)t[e + n - 1] === o[s + i - 1] ? l[i][n] = l[i - 1][n - 1] : (c = l[i - 1][n] + 1, h = l[i][n - 1] + 1, l[i][n] = c < h ? c : h); return l }(t, e, i, s, n, r)), d = []; let u = void 0, p = e, g = n; for (let t = 0; t < h.length; ++t)switch (h[t]) { case 0: void 0 !== u && (d.push(u), u = void 0), p++, g++; break; case 1: void 0 === u && (u = bt(p, [], 0)), u.addedCount++, p++, u.removed.push(s[g]), g++; break; case 2: void 0 === u && (u = bt(p, [], 0)), u.addedCount++, p++; break; case 3: void 0 === u && (u = bt(p, [], 0)), u.removed.push(s[g]), g++ }return void 0 !== u && d.push(u), d } const xt = Array.prototype.push; function $t(t, e, i, o) { const s = bt(e, i, o); let n = !1, r = 0; for (let e = 0; e < t.length; e++) { const i = t[e]; if (i.index += r, n) continue; const o = (a = s.index, l = s.index + s.removed.length, c = i.index, h = i.index + i.addedCount, l < c || h < a ? -1 : l === c || h === a ? 0 : a < c ? l < h ? l - c : h - c : h < l ? h - a : l - a); if (o >= 0) { t.splice(e, 1), e--, r -= i.addedCount - i.removed.length, s.addedCount += i.addedCount - o; const a = s.removed.length + i.removed.length - o; if (s.addedCount || a) { let t = i.removed; if (s.index < i.index) { const e = s.removed.slice(0, i.index - s.index); xt.apply(e, t), t = e } if (s.index + s.removed.length > i.index + i.addedCount) { const e = s.removed.slice(i.index + i.addedCount - s.index); xt.apply(t, e) } s.removed = t, i.index < s.index && (s.index = i.index) } else n = !0 } else if (s.index < i.index) { n = !0, t.splice(e, 0, s), e++; const o = s.addedCount - s.removed.length; i.index += o, r += o } } var a, l, c, h; n || t.push(s) } function wt(t, e) { let i = []; const o = function (t) { const e = []; for (let i = 0, o = t.length; i < o; i++) { const o = t[i]; $t(e, o.index, o.removed, o.addedCount) } return e }(e); for (let e = 0, s = o.length; e < s; ++e) { const s = o[e]; 1 !== s.addedCount || 1 !== s.removed.length ? i = i.concat(yt(t, s.index, s.index + s.addedCount, s.removed, 0, s.removed.length)) : s.removed[0] !== t[s.index] && i.push(s) } return i } let kt = !1; function Ct(t, e) { let i = t.index; const o = e.length; return i > o ? i = o - t.addedCount : i < 0 && (i = o + t.removed.length + i - t.addedCount), i < 0 && (i = 0), t.index = i, t } class It extends u { constructor(t) { super(t), this.oldCollection = void 0, this.splices = void 0, this.needsQueue = !0, this.call = this.flush, Reflect.defineProperty(t, "$fastController", { value: this, enumerable: !1 }) } subscribe(t) { this.flush(), super.subscribe(t) } addSplice(t) { void 0 === this.splices ? this.splices = [t] : this.splices.push(t), this.needsQueue && (this.needsQueue = !1, d.queueUpdate(this)) } reset(t) { this.oldCollection = t, this.needsQueue && (this.needsQueue = !1, d.queueUpdate(this)) } flush() { const t = this.splices, e = this.oldCollection; if (void 0 === t && void 0 === e) return; this.needsQueue = !0, this.splices = void 0, this.oldCollection = void 0; const i = void 0 === e ? wt(this.source, t) : yt(this.source, 0, this.source.length, e, 0, e.length); this.notify(i) } } class Ft { constructor(t, e) { this.target = t, this.propertyName = e } bind(t) { t[this.propertyName] = this.target } unbind() { } } function Dt(t) { return new $("fast-ref", Ft, t) } function Tt(t, e) { const i = "function" == typeof e ? e : () => e; return (e, o) => t(e, o) ? i(e, o) : null } const St = Object.freeze({ positioning: !1, recycle: !0 }); function Ot(t, e, i, o) { t.bind(e[i], o) } function Et(t, e, i, o) { const s = Object.create(o); s.index = i, s.length = e.length, t.bind(e[i], s) } class Vt { constructor(t, e, i, o, s, n) { this.location = t, this.itemsBinding = e, this.templateBinding = o, this.options = n, this.source = null, this.views = [], this.items = null, this.itemsObserver = null, this.originalContext = void 0, this.childContext = void 0, this.bindView = Ot, this.itemsBindingObserver = g.binding(e, this, i), this.templateBindingObserver = g.binding(o, this, s), n.positioning && (this.bindView = Et) } bind(t, e) { this.source = t, this.originalContext = e, this.childContext = Object.create(e), this.childContext.parent = t, this.childContext.parentContext = this.originalContext, this.items = this.itemsBindingObserver.observe(t, this.originalContext), this.template = this.templateBindingObserver.observe(t, this.originalContext), this.observeItems(!0), this.refreshAllViews() } unbind() { this.source = null, this.items = null, null !== this.itemsObserver && this.itemsObserver.unsubscribe(this), this.unbindAllViews(), this.itemsBindingObserver.disconnect(), this.templateBindingObserver.disconnect() } handleChange(t, e) { t === this.itemsBinding ? (this.items = this.itemsBindingObserver.observe(this.source, this.originalContext), this.observeItems(), this.refreshAllViews()) : t === this.templateBinding ? (this.template = this.templateBindingObserver.observe(this.source, this.originalContext), this.refreshAllViews(!0)) : this.updateViews(e) } observeItems(t = !1) { if (!this.items) return void (this.items = o); const e = this.itemsObserver, i = this.itemsObserver = g.getNotifier(this.items), s = e !== i; s && null !== e && e.unsubscribe(this), (s || t) && i.subscribe(this) } updateViews(t) { const e = this.childContext, i = this.views, o = this.bindView, s = this.items, n = this.template, r = this.options.recycle, a = []; let l = 0, c = 0; for (let h = 0, d = t.length; h < d; ++h) { const d = t[h], u = d.removed; let p = 0, g = d.index; const f = g + d.addedCount, m = i.splice(d.index, u.length), v = c = a.length + m.length; for (; g < f; ++g) { const t = i[g], h = t ? t.firstChild : this.location; let d; r && c > 0 ? (p <= v && m.length > 0 ? (d = m[p], p++) : (d = a[l], l++), c--) : d = n.create(), i.splice(g, 0, d), o(d, s, g, e), d.insertBefore(h) } m[p] && a.push(...m.slice(p)) } for (let t = l, e = a.length; t < e; ++t)a[t].dispose(); if (this.options.positioning) for (let t = 0, e = i.length; t < e; ++t) { const o = i[t].context; o.length = e, o.index = t } } refreshAllViews(t = !1) { const e = this.items, i = this.childContext, o = this.template, s = this.location, n = this.bindView; let r = e.length, a = this.views, l = a.length; if (0 !== r && !t && this.options.recycle || (j.disposeContiguousBatch(a), l = 0), 0 === l) { this.views = a = new Array(r); for (let t = 0; t < r; ++t) { const r = o.create(); n(r, e, t, i), a[t] = r, r.insertBefore(s) } } else { let t = 0; for (; t < r; ++t)if (t < l) { n(a[t], e, t, i) } else { const r = o.create(); n(r, e, t, i), a.push(r), r.insertBefore(s) } const c = a.splice(t, l - t); for (t = 0, r = c.length; t < r; ++t)c[t].dispose() } } unbindAllViews() { const t = this.views; for (let e = 0, i = t.length; e < i; ++e)t[e].unbind() } } class Rt extends y { constructor(t, e, i) { super(), this.itemsBinding = t, this.templateBinding = e, this.options = i, this.createPlaceholder = d.createBlockPlaceholder, function () { if (kt) return; kt = !0, g.setArrayObserverFactory(t => new It(t)); const t = Array.prototype; if (t.$fastPatch) return; Reflect.defineProperty(t, "$fastPatch", { value: 1, enumerable: !1 }); const e = t.pop, i = t.push, o = t.reverse, s = t.shift, n = t.sort, r = t.splice, a = t.unshift; t.pop = function () { const t = this.length > 0, i = e.apply(this, arguments), o = this.$fastController; return void 0 !== o && t && o.addSplice(bt(this.length, [i], 0)), i }, t.push = function () { const t = i.apply(this, arguments), e = this.$fastController; return void 0 !== e && e.addSplice(Ct(bt(this.length - arguments.length, [], arguments.length), this)), t }, t.reverse = function () { let t; const e = this.$fastController; void 0 !== e && (e.flush(), t = this.slice()); const i = o.apply(this, arguments); return void 0 !== e && e.reset(t), i }, t.shift = function () { const t = this.length > 0, e = s.apply(this, arguments), i = this.$fastController; return void 0 !== i && t && i.addSplice(bt(0, [e], 0)), e }, t.sort = function () { let t; const e = this.$fastController; void 0 !== e && (e.flush(), t = this.slice()); const i = n.apply(this, arguments); return void 0 !== e && e.reset(t), i }, t.splice = function () { const t = r.apply(this, arguments), e = this.$fastController; return void 0 !== e && e.addSplice(Ct(bt(+arguments[0], t, arguments.length > 2 ? arguments.length - 2 : 0), this)), t }, t.unshift = function () { const t = a.apply(this, arguments), e = this.$fastController; return void 0 !== e && e.addSplice(Ct(bt(0, [], arguments.length), this)), t } }(), this.isItemsBindingVolatile = g.isVolatileBinding(t), this.isTemplateBindingVolatile = g.isVolatileBinding(e) } createBehavior(t) { return new Vt(t, this.itemsBinding, this.isItemsBindingVolatile, this.templateBinding, this.isTemplateBindingVolatile, this.options) } } function At(t, e, i = St) { return new Rt(t, "function" == typeof e ? e : () => e, Object.assign(Object.assign({}, St), i)) } function Lt(t) { return t ? function (e, i, o) { return 1 === e.nodeType && e.matches(t) } : function (t, e, i) { return 1 === t.nodeType } } class Pt { constructor(t, e) { this.target = t, this.options = e, this.source = null } bind(t) { const e = this.options.property; this.shouldUpdate = g.getAccessors(t).some(t => t.name === e), this.source = t, this.updateTarget(this.computeNodes()), this.shouldUpdate && this.observe() } unbind() { this.updateTarget(o), this.source = null, this.shouldUpdate && this.disconnect() } handleEvent() { this.updateTarget(this.computeNodes()) } computeNodes() { let t = this.getNodes(); return void 0 !== this.options.filter && (t = t.filter(this.options.filter)), t } updateTarget(t) { this.source[this.options.property] = t } } class zt extends Pt { constructor(t, e) { super(t, e) } observe() { this.target.addEventListener("slotchange", this) } disconnect() { this.target.removeEventListener("slotchange", this) } getNodes() { return this.target.assignedNodes(this.options) } } function Ht(t) { return "string" == typeof t && (t = { property: t }), new $("fast-slotted", zt, t) } class Mt extends Pt { constructor(t, e) { super(t, e), this.observer = null, e.childList = !0 } observe() { null === this.observer && (this.observer = new MutationObserver(this.handleEvent.bind(this))), this.observer.observe(this.target, this.options) } disconnect() { this.observer.disconnect() } getNodes() { return "subtree" in this.options ? Array.from(this.target.querySelectorAll(this.options.selector)) : Array.from(this.target.childNodes) } } function Bt(t) { return "string" == typeof t && (t = { property: t }), new $("fast-children", Mt, t) } class Nt { handleStartContentChange() { this.startContainer.classList.toggle("start", this.start.assignedNodes().length > 0) } handleEndContentChange() { this.endContainer.classList.toggle("end", this.end.assignedNodes().length > 0) } } const jt = (t, e) => _`<span part="end" ${Dt("endContainer")} class=${t => e.end ? "end" : void 0}><slot name="end" ${Dt("end")} @slotchange="${t => t.handleEndContentChange()}">${e.end || ""}</slot></span>`, Ut = (t, e) => _`<span part="start" ${Dt("startContainer")} class="${t => e.start ? "start" : void 0}"><slot name="start" ${Dt("start")} @slotchange="${t => t.handleStartContentChange()}">${e.start || ""}</slot></span>`, qt = _`<span part="end" ${Dt("endContainer")}><slot name="end" ${Dt("end")} @slotchange="${t => t.handleEndContentChange()}"></slot></span>`, _t = _`<span part="start" ${Dt("startContainer")}><slot name="start" ${Dt("start")} @slotchange="${t => t.handleStartContentChange()}"></slot></span>`;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Gt(t, e, i, o) { var s, n = arguments.length, r = n < 3 ? e : null === o ? o = Object.getOwnPropertyDescriptor(e, i) : o; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(t, e, i, o); else for (var a = t.length - 1; a >= 0; a--)(s = t[a]) && (r = (n < 3 ? s(r) : n > 3 ? s(e, i, r) : s(e, i)) || r); return n > 3 && r && Object.defineProperty(e, i, r), r } const Wt = new Map; "metadata" in Reflect || (Reflect.metadata = function (t, e) { return function (i) { Reflect.defineMetadata(t, e, i) } }, Reflect.defineMetadata = function (t, e, i) { let o = Wt.get(i); void 0 === o && Wt.set(i, o = new Map), o.set(t, e) }, Reflect.getOwnMetadata = function (t, e) { const i = Wt.get(e); if (void 0 !== i) return i.get(t) }); class Kt { constructor(t, e) { this.container = t, this.key = e } instance(t) { return this.registerResolver(0, t) } singleton(t) { return this.registerResolver(1, t) } transient(t) { return this.registerResolver(2, t) } callback(t) { return this.registerResolver(3, t) } cachedCallback(t) { return this.registerResolver(3, me(t)) } aliasTo(t) { return this.registerResolver(5, t) } registerResolver(t, e) { const { container: i, key: o } = this; return this.container = this.key = void 0, i.registerResolver(o, new se(o, t, e)) } } function Xt(t) { const e = t.slice(), i = Object.keys(t), o = i.length; let s; for (let n = 0; n < o; ++n)s = i[n], Ce(s) || (e[s] = t[s]); return e } const Yt = Object.freeze({ none(t) { throw Error(t.toString() + " not registered, did you forget to add @singleton()?") }, singleton: t => new se(t, 1, t), transient: t => new se(t, 2, t) }), Qt = Object.freeze({ default: Object.freeze({ parentLocator: () => null, responsibleForOwnerRequests: !1, defaultResolver: Yt.singleton }) }), Zt = new Map; function Jt(t) { return e => Reflect.getOwnMetadata(t, e) } let te = null; const ee = Object.freeze({ createContainer: t => new ge(null, Object.assign({}, Qt.default, t)), findResponsibleContainer(t) { const e = t.$$container$$; return e && e.responsibleForOwnerRequests ? e : ee.findParentContainer(t) }, findParentContainer(t) { const e = new CustomEvent(ue, { bubbles: !0, composed: !0, cancelable: !0, detail: { container: void 0 } }); return t.dispatchEvent(e), e.detail.container || ee.getOrCreateDOMContainer() }, getOrCreateDOMContainer: (t, e) => t ? t.$$container$$ || new ge(t, Object.assign({}, Qt.default, e, { parentLocator: ee.findParentContainer })) : te || (te = new ge(null, Object.assign({}, Qt.default, e, { parentLocator: () => null }))), getDesignParamtypes: Jt("design:paramtypes"), getAnnotationParamtypes: Jt("di:paramtypes"), getOrCreateAnnotationParamTypes(t) { let e = this.getAnnotationParamtypes(t); return void 0 === e && Reflect.defineMetadata("di:paramtypes", e = [], t), e }, getDependencies(t) { let e = Zt.get(t); if (void 0 === e) { const i = t.inject; if (void 0 === i) { const i = ee.getDesignParamtypes(t), o = ee.getAnnotationParamtypes(t); if (void 0 === i) if (void 0 === o) { const i = Object.getPrototypeOf(t); e = "function" == typeof i && i !== Function.prototype ? Xt(ee.getDependencies(i)) : [] } else e = Xt(o); else if (void 0 === o) e = Xt(i); else { e = Xt(i); let t, s = o.length; for (let i = 0; i < s; ++i)t = o[i], void 0 !== t && (e[i] = t); const n = Object.keys(o); let r; s = n.length; for (let t = 0; t < s; ++t)r = n[t], Ce(r) || (e[r] = o[r]) } } else e = Xt(i); Zt.set(t, e) } return e }, defineProperty(t, e, i, o = !1) { const s = "$di_" + e; Reflect.defineProperty(t, e, { get: function () { let t = this[s]; if (void 0 === t) { const n = this instanceof HTMLElement ? ee.findResponsibleContainer(this) : ee.getOrCreateDOMContainer(); if (t = n.get(i), this[s] = t, o && this instanceof ut) { const o = this.$fastController, n = () => { ee.findResponsibleContainer(this).get(i) !== this[s] && (this[s] = t, o.notify(e)) }; o.subscribe({ handleChange: n }, "isConnected") } } return t } }) }, createInterface(t, e) { const i = "function" == typeof t ? t : e, o = "string" == typeof t ? t : t && "friendlyName" in t && t.friendlyName || xe, s = "string" != typeof t && (t && "respectConnection" in t && t.respectConnection || !1), n = function (t, e, i) { if (null == t || void 0 !== new.target) throw new Error(`No registration for interface: '${n.friendlyName}'`); if (e) ee.defineProperty(t, e, n, s); else { ee.getOrCreateAnnotationParamTypes(t)[i] = n } }; return n.$isInterface = !0, n.friendlyName = null == o ? "(anonymous)" : o, null != i && (n.register = function (t, e) { return i(new Kt(t, null != e ? e : n)) }), n.toString = function () { return `InterfaceSymbol<${n.friendlyName}>` }, n }, inject: (...t) => function (e, i, o) { if ("number" == typeof o) { const i = ee.getOrCreateAnnotationParamTypes(e), s = t[0]; void 0 !== s && (i[o] = s) } else if (i) ee.defineProperty(e, i, t[0]); else { const i = o ? ee.getOrCreateAnnotationParamTypes(o.value) : ee.getOrCreateAnnotationParamTypes(e); let s; for (let e = 0; e < t.length; ++e)s = t[e], void 0 !== s && (i[e] = s) } }, transient: t => (t.register = function (e) { return ve.transient(t, t).register(e) }, t.registerInRequestor = !1, t), singleton: (t, e = oe) => (t.register = function (e) { return ve.singleton(t, t).register(e) }, t.registerInRequestor = e.scoped, t) }), ie = ee.createInterface("Container"); ee.inject; const oe = { scoped: !1 }; class se { constructor(t, e, i) { this.key = t, this.strategy = e, this.state = i, this.resolving = !1 } get $isResolver() { return !0 } register(t) { return t.registerResolver(this.key, this) } resolve(t, e) { switch (this.strategy) { case 0: return this.state; case 1: if (this.resolving) throw new Error("Cyclic dependency found: " + this.state.name); return this.resolving = !0, this.state = t.getFactory(this.state).construct(e), this.strategy = 0, this.resolving = !1, this.state; case 2: { const i = t.getFactory(this.state); if (null === i) throw new Error(`Resolver for ${String(this.key)} returned a null factory`); return i.construct(e) } case 3: return this.state(t, e, this); case 4: return this.state[0].resolve(t, e); case 5: return e.get(this.state); default: throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`) } } getFactory(t) { var e, i, o; switch (this.strategy) { case 1: case 2: return t.getFactory(this.state); case 5: return null !== (o = null === (i = null === (e = t.getResolver(this.state)) || void 0 === e ? void 0 : e.getFactory) || void 0 === i ? void 0 : i.call(e, t)) && void 0 !== o ? o : null; default: return null } } } function ne(t) { return this.get(t) } function re(t, e) { return e(t) } class ae { constructor(t, e) { this.Type = t, this.dependencies = e, this.transformers = null } construct(t, e) { let i; return i = void 0 === e ? new this.Type(...this.dependencies.map(ne, t)) : new this.Type(...this.dependencies.map(ne, t), ...e), null == this.transformers ? i : this.transformers.reduce(re, i) } registerTransformer(t) { (this.transformers || (this.transformers = [])).push(t) } } const le = { $isResolver: !0, resolve: (t, e) => e }; function ce(t) { return "function" == typeof t.register } function he(t) { return function (t) { return ce(t) && "boolean" == typeof t.registerInRequestor }(t) && t.registerInRequestor } const de = new Set(["Array", "ArrayBuffer", "Boolean", "DataView", "Date", "Error", "EvalError", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Number", "Object", "Promise", "RangeError", "ReferenceError", "RegExp", "Set", "SharedArrayBuffer", "String", "SyntaxError", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "URIError", "WeakMap", "WeakSet"]), ue = "__DI_LOCATE_PARENT__", pe = new Map; class ge { constructor(t, e) { this.owner = t, this.config = e, this._parent = void 0, this.registerDepth = 0, this.context = null, null !== t && (t.$$container$$ = this), this.resolvers = new Map, this.resolvers.set(ie, le), t instanceof Node && t.addEventListener(ue, t => { t.composedPath()[0] !== this.owner && (t.detail.container = this, t.stopImmediatePropagation()) }) } get parent() { return void 0 === this._parent && (this._parent = this.config.parentLocator(this.owner)), this._parent } get depth() { return null === this.parent ? 0 : this.parent.depth + 1 } get responsibleForOwnerRequests() { return this.config.responsibleForOwnerRequests } registerWithContext(t, ...e) { return this.context = t, this.register(...e), this.context = null, this } register(...t) { if (100 == ++this.registerDepth) throw new Error("Unable to autoregister dependency"); let e, i, o, s, n; const r = this.context; for (let a = 0, l = t.length; a < l; ++a)if (e = t[a], $e(e)) if (ce(e)) e.register(this, r); else if (void 0 !== e.prototype) ve.singleton(e, e).register(this); else for (i = Object.keys(e), s = 0, n = i.length; s < n; ++s)o = e[i[s]], $e(o) && (ce(o) ? o.register(this, r) : this.register(o)); return --this.registerDepth, this } registerResolver(t, e) { be(t); const i = this.resolvers, o = i.get(t); return null == o ? i.set(t, e) : o instanceof se && 4 === o.strategy ? o.state.push(e) : i.set(t, new se(t, 4, [o, e])), e } registerTransformer(t, e) { const i = this.getResolver(t); if (null == i) return !1; if (i.getFactory) { const t = i.getFactory(this); return null != t && (t.registerTransformer(e), !0) } return !1 } getResolver(t, e = !0) { if (be(t), void 0 !== t.resolve) return t; let i, o = this; for (; null != o;) { if (i = o.resolvers.get(t), null != i) return i; if (null == o.parent) { const i = he(t) ? this : o; return e ? this.jitRegister(t, i) : null } o = o.parent } return null } has(t, e = !1) { return !!this.resolvers.has(t) || !(!e || null == this.parent) && this.parent.has(t, !0) } get(t) { if (be(t), t.$isResolver) return t.resolve(this, this); let e, i = this; for (; null != i;) { if (e = i.resolvers.get(t), null != e) return e.resolve(i, this); if (null == i.parent) { const o = he(t) ? this : i; return e = this.jitRegister(t, o), e.resolve(i, this) } i = i.parent } throw new Error("Unable to resolve key: " + t) } getAll(t, e = !1) { be(t); const i = this; let s, n = i; if (e) { let e = o; for (; null != n;)s = n.resolvers.get(t), null != s && (e = e.concat(ye(s, n, i))), n = n.parent; return e } for (; null != n;) { if (s = n.resolvers.get(t), null != s) return ye(s, n, i); if (n = n.parent, null == n) return o } return o } getFactory(t) { let e = pe.get(t); if (void 0 === e) { if (we(t)) throw new Error(t.name + " is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver."); pe.set(t, e = new ae(t, ee.getDependencies(t))) } return e } registerFactory(t, e) { pe.set(t, e) } createChild(t) { return new ge(null, Object.assign({}, this.config, t, { parentLocator: () => this })) } jitRegister(t, e) { if ("function" != typeof t) throw new Error(`Attempted to jitRegister something that is not a constructor: '${t}'. Did you forget to register this dependency?`); if (de.has(t.name)) throw new Error(`Attempted to jitRegister an intrinsic type: ${t.name}. Did you forget to add @inject(Key)`); if (ce(t)) { const i = t.register(e); if (!(i instanceof Object) || null == i.resolve) { const i = e.resolvers.get(t); if (null != i) return i; throw new Error("A valid resolver was not returned from the static register method") } return i } if (t.$isInterface) throw new Error("Attempted to jitRegister an interface: " + t.friendlyName); { const i = this.config.defaultResolver(t, e); return e.resolvers.set(t, i), i } } } const fe = new WeakMap; function me(t) { return function (e, i, o) { if (fe.has(o)) return fe.get(o); const s = t(e, i, o); return fe.set(o, s), s } } const ve = Object.freeze({ instance: (t, e) => new se(t, 0, e), singleton: (t, e) => new se(t, 1, e), transient: (t, e) => new se(t, 2, e), callback: (t, e) => new se(t, 3, e), cachedCallback: (t, e) => new se(t, 3, me(e)), aliasTo: (t, e) => new se(e, 5, t) }); function be(t) { if (null == t) throw new Error("key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?") } function ye(t, e, i) { if (t instanceof se && 4 === t.strategy) { const o = t.state; let s = o.length; const n = new Array(s); for (; s--;)n[s] = o[s].resolve(e, i); return n } return [t.resolve(e, i)] } const xe = "(anonymous)"; function $e(t) { return "object" == typeof t && null !== t || "function" == typeof t } const we = function () { const t = new WeakMap; let e = !1, i = "", o = 0; return function (s) { return e = t.get(s), void 0 === e && (i = s.toString(), o = i.length, e = o >= 29 && o <= 100 && 125 === i.charCodeAt(o - 1) && i.charCodeAt(o - 2) <= 32 && 93 === i.charCodeAt(o - 3) && 101 === i.charCodeAt(o - 4) && 100 === i.charCodeAt(o - 5) && 111 === i.charCodeAt(o - 6) && 99 === i.charCodeAt(o - 7) && 32 === i.charCodeAt(o - 8) && 101 === i.charCodeAt(o - 9) && 118 === i.charCodeAt(o - 10) && 105 === i.charCodeAt(o - 11) && 116 === i.charCodeAt(o - 12) && 97 === i.charCodeAt(o - 13) && 110 === i.charCodeAt(o - 14) && 88 === i.charCodeAt(o - 15), t.set(s, e)), e } }(), ke = {}; function Ce(t) { switch (typeof t) { case "number": return t >= 0 && (0 | t) === t; case "string": { const e = ke[t]; if (void 0 !== e) return e; const i = t.length; if (0 === i) return ke[t] = !1; let o = 0; for (let e = 0; e < i; ++e)if (o = t.charCodeAt(e), 0 === e && 48 === o && i > 1 || o < 48 || o > 57) return ke[t] = !1; return ke[t] = !0 } default: return !1 } } function Ie(t) { return t.toLowerCase() + ":presentation" } const Fe = new Map, De = Object.freeze({ define(t, e, i) { const o = Ie(t); void 0 === Fe.get(o) ? Fe.set(o, e) : Fe.set(o, !1), i.register(ve.instance(o, e)) }, forTag(t, e) { const i = Ie(t), o = Fe.get(i); if (!1 === o) { return ee.findResponsibleContainer(e).get(i) } return o || null } }); class Te { constructor(t, e) { this.template = t || null, this.styles = void 0 === e ? null : Array.isArray(e) ? G.create(e) : e instanceof G ? e : G.create([e]) } applyTo(t) { const e = t.$fastController; null === e.template && (e.template = this.template), null === e.styles && (e.styles = this.styles) } } class Se extends ut { constructor() { super(...arguments), this._presentation = void 0 } get $presentation() { return void 0 === this._presentation && (this._presentation = De.forTag(this.tagName, this)), this._presentation } templateChanged() { void 0 !== this.template && (this.$fastController.template = this.template) } stylesChanged() { void 0 !== this.styles && (this.$fastController.styles = this.styles) } connectedCallback() { null !== this.$presentation && this.$presentation.applyTo(this), super.connectedCallback() } static compose(t) { return (e = {}) => new Ee(this === Se ? class extends Se { } : this, t, e) } } function Oe(t, e, i) { return "function" == typeof t ? t(e, i) : t } Gt([f], Se.prototype, "template", void 0), Gt([f], Se.prototype, "styles", void 0); class Ee { constructor(t, e, i) { this.type = t, this.elementDefinition = e, this.overrideDefinition = i, this.definition = Object.assign(Object.assign({}, this.elementDefinition), this.overrideDefinition) } register(t, e) { const i = this.definition, o = this.overrideDefinition, s = `${i.prefix || e.elementPrefix}-${i.baseName}`; e.tryDefineElement({ name: s, type: this.type, baseClass: this.elementDefinition.baseClass, callback: t => { const e = new Te(Oe(i.template, t, i), Oe(i.styles, t, i)); t.definePresentation(e); let s = Oe(i.shadowOptions, t, i); t.shadowRootMode && (s ? o.shadowOptions || (s.mode = t.shadowRootMode) : null !== s && (s = { mode: t.shadowRootMode })), t.defineElement({ elementOptions: Oe(i.elementOptions, t, i), shadowOptions: s, attributes: Oe(i.attributes, t, i) }) } }) } } function Ve(t, ...e) { const i = Z.locate(t); e.forEach(e => { Object.getOwnPropertyNames(e.prototype).forEach(i => { "constructor" !== i && Object.defineProperty(t.prototype, i, Object.getOwnPropertyDescriptor(e.prototype, i)) }); Z.locate(e).forEach(t => i.push(t)) }) } class Re extends Se { constructor() { super(...arguments), this.headinglevel = 2, this.expanded = !1, this.clickHandler = t => { this.expanded = !this.expanded, this.change() }, this.change = () => { this.$emit("change") } } } Gt([it({ attribute: "heading-level", mode: "fromView", converter: tt })], Re.prototype, "headinglevel", void 0), Gt([it({ mode: "boolean" })], Re.prototype, "expanded", void 0), Gt([it], Re.prototype, "id", void 0), Ve(Re, Nt); const Ae = "horizontal", Le = "vertical"; function Pe(...t) { return t.every(t => t instanceof HTMLElement) } let ze; var He; !function (t) { t[t.alt = 18] = "alt", t[t.arrowDown = 40] = "arrowDown", t[t.arrowLeft = 37] = "arrowLeft", t[t.arrowRight = 39] = "arrowRight", t[t.arrowUp = 38] = "arrowUp", t[t.back = 8] = "back", t[t.backSlash = 220] = "backSlash", t[t.break = 19] = "break", t[t.capsLock = 20] = "capsLock", t[t.closeBracket = 221] = "closeBracket", t[t.colon = 186] = "colon", t[t.colon2 = 59] = "colon2", t[t.comma = 188] = "comma", t[t.ctrl = 17] = "ctrl", t[t.delete = 46] = "delete", t[t.end = 35] = "end", t[t.enter = 13] = "enter", t[t.equals = 187] = "equals", t[t.equals2 = 61] = "equals2", t[t.equals3 = 107] = "equals3", t[t.escape = 27] = "escape", t[t.forwardSlash = 191] = "forwardSlash", t[t.function1 = 112] = "function1", t[t.function10 = 121] = "function10", t[t.function11 = 122] = "function11", t[t.function12 = 123] = "function12", t[t.function2 = 113] = "function2", t[t.function3 = 114] = "function3", t[t.function4 = 115] = "function4", t[t.function5 = 116] = "function5", t[t.function6 = 117] = "function6", t[t.function7 = 118] = "function7", t[t.function8 = 119] = "function8", t[t.function9 = 120] = "function9", t[t.home = 36] = "home", t[t.insert = 45] = "insert", t[t.menu = 93] = "menu", t[t.minus = 189] = "minus", t[t.minus2 = 109] = "minus2", t[t.numLock = 144] = "numLock", t[t.numPad0 = 96] = "numPad0", t[t.numPad1 = 97] = "numPad1", t[t.numPad2 = 98] = "numPad2", t[t.numPad3 = 99] = "numPad3", t[t.numPad4 = 100] = "numPad4", t[t.numPad5 = 101] = "numPad5", t[t.numPad6 = 102] = "numPad6", t[t.numPad7 = 103] = "numPad7", t[t.numPad8 = 104] = "numPad8", t[t.numPad9 = 105] = "numPad9", t[t.numPadDivide = 111] = "numPadDivide", t[t.numPadDot = 110] = "numPadDot", t[t.numPadMinus = 109] = "numPadMinus", t[t.numPadMultiply = 106] = "numPadMultiply", t[t.numPadPlus = 107] = "numPadPlus", t[t.openBracket = 219] = "openBracket", t[t.pageDown = 34] = "pageDown", t[t.pageUp = 33] = "pageUp", t[t.period = 190] = "period", t[t.print = 44] = "print", t[t.quote = 222] = "quote", t[t.scrollLock = 145] = "scrollLock", t[t.shift = 16] = "shift", t[t.space = 32] = "space", t[t.tab = 9] = "tab", t[t.tilde = 192] = "tilde", t[t.windowsLeft = 91] = "windowsLeft", t[t.windowsOpera = 219] = "windowsOpera", t[t.windowsRight = 92] = "windowsRight" }(He || (He = {})); const Me = { ArrowDown: "ArrowDown", ArrowLeft: "ArrowLeft", ArrowRight: "ArrowRight", ArrowUp: "ArrowUp" }; var Be; function Ne(t, e, i) { return i < t ? e : i > e ? t : i } function je(t, e, i) { return Math.min(Math.max(i, t), e) } function Ue(t, e, i = 0) { return [e, i] = [e, i].sort((t, e) => t - e), e <= t && t < i } !function (t) { t.ltr = "ltr", t.rtl = "rtl" }(Be || (Be = {})); let qe = 0; function _e(t = "") { return `${t}${qe++}` } var Ge; !function (t) { t.Canvas = "Canvas", t.CanvasText = "CanvasText", t.LinkText = "LinkText", t.VisitedText = "VisitedText", t.ActiveText = "ActiveText", t.ButtonFace = "ButtonFace", t.ButtonText = "ButtonText", t.Field = "Field", t.FieldText = "FieldText", t.Highlight = "Highlight", t.HighlightText = "HighlightText", t.GrayText = "GrayText" }(Ge || (Ge = {})); const We = "single", Ke = "multi"; class Xe extends Se { constructor() { super(...arguments), this.expandmode = Ke, this.activeItemIndex = 0, this.change = () => { this.$emit("change", this.activeid) }, this.setItems = () => { var t; if (0 !== this.accordionItems.length && (this.accordionIds = this.getItemIds(), this.accordionItems.forEach((t, e) => { t instanceof Re && (t.addEventListener("change", this.activeItemChange), this.isSingleExpandMode() && (this.activeItemIndex !== e ? t.expanded = !1 : t.expanded = !0)); const i = this.accordionIds[e]; t.setAttribute("id", "string" != typeof i ? "accordion-" + (e + 1) : i), this.activeid = this.accordionIds[this.activeItemIndex], t.addEventListener("keydown", this.handleItemKeyDown), t.addEventListener("focus", this.handleItemFocus) }), this.isSingleExpandMode())) { (null !== (t = this.findExpandedItem()) && void 0 !== t ? t : this.accordionItems[0]).setAttribute("aria-disabled", "true") } }, this.removeItemListeners = t => { t.forEach((t, e) => { t.removeEventListener("change", this.activeItemChange), t.removeEventListener("keydown", this.handleItemKeyDown), t.removeEventListener("focus", this.handleItemFocus) }) }, this.activeItemChange = t => { if (t.defaultPrevented || t.target !== t.currentTarget) return; t.preventDefault(); const e = t.target; this.activeid = e.getAttribute("id"), this.isSingleExpandMode() && (this.resetItems(), e.expanded = !0, e.setAttribute("aria-disabled", "true"), this.accordionItems.forEach(t => { t.hasAttribute("disabled") || t.id === this.activeid || t.removeAttribute("aria-disabled") })), this.activeItemIndex = Array.from(this.accordionItems).indexOf(e), this.change() }, this.handleItemKeyDown = t => { if (t.target === t.currentTarget) switch (this.accordionIds = this.getItemIds(), t.key) { case "ArrowUp": t.preventDefault(), this.adjust(-1); break; case "ArrowDown": t.preventDefault(), this.adjust(1); break; case "Home": this.activeItemIndex = 0, this.focusItem(); break; case "End": this.activeItemIndex = this.accordionItems.length - 1, this.focusItem() } }, this.handleItemFocus = t => { if (t.target === t.currentTarget) { const e = t.target, i = this.activeItemIndex = Array.from(this.accordionItems).indexOf(e); this.activeItemIndex !== i && -1 !== i && (this.activeItemIndex = i, this.activeid = this.accordionIds[this.activeItemIndex]) } } } accordionItemsChanged(t, e) { this.$fastController.isConnected && (this.removeItemListeners(t), this.setItems()) } findExpandedItem() { for (let t = 0; t < this.accordionItems.length; t++)if ("true" === this.accordionItems[t].getAttribute("expanded")) return this.accordionItems[t]; return null } resetItems() { this.accordionItems.forEach((t, e) => { t.expanded = !1 }) } getItemIds() { return this.accordionItems.map(t => t.getAttribute("id")) } isSingleExpandMode() { return this.expandmode === We } adjust(t) { this.activeItemIndex = Ne(0, this.accordionItems.length - 1, this.activeItemIndex + t), this.focusItem() } focusItem() { const t = this.accordionItems[this.activeItemIndex]; t instanceof Re && t.expandbutton.focus() } } Gt([it({ attribute: "expand-mode" })], Xe.prototype, "expandmode", void 0), Gt([f], Xe.prototype, "accordionItems", void 0); const Ye = (t, e) => _`<a class="control" part="control" download="${t => t.download}" href="${t => t.href}" hreflang="${t => t.hreflang}" ping="${t => t.ping}" referrerpolicy="${t => t.referrerpolicy}" rel="${t => t.rel}" target="${t => t.target}" type="${t => t.type}" aria-atomic="${t => t.ariaAtomic}" aria-busy="${t => t.ariaBusy}" aria-controls="${t => t.ariaControls}" aria-current="${t => t.ariaCurrent}" aria-describedby="${t => t.ariaDescribedby}" aria-details="${t => t.ariaDetails}" aria-disabled="${t => t.ariaDisabled}" aria-errormessage="${t => t.ariaErrormessage}" aria-expanded="${t => t.ariaExpanded}" aria-flowto="${t => t.ariaFlowto}" aria-haspopup="${t => t.ariaHaspopup}" aria-hidden="${t => t.ariaHidden}" aria-invalid="${t => t.ariaInvalid}" aria-keyshortcuts="${t => t.ariaKeyshortcuts}" aria-label="${t => t.ariaLabel}" aria-labelledby="${t => t.ariaLabelledby}" aria-live="${t => t.ariaLive}" aria-owns="${t => t.ariaOwns}" aria-relevant="${t => t.ariaRelevant}" aria-roledescription="${t => t.ariaRoledescription}" ${Dt("control")}>${Ut(0, e)}<span class="content" part="content"><slot ${Ht("defaultSlottedContent")}></slot></span>${jt(0, e)}</a>`; class Qe { } Gt([it({ attribute: "aria-atomic" })], Qe.prototype, "ariaAtomic", void 0), Gt([it({ attribute: "aria-busy" })], Qe.prototype, "ariaBusy", void 0), Gt([it({ attribute: "aria-controls" })], Qe.prototype, "ariaControls", void 0), Gt([it({ attribute: "aria-current" })], Qe.prototype, "ariaCurrent", void 0), Gt([it({ attribute: "aria-describedby" })], Qe.prototype, "ariaDescribedby", void 0), Gt([it({ attribute: "aria-details" })], Qe.prototype, "ariaDetails", void 0), Gt([it({ attribute: "aria-disabled" })], Qe.prototype, "ariaDisabled", void 0), Gt([it({ attribute: "aria-errormessage" })], Qe.prototype, "ariaErrormessage", void 0), Gt([it({ attribute: "aria-flowto" })], Qe.prototype, "ariaFlowto", void 0), Gt([it({ attribute: "aria-haspopup" })], Qe.prototype, "ariaHaspopup", void 0), Gt([it({ attribute: "aria-hidden" })], Qe.prototype, "ariaHidden", void 0), Gt([it({ attribute: "aria-invalid" })], Qe.prototype, "ariaInvalid", void 0), Gt([it({ attribute: "aria-keyshortcuts" })], Qe.prototype, "ariaKeyshortcuts", void 0), Gt([it({ attribute: "aria-label" })], Qe.prototype, "ariaLabel", void 0), Gt([it({ attribute: "aria-labelledby" })], Qe.prototype, "ariaLabelledby", void 0), Gt([it({ attribute: "aria-live" })], Qe.prototype, "ariaLive", void 0), Gt([it({ attribute: "aria-owns" })], Qe.prototype, "ariaOwns", void 0), Gt([it({ attribute: "aria-relevant" })], Qe.prototype, "ariaRelevant", void 0), Gt([it({ attribute: "aria-roledescription" })], Qe.prototype, "ariaRoledescription", void 0); class Ze extends Se { constructor() { super(...arguments), this.handleUnsupportedDelegatesFocus = () => { var t; window.ShadowRoot && !window.ShadowRoot.prototype.hasOwnProperty("delegatesFocus") && (null === (t = this.$fastController.definition.shadowOptions) || void 0 === t ? void 0 : t.delegatesFocus) && (this.focus = () => { this.control.focus() }) } } connectedCallback() { super.connectedCallback(), this.handleUnsupportedDelegatesFocus() } } Gt([it], Ze.prototype, "download", void 0), Gt([it], Ze.prototype, "href", void 0), Gt([it], Ze.prototype, "hreflang", void 0), Gt([it], Ze.prototype, "ping", void 0), Gt([it], Ze.prototype, "referrerpolicy", void 0), Gt([it], Ze.prototype, "rel", void 0), Gt([it], Ze.prototype, "target", void 0), Gt([it], Ze.prototype, "type", void 0), Gt([f], Ze.prototype, "defaultSlottedContent", void 0); class Je { } Gt([it({ attribute: "aria-expanded" })], Je.prototype, "ariaExpanded", void 0), Ve(Je, Qe), Ve(Ze, Nt, Je); const ti = t => { const e = t.closest("[dir]"); return null !== e && "rtl" === e.dir ? Be.rtl : Be.ltr }; class ei extends Se { constructor() { super(...arguments), this.anchor = "", this.viewport = "", this.horizontalPositioningMode = "uncontrolled", this.horizontalDefaultPosition = "unset", this.horizontalViewportLock = !1, this.horizontalInset = !1, this.horizontalScaling = "content", this.verticalPositioningMode = "uncontrolled", this.verticalDefaultPosition = "unset", this.verticalViewportLock = !1, this.verticalInset = !1, this.verticalScaling = "content", this.fixedPlacement = !1, this.autoUpdateMode = "anchor", this.anchorElement = null, this.viewportElement = null, this.initialLayoutComplete = !1, this.resizeDetector = null, this.baseHorizontalOffset = 0, this.baseVerticalOffset = 0, this.pendingPositioningUpdate = !1, this.pendingReset = !1, this.currentDirection = Be.ltr, this.regionVisible = !1, this.forceUpdate = !1, this.updateThreshold = .5, this.update = () => { this.pendingPositioningUpdate || this.requestPositionUpdates() }, this.startObservers = () => { this.stopObservers(), null !== this.anchorElement && (this.requestPositionUpdates(), null !== this.resizeDetector && (this.resizeDetector.observe(this.anchorElement), this.resizeDetector.observe(this))) }, this.requestPositionUpdates = () => { null === this.anchorElement || this.pendingPositioningUpdate || (ei.intersectionService.requestPosition(this, this.handleIntersection), ei.intersectionService.requestPosition(this.anchorElement, this.handleIntersection), null !== this.viewportElement && ei.intersectionService.requestPosition(this.viewportElement, this.handleIntersection), this.pendingPositioningUpdate = !0) }, this.stopObservers = () => { this.pendingPositioningUpdate && (this.pendingPositioningUpdate = !1, ei.intersectionService.cancelRequestPosition(this, this.handleIntersection), null !== this.anchorElement && ei.intersectionService.cancelRequestPosition(this.anchorElement, this.handleIntersection), null !== this.viewportElement && ei.intersectionService.cancelRequestPosition(this.viewportElement, this.handleIntersection)), null !== this.resizeDetector && this.resizeDetector.disconnect() }, this.getViewport = () => "string" != typeof this.viewport || "" === this.viewport ? document.documentElement : document.getElementById(this.viewport), this.getAnchor = () => document.getElementById(this.anchor), this.handleIntersection = t => { this.pendingPositioningUpdate && (this.pendingPositioningUpdate = !1, this.applyIntersectionEntries(t) && this.updateLayout()) }, this.applyIntersectionEntries = t => { const e = t.find(t => t.target === this), i = t.find(t => t.target === this.anchorElement), o = t.find(t => t.target === this.viewportElement); return void 0 !== e && void 0 !== o && void 0 !== i && (!!(!this.regionVisible || this.forceUpdate || void 0 === this.regionRect || void 0 === this.anchorRect || void 0 === this.viewportRect || this.isRectDifferent(this.anchorRect, i.boundingClientRect) || this.isRectDifferent(this.viewportRect, o.boundingClientRect) || this.isRectDifferent(this.regionRect, e.boundingClientRect)) && (this.regionRect = e.boundingClientRect, this.anchorRect = i.boundingClientRect, this.viewportElement === document.documentElement ? this.viewportRect = new DOMRectReadOnly(o.boundingClientRect.x + document.documentElement.scrollLeft, o.boundingClientRect.y + document.documentElement.scrollTop, o.boundingClientRect.width, o.boundingClientRect.height) : this.viewportRect = o.boundingClientRect, this.updateRegionOffset(), this.forceUpdate = !1, !0)) }, this.updateRegionOffset = () => { this.anchorRect && this.regionRect && (this.baseHorizontalOffset = this.baseHorizontalOffset + (this.anchorRect.left - this.regionRect.left) + (this.translateX - this.baseHorizontalOffset), this.baseVerticalOffset = this.baseVerticalOffset + (this.anchorRect.top - this.regionRect.top) + (this.translateY - this.baseVerticalOffset)) }, this.isRectDifferent = (t, e) => Math.abs(t.top - e.top) > this.updateThreshold || Math.abs(t.right - e.right) > this.updateThreshold || Math.abs(t.bottom - e.bottom) > this.updateThreshold || Math.abs(t.left - e.left) > this.updateThreshold, this.handleResize = t => { this.update() }, this.reset = () => { this.pendingReset && (this.pendingReset = !1, null === this.anchorElement && (this.anchorElement = this.getAnchor()), null === this.viewportElement && (this.viewportElement = this.getViewport()), this.currentDirection = ti(this), this.startObservers()) }, this.updateLayout = () => { let t = void 0, e = void 0; if ("uncontrolled" !== this.horizontalPositioningMode) { const t = this.getPositioningOptions(this.horizontalInset); if ("center" === this.horizontalDefaultPosition) e = "center"; else if ("unset" !== this.horizontalDefaultPosition) { let t = this.horizontalDefaultPosition; if ("start" === t || "end" === t) { const e = ti(this); if (e !== this.currentDirection) return this.currentDirection = e, void this.initialize(); t = this.currentDirection === Be.ltr ? "start" === t ? "left" : "right" : "start" === t ? "right" : "left" } switch (t) { case "left": e = this.horizontalInset ? "insetStart" : "start"; break; case "right": e = this.horizontalInset ? "insetEnd" : "end" } } const i = void 0 !== this.horizontalThreshold ? this.horizontalThreshold : void 0 !== this.regionRect ? this.regionRect.width : 0, o = void 0 !== this.anchorRect ? this.anchorRect.left : 0, s = void 0 !== this.anchorRect ? this.anchorRect.right : 0, n = void 0 !== this.anchorRect ? this.anchorRect.width : 0, r = void 0 !== this.viewportRect ? this.viewportRect.left : 0, a = void 0 !== this.viewportRect ? this.viewportRect.right : 0; (void 0 === e || "locktodefault" !== this.horizontalPositioningMode && this.getAvailableSpace(e, o, s, n, r, a) < i) && (e = this.getAvailableSpace(t[0], o, s, n, r, a) > this.getAvailableSpace(t[1], o, s, n, r, a) ? t[0] : t[1]) } if ("uncontrolled" !== this.verticalPositioningMode) { const e = this.getPositioningOptions(this.verticalInset); if ("center" === this.verticalDefaultPosition) t = "center"; else if ("unset" !== this.verticalDefaultPosition) switch (this.verticalDefaultPosition) { case "top": t = this.verticalInset ? "insetStart" : "start"; break; case "bottom": t = this.verticalInset ? "insetEnd" : "end" }const i = void 0 !== this.verticalThreshold ? this.verticalThreshold : void 0 !== this.regionRect ? this.regionRect.height : 0, o = void 0 !== this.anchorRect ? this.anchorRect.top : 0, s = void 0 !== this.anchorRect ? this.anchorRect.bottom : 0, n = void 0 !== this.anchorRect ? this.anchorRect.height : 0, r = void 0 !== this.viewportRect ? this.viewportRect.top : 0, a = void 0 !== this.viewportRect ? this.viewportRect.bottom : 0; (void 0 === t || "locktodefault" !== this.verticalPositioningMode && this.getAvailableSpace(t, o, s, n, r, a) < i) && (t = this.getAvailableSpace(e[0], o, s, n, r, a) > this.getAvailableSpace(e[1], o, s, n, r, a) ? e[0] : e[1]) } const i = this.getNextRegionDimension(e, t), o = this.horizontalPosition !== e || this.verticalPosition !== t; if (this.setHorizontalPosition(e, i), this.setVerticalPosition(t, i), this.updateRegionStyle(), !this.initialLayoutComplete) return this.initialLayoutComplete = !0, void this.requestPositionUpdates(); this.regionVisible || (this.regionVisible = !0, this.style.removeProperty("pointer-events"), this.style.removeProperty("opacity"), this.classList.toggle("loaded", !0), this.$emit("loaded", this, { bubbles: !1 })), this.updatePositionClasses(), o && this.$emit("positionchange", this, { bubbles: !1 }) }, this.updateRegionStyle = () => { this.style.width = this.regionWidth, this.style.height = this.regionHeight, this.style.transform = `translate(${this.translateX}px, ${this.translateY}px)` }, this.updatePositionClasses = () => { this.classList.toggle("top", "start" === this.verticalPosition), this.classList.toggle("bottom", "end" === this.verticalPosition), this.classList.toggle("inset-top", "insetStart" === this.verticalPosition), this.classList.toggle("inset-bottom", "insetEnd" === this.verticalPosition), this.classList.toggle("vertical-center", "center" === this.verticalPosition), this.classList.toggle("left", "start" === this.horizontalPosition), this.classList.toggle("right", "end" === this.horizontalPosition), this.classList.toggle("inset-left", "insetStart" === this.horizontalPosition), this.classList.toggle("inset-right", "insetEnd" === this.horizontalPosition), this.classList.toggle("horizontal-center", "center" === this.horizontalPosition) }, this.setHorizontalPosition = (t, e) => { if (void 0 === t || void 0 === this.regionRect || void 0 === this.anchorRect || void 0 === this.viewportRect) return; let i = 0; switch (this.horizontalScaling) { case "anchor": case "fill": i = this.horizontalViewportLock ? this.viewportRect.width : e.width, this.regionWidth = i + "px"; break; case "content": i = this.regionRect.width, this.regionWidth = "unset" }let o = 0; switch (t) { case "start": this.translateX = this.baseHorizontalOffset - i, this.horizontalViewportLock && this.anchorRect.left > this.viewportRect.right && (this.translateX = this.translateX - (this.anchorRect.left - this.viewportRect.right)); break; case "insetStart": this.translateX = this.baseHorizontalOffset - i + this.anchorRect.width, this.horizontalViewportLock && this.anchorRect.right > this.viewportRect.right && (this.translateX = this.translateX - (this.anchorRect.right - this.viewportRect.right)); break; case "insetEnd": this.translateX = this.baseHorizontalOffset, this.horizontalViewportLock && this.anchorRect.left < this.viewportRect.left && (this.translateX = this.translateX - (this.anchorRect.left - this.viewportRect.left)); break; case "end": this.translateX = this.baseHorizontalOffset + this.anchorRect.width, this.horizontalViewportLock && this.anchorRect.right < this.viewportRect.left && (this.translateX = this.translateX - (this.anchorRect.right - this.viewportRect.left)); break; case "center": if (o = (this.anchorRect.width - i) / 2, this.translateX = this.baseHorizontalOffset + o, this.horizontalViewportLock) { const t = this.anchorRect.left + o, e = this.anchorRect.right - o; t < this.viewportRect.left && !(e > this.viewportRect.right) ? this.translateX = this.translateX - (t - this.viewportRect.left) : e > this.viewportRect.right && !(t < this.viewportRect.left) && (this.translateX = this.translateX - (e - this.viewportRect.right)) } }this.horizontalPosition = t }, this.setVerticalPosition = (t, e) => { if (void 0 === t || void 0 === this.regionRect || void 0 === this.anchorRect || void 0 === this.viewportRect) return; let i = 0; switch (this.verticalScaling) { case "anchor": case "fill": i = this.verticalViewportLock ? this.viewportRect.height : e.height, this.regionHeight = i + "px"; break; case "content": i = this.regionRect.height, this.regionHeight = "unset" }let o = 0; switch (t) { case "start": this.translateY = this.baseVerticalOffset - i, this.verticalViewportLock && this.anchorRect.top > this.viewportRect.bottom && (this.translateY = this.translateY - (this.anchorRect.top - this.viewportRect.bottom)); break; case "insetStart": this.translateY = this.baseVerticalOffset - i + this.anchorRect.height, this.verticalViewportLock && this.anchorRect.bottom > this.viewportRect.bottom && (this.translateY = this.translateY - (this.anchorRect.bottom - this.viewportRect.bottom)); break; case "insetEnd": this.translateY = this.baseVerticalOffset, this.verticalViewportLock && this.anchorRect.top < this.viewportRect.top && (this.translateY = this.translateY - (this.anchorRect.top - this.viewportRect.top)); break; case "end": this.translateY = this.baseVerticalOffset + this.anchorRect.height, this.verticalViewportLock && this.anchorRect.bottom < this.viewportRect.top && (this.translateY = this.translateY - (this.anchorRect.bottom - this.viewportRect.top)); break; case "center": if (o = (this.anchorRect.height - i) / 2, this.translateY = this.baseVerticalOffset + o, this.verticalViewportLock) { const t = this.anchorRect.top + o, e = this.anchorRect.bottom - o; t < this.viewportRect.top && !(e > this.viewportRect.bottom) ? this.translateY = this.translateY - (t - this.viewportRect.top) : e > this.viewportRect.bottom && !(t < this.viewportRect.top) && (this.translateY = this.translateY - (e - this.viewportRect.bottom)) } }this.verticalPosition = t }, this.getPositioningOptions = t => t ? ["insetStart", "insetEnd"] : ["start", "end"], this.getAvailableSpace = (t, e, i, o, s, n) => { const r = e - s, a = n - (e + o); switch (t) { case "start": return r; case "insetStart": return r + o; case "insetEnd": return a + o; case "end": return a; case "center": return 2 * Math.min(r, a) + o } }, this.getNextRegionDimension = (t, e) => { const i = { height: void 0 !== this.regionRect ? this.regionRect.height : 0, width: void 0 !== this.regionRect ? this.regionRect.width : 0 }; return void 0 !== t && "fill" === this.horizontalScaling ? i.width = this.getAvailableSpace(t, void 0 !== this.anchorRect ? this.anchorRect.left : 0, void 0 !== this.anchorRect ? this.anchorRect.right : 0, void 0 !== this.anchorRect ? this.anchorRect.width : 0, void 0 !== this.viewportRect ? this.viewportRect.left : 0, void 0 !== this.viewportRect ? this.viewportRect.right : 0) : "anchor" === this.horizontalScaling && (i.width = void 0 !== this.anchorRect ? this.anchorRect.width : 0), void 0 !== e && "fill" === this.verticalScaling ? i.height = this.getAvailableSpace(e, void 0 !== this.anchorRect ? this.anchorRect.top : 0, void 0 !== this.anchorRect ? this.anchorRect.bottom : 0, void 0 !== this.anchorRect ? this.anchorRect.height : 0, void 0 !== this.viewportRect ? this.viewportRect.top : 0, void 0 !== this.viewportRect ? this.viewportRect.bottom : 0) : "anchor" === this.verticalScaling && (i.height = void 0 !== this.anchorRect ? this.anchorRect.height : 0), i }, this.startAutoUpdateEventListeners = () => { window.addEventListener("resize", this.update, { passive: !0 }), window.addEventListener("scroll", this.update, { passive: !0, capture: !0 }), null !== this.resizeDetector && null !== this.viewportElement && this.resizeDetector.observe(this.viewportElement) }, this.stopAutoUpdateEventListeners = () => { window.removeEventListener("resize", this.update), window.removeEventListener("scroll", this.update), null !== this.resizeDetector && null !== this.viewportElement && this.resizeDetector.unobserve(this.viewportElement) } } anchorChanged() { this.initialLayoutComplete && (this.anchorElement = this.getAnchor()) } viewportChanged() { this.initialLayoutComplete && (this.viewportElement = this.getViewport()) } horizontalPositioningModeChanged() { this.requestReset() } horizontalDefaultPositionChanged() { this.updateForAttributeChange() } horizontalViewportLockChanged() { this.updateForAttributeChange() } horizontalInsetChanged() { this.updateForAttributeChange() } horizontalThresholdChanged() { this.updateForAttributeChange() } horizontalScalingChanged() { this.updateForAttributeChange() } verticalPositioningModeChanged() { this.requestReset() } verticalDefaultPositionChanged() { this.updateForAttributeChange() } verticalViewportLockChanged() { this.updateForAttributeChange() } verticalInsetChanged() { this.updateForAttributeChange() } verticalThresholdChanged() { this.updateForAttributeChange() } verticalScalingChanged() { this.updateForAttributeChange() } fixedPlacementChanged() { this.$fastController.isConnected && this.initialLayoutComplete && this.initialize() } autoUpdateModeChanged(t, e) { this.$fastController.isConnected && this.initialLayoutComplete && ("auto" === t && this.stopAutoUpdateEventListeners(), "auto" === e && this.startAutoUpdateEventListeners()) } anchorElementChanged() { this.requestReset() } viewportElementChanged() { this.$fastController.isConnected && this.initialLayoutComplete && this.initialize() } connectedCallback() { super.connectedCallback(), "auto" === this.autoUpdateMode && this.startAutoUpdateEventListeners(), this.initialize() } disconnectedCallback() { super.disconnectedCallback(), "auto" === this.autoUpdateMode && this.stopAutoUpdateEventListeners(), this.stopObservers(), this.disconnectResizeDetector() } adoptedCallback() { this.initialize() } disconnectResizeDetector() { null !== this.resizeDetector && (this.resizeDetector.disconnect(), this.resizeDetector = null) } initializeResizeDetector() { this.disconnectResizeDetector(), this.resizeDetector = new window.ResizeObserver(this.handleResize) } updateForAttributeChange() { this.$fastController.isConnected && this.initialLayoutComplete && (this.forceUpdate = !0, this.update()) } initialize() { this.initializeResizeDetector(), null === this.anchorElement && (this.anchorElement = this.getAnchor()), this.requestReset() } requestReset() { this.$fastController.isConnected && !1 === this.pendingReset && (this.setInitialState(), d.queueUpdate(() => this.reset()), this.pendingReset = !0) } setInitialState() { this.initialLayoutComplete = !1, this.regionVisible = !1, this.translateX = 0, this.translateY = 0, this.baseHorizontalOffset = 0, this.baseVerticalOffset = 0, this.viewportRect = void 0, this.regionRect = void 0, this.anchorRect = void 0, this.verticalPosition = void 0, this.horizontalPosition = void 0, this.style.opacity = "0", this.style.pointerEvents = "none", this.forceUpdate = !1, this.style.position = this.fixedPlacement ? "fixed" : "absolute", this.updatePositionClasses(), this.updateRegionStyle() } } ei.intersectionService = new class { constructor() { this.intersectionDetector = null, this.observedElements = new Map, this.requestPosition = (t, e) => { var i; null !== this.intersectionDetector && (this.observedElements.has(t) ? null === (i = this.observedElements.get(t)) || void 0 === i || i.push(e) : (this.observedElements.set(t, [e]), this.intersectionDetector.observe(t))) }, this.cancelRequestPosition = (t, e) => { const i = this.observedElements.get(t); if (void 0 !== i) { const t = i.indexOf(e); -1 !== t && i.splice(t, 1) } }, this.initializeIntersectionDetector = () => { t.IntersectionObserver && (this.intersectionDetector = new IntersectionObserver(this.handleIntersection, { root: null, rootMargin: "0px", threshold: [0, 1] })) }, this.handleIntersection = t => { if (null === this.intersectionDetector) return; const e = [], i = []; t.forEach(t => { var o; null === (o = this.intersectionDetector) || void 0 === o || o.unobserve(t.target); const s = this.observedElements.get(t.target); void 0 !== s && (s.forEach(o => { let s = e.indexOf(o); -1 === s && (s = e.length, e.push(o), i.push([])), i[s].push(t) }), this.observedElements.delete(t.target)) }), e.forEach((t, e) => { t(i[e]) }) }, this.initializeIntersectionDetector() } }, Gt([it], ei.prototype, "anchor", void 0), Gt([it], ei.prototype, "viewport", void 0), Gt([it({ attribute: "horizontal-positioning-mode" })], ei.prototype, "horizontalPositioningMode", void 0), Gt([it({ attribute: "horizontal-default-position" })], ei.prototype, "horizontalDefaultPosition", void 0), Gt([it({ attribute: "horizontal-viewport-lock", mode: "boolean" })], ei.prototype, "horizontalViewportLock", void 0), Gt([it({ attribute: "horizontal-inset", mode: "boolean" })], ei.prototype, "horizontalInset", void 0), Gt([it({ attribute: "horizontal-threshold" })], ei.prototype, "horizontalThreshold", void 0), Gt([it({ attribute: "horizontal-scaling" })], ei.prototype, "horizontalScaling", void 0), Gt([it({ attribute: "vertical-positioning-mode" })], ei.prototype, "verticalPositioningMode", void 0), Gt([it({ attribute: "vertical-default-position" })], ei.prototype, "verticalDefaultPosition", void 0), Gt([it({ attribute: "vertical-viewport-lock", mode: "boolean" })], ei.prototype, "verticalViewportLock", void 0), Gt([it({ attribute: "vertical-inset", mode: "boolean" })], ei.prototype, "verticalInset", void 0), Gt([it({ attribute: "vertical-threshold" })], ei.prototype, "verticalThreshold", void 0), Gt([it({ attribute: "vertical-scaling" })], ei.prototype, "verticalScaling", void 0), Gt([it({ attribute: "fixed-placement", mode: "boolean" })], ei.prototype, "fixedPlacement", void 0), Gt([it({ attribute: "auto-update-mode" })], ei.prototype, "autoUpdateMode", void 0), Gt([f], ei.prototype, "anchorElement", void 0), Gt([f], ei.prototype, "viewportElement", void 0), Gt([f], ei.prototype, "initialLayoutComplete", void 0); class ii extends Se { constructor() { super(...arguments), this.generateBadgeStyle = () => { if (!this.fill && !this.color) return; const t = `background-color: var(--badge-fill-${this.fill});`, e = `color: var(--badge-color-${this.color});`; return this.fill && !this.color ? t : this.color && !this.fill ? e : `${e} ${t}` } } } Gt([it({ attribute: "fill" })], ii.prototype, "fill", void 0), Gt([it({ attribute: "color" })], ii.prototype, "color", void 0), Gt([it({ mode: "boolean" })], ii.prototype, "circular", void 0); class oi extends Ze { constructor() { super(...arguments), this.separator = !0 } } Gt([f], oi.prototype, "separator", void 0), Ve(oi, Nt, Je); class si extends Se { slottedBreadcrumbItemsChanged() { if (this.$fastController.isConnected) { if (void 0 === this.slottedBreadcrumbItems || 0 === this.slottedBreadcrumbItems.length) return; const t = this.slottedBreadcrumbItems[this.slottedBreadcrumbItems.length - 1]; this.slottedBreadcrumbItems.forEach(e => { const i = e === t; this.setItemSeparator(e, i), this.setAriaCurrent(e, i) }) } } setItemSeparator(t, e) { t instanceof oi && (t.separator = !e) } findChildWithHref(t) { var e, i; return t.childElementCount > 0 ? t.querySelector("a[href]") : (null === (e = t.shadowRoot) || void 0 === e ? void 0 : e.childElementCount) ? null === (i = t.shadowRoot) || void 0 === i ? void 0 : i.querySelector("a[href]") : null } setAriaCurrent(t, e) { const i = this.findChildWithHref(t); null === i && t.hasAttribute("href") && t instanceof oi ? e ? t.setAttribute("aria-current", "page") : t.removeAttribute("aria-current") : null !== i && (e ? i.setAttribute("aria-current", "page") : i.removeAttribute("aria-current")) } } Gt([f], si.prototype, "slottedBreadcrumbItems", void 0); const ni = "ElementInternals" in window && "setFormValue" in window.ElementInternals.prototype, ri = new WeakMap; function ai(t) { const e = class extends t { constructor(...t) { super(...t), this.dirtyValue = !1, this.disabled = !1, this.proxyEventsToBlock = ["change", "click"], this.proxyInitialized = !1, this.required = !1, this.initialValue = this.initialValue || "", this.elementInternals || (this.formResetCallback = this.formResetCallback.bind(this)) } static get formAssociated() { return ni } get validity() { return this.elementInternals ? this.elementInternals.validity : this.proxy.validity } get form() { return this.elementInternals ? this.elementInternals.form : this.proxy.form } get validationMessage() { return this.elementInternals ? this.elementInternals.validationMessage : this.proxy.validationMessage } get willValidate() { return this.elementInternals ? this.elementInternals.willValidate : this.proxy.willValidate } get labels() { if (this.elementInternals) return Object.freeze(Array.from(this.elementInternals.labels)); if (this.proxy instanceof HTMLElement && this.proxy.ownerDocument && this.id) { const t = this.proxy.labels, e = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`)), i = t ? e.concat(Array.from(t)) : e; return Object.freeze(i) } return o } valueChanged(t, e) { this.dirtyValue = !0, this.proxy instanceof HTMLElement && (this.proxy.value = this.value), this.currentValue = this.value, this.setFormValue(this.value), this.validate() } currentValueChanged() { this.value = this.currentValue } initialValueChanged(t, e) { this.dirtyValue || (this.value = this.initialValue, this.dirtyValue = !1) } disabledChanged(t, e) { this.proxy instanceof HTMLElement && (this.proxy.disabled = this.disabled), d.queueUpdate(() => this.classList.toggle("disabled", this.disabled)) } nameChanged(t, e) { this.proxy instanceof HTMLElement && (this.proxy.name = this.name) } requiredChanged(t, e) { this.proxy instanceof HTMLElement && (this.proxy.required = this.required), d.queueUpdate(() => this.classList.toggle("required", this.required)), this.validate() } get elementInternals() { if (!ni) return null; let t = ri.get(this); return t || (t = this.attachInternals(), ri.set(this, t)), t } connectedCallback() { super.connectedCallback(), this.addEventListener("keypress", this._keypressHandler), this.value || (this.value = this.initialValue, this.dirtyValue = !1), this.elementInternals || (this.attachProxy(), this.form && this.form.addEventListener("reset", this.formResetCallback)) } disconnectedCallback() { this.proxyEventsToBlock.forEach(t => this.proxy.removeEventListener(t, this.stopPropagation)), !this.elementInternals && this.form && this.form.removeEventListener("reset", this.formResetCallback) } checkValidity() { return this.elementInternals ? this.elementInternals.checkValidity() : this.proxy.checkValidity() } reportValidity() { return this.elementInternals ? this.elementInternals.reportValidity() : this.proxy.reportValidity() } setValidity(t, e, i) { this.elementInternals ? this.elementInternals.setValidity(t, e, i) : "string" == typeof e && this.proxy.setCustomValidity(e) } formDisabledCallback(t) { this.disabled = t } formResetCallback() { this.value = this.initialValue, this.dirtyValue = !1 } attachProxy() { var t; this.proxyInitialized || (this.proxyInitialized = !0, this.proxy.style.display = "none", this.proxyEventsToBlock.forEach(t => this.proxy.addEventListener(t, this.stopPropagation)), this.proxy.disabled = this.disabled, this.proxy.required = this.required, "string" == typeof this.name && (this.proxy.name = this.name), "string" == typeof this.value && (this.proxy.value = this.value), this.proxy.setAttribute("slot", "form-associated-proxy"), this.proxySlot = document.createElement("slot"), this.proxySlot.setAttribute("name", "form-associated-proxy")), null === (t = this.shadowRoot) || void 0 === t || t.appendChild(this.proxySlot), this.appendChild(this.proxy) } detachProxy() { var t; this.removeChild(this.proxy), null === (t = this.shadowRoot) || void 0 === t || t.removeChild(this.proxySlot) } validate(t) { this.proxy instanceof HTMLElement && this.setValidity(this.proxy.validity, this.proxy.validationMessage, t) } setFormValue(t, e) { this.elementInternals && this.elementInternals.setFormValue(t, e || t) } _keypressHandler(t) { switch (t.key) { case "Enter": if (this.form instanceof HTMLFormElement) { const t = this.form.querySelector("[type=submit]"); null == t || t.click() } } } stopPropagation(t) { t.stopPropagation() } }; return it({ mode: "boolean" })(e.prototype, "disabled"), it({ mode: "fromView", attribute: "value" })(e.prototype, "initialValue"), it({ attribute: "current-value" })(e.prototype, "currentValue"), it(e.prototype, "name"), it({ mode: "boolean" })(e.prototype, "required"), f(e.prototype, "value"), e } function li(t) { class e extends (ai(t)) { } class i extends e { constructor(...t) { super(t), this.dirtyChecked = !1, this.checkedAttribute = !1, this.checked = !1, this.dirtyChecked = !1 } checkedAttributeChanged() { this.defaultChecked = this.checkedAttribute } defaultCheckedChanged() { this.dirtyChecked || (this.checked = this.defaultChecked, this.dirtyChecked = !1) } checkedChanged(t, e) { this.dirtyChecked || (this.dirtyChecked = !0), this.currentChecked = this.checked, this.updateForm(), this.proxy instanceof HTMLInputElement && (this.proxy.checked = this.checked), void 0 !== t && this.$emit("change"), this.validate() } currentCheckedChanged(t, e) { this.checked = this.currentChecked } updateForm() { const t = this.checked ? this.value : null; this.setFormValue(t, t) } connectedCallback() { super.connectedCallback(), this.updateForm() } formResetCallback() { super.formResetCallback(), this.checked = !!this.checkedAttribute, this.dirtyChecked = !1 } } return it({ attribute: "checked", mode: "boolean" })(i.prototype, "checkedAttribute"), it({ attribute: "current-checked", converter: J })(i.prototype, "currentChecked"), f(i.prototype, "defaultChecked"), f(i.prototype, "checked"), i } class ci extends Se { } class hi extends (ai(ci)) { constructor() { super(...arguments), this.proxy = document.createElement("input") } } class di extends hi { constructor() { super(...arguments), this.handleClick = t => { var e; this.disabled && (null === (e = this.defaultSlottedContent) || void 0 === e ? void 0 : e.length) <= 1 && t.stopPropagation() }, this.handleSubmission = () => { if (!this.form) return; const t = this.proxy.isConnected; t || this.attachProxy(), "function" == typeof this.form.requestSubmit ? this.form.requestSubmit(this.proxy) : this.proxy.click(), t || this.detachProxy() }, this.handleFormReset = () => { var t; null === (t = this.form) || void 0 === t || t.reset() }, this.handleUnsupportedDelegatesFocus = () => { var t; window.ShadowRoot && !window.ShadowRoot.prototype.hasOwnProperty("delegatesFocus") && (null === (t = this.$fastController.definition.shadowOptions) || void 0 === t ? void 0 : t.delegatesFocus) && (this.focus = () => { this.control.focus() }) } } formactionChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.formAction = this.formaction) } formenctypeChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.formEnctype = this.formenctype) } formmethodChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.formMethod = this.formmethod) } formnovalidateChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.formNoValidate = this.formnovalidate) } formtargetChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.formTarget = this.formtarget) } typeChanged(t, e) { this.proxy instanceof HTMLInputElement && (this.proxy.type = this.type), "submit" === e && this.addEventListener("click", this.handleSubmission), "submit" === t && this.removeEventListener("click", this.handleSubmission), "reset" === e && this.addEventListener("click", this.handleFormReset), "reset" === t && this.removeEventListener("click", this.handleFormReset) } validate() { super.validate(this.control) } connectedCallback() { var t; super.connectedCallback(), this.proxy.setAttribute("type", this.type), this.handleUnsupportedDelegatesFocus(); const e = Array.from(null === (t = this.control) || void 0 === t ? void 0 : t.children); e && e.forEach(t => { t.addEventListener("click", this.handleClick) }) } disconnectedCallback() { var t; super.disconnectedCallback(); const e = Array.from(null === (t = this.control) || void 0 === t ? void 0 : t.children); e && e.forEach(t => { t.removeEventListener("click", this.handleClick) }) } } Gt([it({ mode: "boolean" })], di.prototype, "autofocus", void 0), Gt([it({ attribute: "form" })], di.prototype, "formId", void 0), Gt([it], di.prototype, "formaction", void 0), Gt([it], di.prototype, "formenctype", void 0), Gt([it], di.prototype, "formmethod", void 0), Gt([it({ mode: "boolean" })], di.prototype, "formnovalidate", void 0), Gt([it], di.prototype, "formtarget", void 0), Gt([it], di.prototype, "type", void 0), Gt([f], di.prototype, "defaultSlottedContent", void 0); class ui { } Gt([it({ attribute: "aria-expanded" })], ui.prototype, "ariaExpanded", void 0), Gt([it({ attribute: "aria-pressed" })], ui.prototype, "ariaPressed", void 0), Ve(ui, Qe), Ve(di, Nt, ui); class pi { constructor(t) { if (this.dayFormat = "numeric", this.weekdayFormat = "long", this.monthFormat = "long", this.yearFormat = "numeric", this.date = new Date, t) for (const e in t) { const i = t[e]; "date" === e ? this.date = this.getDateObject(i) : this[e] = i } } getDateObject(t) { if ("string" == typeof t) { const e = t.split(/[/-]/); return e.length < 3 ? new Date : new Date(parseInt(e[2], 10), parseInt(e[0], 10) - 1, parseInt(e[1], 10)) } if ("day" in t && "month" in t && "year" in t) { const { day: e, month: i, year: o } = t; return new Date(o, i - 1, e) } return t } getDate(t = this.date, e = { weekday: this.weekdayFormat, month: this.monthFormat, day: this.dayFormat, year: this.yearFormat }, i = this.locale) { const o = this.getDateObject(t), s = Object.assign({ timeZone: "utc" }, e); return new Intl.DateTimeFormat(i, s).format(o) } getDay(t = this.date.getDate(), e = this.dayFormat, i = this.locale) { return this.getDate({ month: 1, day: t, year: 2020 }, { day: e }, i) } getMonth(t = this.date.getMonth() + 1, e = this.monthFormat, i = this.locale) { return this.getDate({ month: t, day: 2, year: 2020 }, { month: e }, i) } getYear(t = this.date.getFullYear(), e = this.yearFormat, i = this.locale) { return this.getDate({ month: 2, day: 2, year: t }, { year: e }, i) } getWeekday(t = 0, e = this.weekdayFormat, i = this.locale) { const o = `1-${t + 1}-2017`; return this.getDate(o, { weekday: e }, i) } getWeekdays(t = this.weekdayFormat, e = this.locale) { return Array(7).fill(null).map((i, o) => this.getWeekday(o, t, e)) } } class gi extends Se { constructor() { super(...arguments), this.dateFormatter = new pi, this.readonly = !1, this.locale = "en-US", this.month = (new Date).getMonth() + 1, this.year = (new Date).getFullYear(), this.dayFormat = "numeric", this.weekdayFormat = "short", this.monthFormat = "long", this.yearFormat = "numeric", this.minWeeks = 0, this.disabledDates = "", this.selectedDates = "", this.oneDayInMs = 864e5 } localeChanged() { this.dateFormatter.locale = this.locale } dayFormatChanged() { this.dateFormatter.dayFormat = this.dayFormat } weekdayFormatChanged() { this.dateFormatter.weekdayFormat = this.weekdayFormat } monthFormatChanged() { this.dateFormatter.monthFormat = this.monthFormat } yearFormatChanged() { this.dateFormatter.yearFormat = this.yearFormat } getMonthInfo(t = this.month, e = this.year) { const i = t => new Date(t.getFullYear(), t.getMonth(), 1).getDay(), o = t => { const e = new Date(t.getFullYear(), t.getMonth() + 1, 1); return new Date(e.getTime() - this.oneDayInMs).getDate() }, s = new Date(e, t - 1), n = new Date(e, t), r = new Date(e, t - 2); return { length: o(s), month: t, start: i(s), year: e, previous: { length: o(r), month: r.getMonth() + 1, start: i(r), year: r.getFullYear() }, next: { length: o(n), month: n.getMonth() + 1, start: i(n), year: n.getFullYear() } } } getDays(t = this.getMonthInfo(), e = this.minWeeks) { e = e > 10 ? 10 : e; const { start: i, length: o, previous: s, next: n } = t, r = []; let a = 1 - i; for (; a < o + 1 || r.length < e || r[r.length - 1].length % 7 != 0;) { const { month: e, year: i } = a < 1 ? s : a > o ? n : t, l = a < 1 ? s.length + a : a > o ? a - o : a, c = `${e}-${l}-${i}`, h = { day: l, month: e, year: i, disabled: this.dateInString(c, this.disabledDates), selected: this.dateInString(c, this.selectedDates) }, d = r[r.length - 1]; 0 === r.length || d.length % 7 == 0 ? r.push([h]) : d.push(h), a++ } return r } dateInString(t, e) { const i = e.split(",").map(t => t.trim()); return t = "string" == typeof t ? t : `${t.getMonth() + 1}-${t.getDate()}-${t.getFullYear()}`, i.some(e => e === t) } getDayClassNames(t, e) { const { day: i, month: o, year: s, disabled: n, selected: r } = t; return ["day", e === `${o}-${i}-${s}` && "today", this.month !== o && "inactive", n && "disabled", r && "selected"].filter(Boolean).join(" ") } getWeekdayText() { const t = this.dateFormatter.getWeekdays().map(t => ({ text: t })); if ("long" !== this.weekdayFormat) { const e = this.dateFormatter.getWeekdays("long"); t.forEach((t, i) => { t.abbr = e[i] }) } return t } handleDateSelect(t, e) { t.preventDefault, this.$emit("dateselected", e) } handleKeydown(t, e) { return "Enter" === t.key && this.handleDateSelect(t, e), !0 } } Gt([it({ mode: "boolean" })], gi.prototype, "readonly", void 0), Gt([it], gi.prototype, "locale", void 0), Gt([it({ converter: tt })], gi.prototype, "month", void 0), Gt([it({ converter: tt })], gi.prototype, "year", void 0), Gt([it({ attribute: "day-format", mode: "fromView" })], gi.prototype, "dayFormat", void 0), Gt([it({ attribute: "weekday-format", mode: "fromView" })], gi.prototype, "weekdayFormat", void 0), Gt([it({ attribute: "month-format", mode: "fromView" })], gi.prototype, "monthFormat", void 0), Gt([it({ attribute: "year-format", mode: "fromView" })], gi.prototype, "yearFormat", void 0), Gt([it({ attribute: "min-weeks", converter: tt })], gi.prototype, "minWeeks", void 0), Gt([it({ attribute: "disabled-dates" })], gi.prototype, "disabledDates", void 0), Gt([it({ attribute: "selected-dates" })], gi.prototype, "selectedDates", void 0); const fi = "none", mi = "default", vi = "sticky", bi = "default", yi = "columnheader", xi = "rowheader", $i = "default", wi = "header", ki = "sticky-header"; class Ci extends Se { constructor() { super(...arguments), this.rowType = $i, this.rowData = null, this.columnDefinitions = null, this.isActiveRow = !1, this.cellsRepeatBehavior = null, this.cellsPlaceholder = null, this.focusColumnIndex = 0, this.refocusOnLoad = !1, this.updateRowStyle = () => { this.style.gridTemplateColumns = this.gridTemplateColumns } } gridTemplateColumnsChanged() { this.$fastController.isConnected && this.updateRowStyle() } rowTypeChanged() { this.$fastController.isConnected && this.updateItemTemplate() } rowDataChanged() { null !== this.rowData && this.isActiveRow && (this.refocusOnLoad = !0) } cellItemTemplateChanged() { this.updateItemTemplate() } headerCellItemTemplateChanged() { this.updateItemTemplate() } connectedCallback() { super.connectedCallback(), null === this.cellsRepeatBehavior && (this.cellsPlaceholder = document.createComment(""), this.appendChild(this.cellsPlaceholder), this.updateItemTemplate(), this.cellsRepeatBehavior = new Rt(t => t.columnDefinitions, t => t.activeCellItemTemplate, { positioning: !0 }).createBehavior(this.cellsPlaceholder), this.$fastController.addBehaviors([this.cellsRepeatBehavior])), this.addEventListener("cell-focused", this.handleCellFocus), this.addEventListener("focusout", this.handleFocusout), this.addEventListener("keydown", this.handleKeydown), this.updateRowStyle(), this.refocusOnLoad && (this.refocusOnLoad = !1, this.cellElements.length > this.focusColumnIndex && this.cellElements[this.focusColumnIndex].focus()) } disconnectedCallback() { super.disconnectedCallback(), this.removeEventListener("cell-focused", this.handleCellFocus), this.removeEventListener("focusout", this.handleFocusout), this.removeEventListener("keydown", this.handleKeydown) } handleFocusout(t) { this.contains(t.target) || (this.isActiveRow = !1, this.focusColumnIndex = 0) } handleCellFocus(t) { this.isActiveRow = !0, this.focusColumnIndex = this.cellElements.indexOf(t.target), this.$emit("row-focused", this) } handleKeydown(t) { if (t.defaultPrevented) return; let e = 0; switch (t.key) { case "ArrowLeft": e = Math.max(0, this.focusColumnIndex - 1), this.cellElements[e].focus(), t.preventDefault(); break; case "ArrowRight": e = Math.min(this.cellElements.length - 1, this.focusColumnIndex + 1), this.cellElements[e].focus(), t.preventDefault(); break; case "Home": t.ctrlKey || (this.cellElements[0].focus(), t.preventDefault()); break; case "End": t.ctrlKey || (this.cellElements[this.cellElements.length - 1].focus(), t.preventDefault()) } } updateItemTemplate() { this.activeCellItemTemplate = this.rowType === $i && void 0 !== this.cellItemTemplate ? this.cellItemTemplate : this.rowType === $i && void 0 === this.cellItemTemplate ? this.defaultCellItemTemplate : void 0 !== this.headerCellItemTemplate ? this.headerCellItemTemplate : this.defaultHeaderCellItemTemplate } } Gt([it({ attribute: "grid-template-columns" })], Ci.prototype, "gridTemplateColumns", void 0), Gt([it({ attribute: "row-type" })], Ci.prototype, "rowType", void 0), Gt([f], Ci.prototype, "rowData", void 0), Gt([f], Ci.prototype, "columnDefinitions", void 0), Gt([f], Ci.prototype, "cellItemTemplate", void 0), Gt([f], Ci.prototype, "headerCellItemTemplate", void 0), Gt([f], Ci.prototype, "rowIndex", void 0), Gt([f], Ci.prototype, "isActiveRow", void 0), Gt([f], Ci.prototype, "activeCellItemTemplate", void 0), Gt([f], Ci.prototype, "defaultCellItemTemplate", void 0), Gt([f], Ci.prototype, "defaultHeaderCellItemTemplate", void 0), Gt([f], Ci.prototype, "cellElements", void 0); class Ii extends Se { constructor() { super(), this.noTabbing = !1, this.generateHeader = mi, this.rowsData = [], this.columnDefinitions = null, this.focusRowIndex = 0, this.focusColumnIndex = 0, this.rowsPlaceholder = null, this.generatedHeader = null, this.isUpdatingFocus = !1, this.pendingFocusUpdate = !1, this.rowindexUpdateQueued = !1, this.columnDefinitionsStale = !0, this.generatedGridTemplateColumns = "", this.focusOnCell = (t, e, i) => { if (0 === this.rowElements.length) return this.focusRowIndex = 0, void (this.focusColumnIndex = 0); const o = Math.max(0, Math.min(this.rowElements.length - 1, t)), s = this.rowElements[o].querySelectorAll('[role="cell"], [role="gridcell"], [role="columnheader"], [role="rowheader"]'), n = s[Math.max(0, Math.min(s.length - 1, e))]; i && this.scrollHeight !== this.clientHeight && (o < this.focusRowIndex && this.scrollTop > 0 || o > this.focusRowIndex && this.scrollTop < this.scrollHeight - this.clientHeight) && n.scrollIntoView({ block: "center", inline: "center" }), n.focus() }, this.onChildListChange = (t, e) => { t && t.length && (t.forEach(t => { t.addedNodes.forEach(t => { 1 === t.nodeType && "row" === t.getAttribute("role") && (t.columnDefinitions = this.columnDefinitions) }) }), this.queueRowIndexUpdate()) }, this.queueRowIndexUpdate = () => { this.rowindexUpdateQueued || (this.rowindexUpdateQueued = !0, d.queueUpdate(this.updateRowIndexes)) }, this.updateRowIndexes = () => { let t = this.gridTemplateColumns; if (void 0 === t) { if ("" === this.generatedGridTemplateColumns && this.rowElements.length > 0) { const t = this.rowElements[0]; this.generatedGridTemplateColumns = new Array(t.cellElements.length).fill("1fr").join(" ") } t = this.generatedGridTemplateColumns } this.rowElements.forEach((e, i) => { const o = e; o.rowIndex = i, o.gridTemplateColumns = t, this.columnDefinitionsStale && (o.columnDefinitions = this.columnDefinitions) }), this.rowindexUpdateQueued = !1, this.columnDefinitionsStale = !1 } } static generateTemplateColumns(t) { let e = ""; return t.forEach(t => { e = `${e}${"" === e ? "" : " "}1fr` }), e } noTabbingChanged() { this.$fastController.isConnected && (this.noTabbing ? this.setAttribute("tabIndex", "-1") : this.setAttribute("tabIndex", this.contains(document.activeElement) || this === document.activeElement ? "-1" : "0")) } generateHeaderChanged() { this.$fastController.isConnected && this.toggleGeneratedHeader() } gridTemplateColumnsChanged() { this.$fastController.isConnected && this.updateRowIndexes() } rowsDataChanged() { null === this.columnDefinitions && this.rowsData.length > 0 && (this.columnDefinitions = Ii.generateColumns(this.rowsData[0])), this.$fastController.isConnected && this.toggleGeneratedHeader() } columnDefinitionsChanged() { null !== this.columnDefinitions ? (this.generatedGridTemplateColumns = Ii.generateTemplateColumns(this.columnDefinitions), this.$fastController.isConnected && (this.columnDefinitionsStale = !0, this.queueRowIndexUpdate())) : this.generatedGridTemplateColumns = "" } headerCellItemTemplateChanged() { this.$fastController.isConnected && null !== this.generatedHeader && (this.generatedHeader.headerCellItemTemplate = this.headerCellItemTemplate) } focusRowIndexChanged() { this.$fastController.isConnected && this.queueFocusUpdate() } focusColumnIndexChanged() { this.$fastController.isConnected && this.queueFocusUpdate() } connectedCallback() { super.connectedCallback(), void 0 === this.rowItemTemplate && (this.rowItemTemplate = this.defaultRowItemTemplate), this.rowsPlaceholder = document.createComment(""), this.appendChild(this.rowsPlaceholder), this.toggleGeneratedHeader(), this.rowsRepeatBehavior = new Rt(t => t.rowsData, t => t.rowItemTemplate, { positioning: !0 }).createBehavior(this.rowsPlaceholder), this.$fastController.addBehaviors([this.rowsRepeatBehavior]), this.addEventListener("row-focused", this.handleRowFocus), this.addEventListener("focus", this.handleFocus), this.addEventListener("keydown", this.handleKeydown), this.addEventListener("focusout", this.handleFocusOut), this.observer = new MutationObserver(this.onChildListChange), this.observer.observe(this, { childList: !0 }), this.noTabbing && this.setAttribute("tabindex", "-1"), d.queueUpdate(this.queueRowIndexUpdate) } disconnectedCallback() { super.disconnectedCallback(), this.removeEventListener("row-focused", this.handleRowFocus), this.removeEventListener("focus", this.handleFocus), this.removeEventListener("keydown", this.handleKeydown), this.removeEventListener("focusout", this.handleFocusOut), this.observer.disconnect(), this.rowsPlaceholder = null, this.generatedHeader = null } handleRowFocus(t) { this.isUpdatingFocus = !0; const e = t.target; this.focusRowIndex = this.rowElements.indexOf(e), this.focusColumnIndex = e.focusColumnIndex, this.setAttribute("tabIndex", "-1"), this.isUpdatingFocus = !1 } handleFocus(t) { this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, !0) } handleFocusOut(t) { null !== t.relatedTarget && this.contains(t.relatedTarget) || this.setAttribute("tabIndex", this.noTabbing ? "-1" : "0") } handleKeydown(t) { if (t.defaultPrevented) return; let e; const i = this.rowElements.length - 1, o = this.offsetHeight + this.scrollTop, s = this.rowElements[i]; switch (t.key) { case "ArrowUp": t.preventDefault(), this.focusOnCell(this.focusRowIndex - 1, this.focusColumnIndex, !0); break; case "ArrowDown": t.preventDefault(), this.focusOnCell(this.focusRowIndex + 1, this.focusColumnIndex, !0); break; case "PageUp": if (t.preventDefault(), 0 === this.rowElements.length) { this.focusOnCell(0, 0, !1); break } if (0 === this.focusRowIndex) return void this.focusOnCell(0, this.focusColumnIndex, !1); for (e = this.focusRowIndex - 1; e >= 0; e--) { const t = this.rowElements[e]; if (t.offsetTop < this.scrollTop) { this.scrollTop = t.offsetTop + t.clientHeight - this.clientHeight; break } } this.focusOnCell(e, this.focusColumnIndex, !1); break; case "PageDown": if (t.preventDefault(), 0 === this.rowElements.length) { this.focusOnCell(0, 0, !1); break } if (this.focusRowIndex >= i || s.offsetTop + s.offsetHeight <= o) return void this.focusOnCell(i, this.focusColumnIndex, !1); for (e = this.focusRowIndex + 1; e <= i; e++) { const t = this.rowElements[e]; if (t.offsetTop + t.offsetHeight > o) { let e = 0; this.generateHeader === vi && null !== this.generatedHeader && (e = this.generatedHeader.clientHeight), this.scrollTop = t.offsetTop - e; break } } this.focusOnCell(e, this.focusColumnIndex, !1); break; case "Home": t.ctrlKey && (t.preventDefault(), this.focusOnCell(0, 0, !0)); break; case "End": t.ctrlKey && null !== this.columnDefinitions && (t.preventDefault(), this.focusOnCell(this.rowElements.length - 1, this.columnDefinitions.length - 1, !0)) } } queueFocusUpdate() { this.isUpdatingFocus && (this.contains(document.activeElement) || this === document.activeElement) || !1 === this.pendingFocusUpdate && (this.pendingFocusUpdate = !0, d.queueUpdate(() => this.updateFocus())) } updateFocus() { this.pendingFocusUpdate = !1, this.focusOnCell(this.focusRowIndex, this.focusColumnIndex, !0) } toggleGeneratedHeader() { if (null !== this.generatedHeader && (this.removeChild(this.generatedHeader), this.generatedHeader = null), this.generateHeader !== fi && this.rowsData.length > 0) { const t = document.createElement(this.rowElementTag); return this.generatedHeader = t, this.generatedHeader.columnDefinitions = this.columnDefinitions, this.generatedHeader.gridTemplateColumns = this.gridTemplateColumns, this.generatedHeader.rowType = this.generateHeader === vi ? ki : wi, void (null === this.firstChild && null === this.rowsPlaceholder || this.insertBefore(t, null !== this.firstChild ? this.firstChild : this.rowsPlaceholder)) } } } Ii.generateColumns = t => Object.getOwnPropertyNames(t).map((t, e) => ({ columnDataKey: t, gridColumn: "" + e })), Gt([it({ attribute: "no-tabbing", mode: "boolean" })], Ii.prototype, "noTabbing", void 0), Gt([it({ attribute: "generate-header" })], Ii.prototype, "generateHeader", void 0), Gt([it({ attribute: "grid-template-columns" })], Ii.prototype, "gridTemplateColumns", void 0), Gt([f], Ii.prototype, "rowsData", void 0), Gt([f], Ii.prototype, "columnDefinitions", void 0), Gt([f], Ii.prototype, "rowItemTemplate", void 0), Gt([f], Ii.prototype, "cellItemTemplate", void 0), Gt([f], Ii.prototype, "headerCellItemTemplate", void 0), Gt([f], Ii.prototype, "focusRowIndex", void 0), Gt([f], Ii.prototype, "focusColumnIndex", void 0), Gt([f], Ii.prototype, "defaultRowItemTemplate", void 0), Gt([f], Ii.prototype, "rowElementTag", void 0), Gt([f], Ii.prototype, "rowElements", void 0); const Fi = _`<template>${t => null === t.rowData || null === t.columnDefinition || null === t.columnDefinition.columnDataKey ? null : t.rowData[t.columnDefinition.columnDataKey]}</template>`, Di = _`<template>${t => null === t.columnDefinition ? null : void 0 === t.columnDefinition.title ? t.columnDefinition.columnDataKey : t.columnDefinition.title}</template>`; class Ti extends Se { constructor() { super(...arguments), this.cellType = bi, this.rowData = null, this.columnDefinition = null, this.isActiveCell = !1, this.customCellView = null, this.updateCellStyle = () => { this.style.gridColumn = this.gridColumn } } cellTypeChanged() { this.$fastController.isConnected && this.updateCellView() } gridColumnChanged() { this.$fastController.isConnected && this.updateCellStyle() } columnDefinitionChanged(t, e) { this.$fastController.isConnected && this.updateCellView() } connectedCallback() { var t; super.connectedCallback(), this.addEventListener("focusin", this.handleFocusin), this.addEventListener("focusout", this.handleFocusout), this.addEventListener("keydown", this.handleKeydown), this.style.gridColumn = "" + (void 0 === (null === (t = this.columnDefinition) || void 0 === t ? void 0 : t.gridColumn) ? 0 : this.columnDefinition.gridColumn), this.updateCellView(), this.updateCellStyle() } disconnectedCallback() { super.disconnectedCallback(), this.removeEventListener("focusin", this.handleFocusin), this.removeEventListener("focusout", this.handleFocusout), this.removeEventListener("keydown", this.handleKeydown), this.disconnectCellView() } handleFocusin(t) { if (!this.isActiveCell) { switch (this.isActiveCell = !0, this.cellType) { case yi: if (null !== this.columnDefinition && !0 !== this.columnDefinition.headerCellInternalFocusQueue && "function" == typeof this.columnDefinition.headerCellFocusTargetCallback) { const t = this.columnDefinition.headerCellFocusTargetCallback(this); null !== t && t.focus() } break; default: if (null !== this.columnDefinition && !0 !== this.columnDefinition.cellInternalFocusQueue && "function" == typeof this.columnDefinition.cellFocusTargetCallback) { const t = this.columnDefinition.cellFocusTargetCallback(this); null !== t && t.focus() } }this.$emit("cell-focused", this) } } handleFocusout(t) { this === document.activeElement || this.contains(document.activeElement) || (this.isActiveCell = !1) } handleKeydown(t) { if (!(t.defaultPrevented || null === this.columnDefinition || this.cellType === bi && !0 !== this.columnDefinition.cellInternalFocusQueue || this.cellType === yi && !0 !== this.columnDefinition.headerCellInternalFocusQueue)) switch (t.key) { case "Enter": case "F2": if (this.contains(document.activeElement) && document.activeElement !== this) return; switch (this.cellType) { case yi: if (void 0 !== this.columnDefinition.headerCellFocusTargetCallback) { const e = this.columnDefinition.headerCellFocusTargetCallback(this); null !== e && e.focus(), t.preventDefault() } break; default: if (void 0 !== this.columnDefinition.cellFocusTargetCallback) { const e = this.columnDefinition.cellFocusTargetCallback(this); null !== e && e.focus(), t.preventDefault() } }break; case "Escape": this.contains(document.activeElement) && document.activeElement !== this && (this.focus(), t.preventDefault()) } } updateCellView() { if (this.disconnectCellView(), null !== this.columnDefinition) switch (this.cellType) { case yi: void 0 !== this.columnDefinition.headerCellTemplate ? this.customCellView = this.columnDefinition.headerCellTemplate.render(this, this) : this.customCellView = Di.render(this, this); break; case void 0: case xi: case bi: void 0 !== this.columnDefinition.cellTemplate ? this.customCellView = this.columnDefinition.cellTemplate.render(this, this) : this.customCellView = Fi.render(this, this) } } disconnectCellView() { null !== this.customCellView && (this.customCellView.dispose(), this.customCellView = null) } } Gt([it({ attribute: "cell-type" })], Ti.prototype, "cellType", void 0), Gt([it({ attribute: "grid-column" })], Ti.prototype, "gridColumn", void 0), Gt([f], Ti.prototype, "rowData", void 0), Gt([f], Ti.prototype, "columnDefinition", void 0); const Si = _`<div class="title" part="title" aria-label="${t => t.dateFormatter.getDate(`${t.month}-2-${t.year}`, { month: "long", year: "numeric" })}"><span part="month">${t => t.dateFormatter.getMonth(t.month)}</span><span part="year">${t => t.dateFormatter.getYear(t.year)}</span></div>`, Oi = (t, e) => { const i = t.tagFor(Ci); return _`<${i} class="week" part="week" role="row" role-type="default" grid-template-columns="1fr 1fr 1fr 1fr 1fr 1fr 1fr">${At(t => t, ((t, e) => { const i = t.tagFor(Ti); return _`<${i} class="${(t, i) => i.parentContext.parent.getDayClassNames(t, e)}" part="day" tabindex="-1" role="gridcell" grid-column="${(t, e) => e.index + 1}" @click="${(t, e) => e.parentContext.parent.handleDateSelect(e.event, t)}" @keydown="${(t, e) => e.parentContext.parent.handleKeydown(e.event, t)}" aria-label="${(t, e) => e.parentContext.parent.dateFormatter.getDate(`${t.month}-${t.day}-${t.year}`, { month: "long", day: "numeric" })}"><div class="date" part="${t => e === `${t.month}-${t.day}-${t.year}` ? "today" : "date"}">${(t, e) => e.parentContext.parent.dateFormatter.getDay(t.day)}</div><slot name="${t => t.month}-${t => t.day}-${t => t.year}"></slot></${i}>` })(t, e), { positioning: !0 })}</${i}>` }, Ei = (t, e) => { const i = t.tagFor(Ii), o = t.tagFor(Ci); return _`<${i} class="days interact" part="days" generate-header="none"><${o} class="week-days" part="week-days" role="row" row-type="header" grid-template-columns="1fr 1fr 1fr 1fr 1fr 1fr 1fr">${At(t => t.getWeekdayText(), (t => { const e = t.tagFor(Ti); return _`<${e} class="week-day" part="week-day" tabindex="-1" grid-column="${(t, e) => e.index + 1}" abbr="${t => t.abbr}">${t => t.text}</${e}>` })(t), { positioning: !0 })}</${o}>${At(t => t.getDays(), Oi(t, e))}</${i}>` }; class Vi extends Se { } class Ri extends Se { } class Ai extends (li(Ri)) { constructor() { super(...arguments), this.proxy = document.createElement("input") } } class Li extends Ai { constructor() { super(), this.initialValue = "on", this.indeterminate = !1, this.keypressHandler = t => { if (!this.readOnly) switch (t.key) { case " ": this.indeterminate && (this.indeterminate = !1), this.checked = !this.checked } }, this.clickHandler = t => { this.disabled || this.readOnly || (this.indeterminate && (this.indeterminate = !1), this.checked = !this.checked) }, this.proxy.setAttribute("type", "checkbox") } readOnlyChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.readOnly = this.readOnly) } } function Pi(t) { return Pe(t) && ("option" === t.getAttribute("role") || t instanceof HTMLOptionElement) } Gt([it({ attribute: "readonly", mode: "boolean" })], Li.prototype, "readOnly", void 0), Gt([f], Li.prototype, "defaultSlottedNodes", void 0), Gt([f], Li.prototype, "indeterminate", void 0); class zi extends Se { constructor(t, e, i, o) { super(), this.defaultSelected = !1, this.dirtySelected = !1, this.selected = this.defaultSelected, this.dirtyValue = !1, t && (this.textContent = t), e && (this.initialValue = e), i && (this.defaultSelected = i), o && (this.selected = o), this.proxy = new Option("" + this.textContent, this.initialValue, this.defaultSelected, this.selected), this.proxy.disabled = this.disabled } checkedChanged(t, e) { this.ariaChecked = "boolean" != typeof e ? null : e ? "true" : "false" } contentChanged(t, e) { this.proxy instanceof HTMLOptionElement && (this.proxy.textContent = this.textContent), this.$emit("contentchange", null, { bubbles: !0 }) } defaultSelectedChanged() { this.dirtySelected || (this.selected = this.defaultSelected, this.proxy instanceof HTMLOptionElement && (this.proxy.selected = this.defaultSelected)) } disabledChanged(t, e) { this.ariaDisabled = this.disabled ? "true" : "false", this.proxy instanceof HTMLOptionElement && (this.proxy.disabled = this.disabled) } selectedAttributeChanged() { this.defaultSelected = this.selectedAttribute, this.proxy instanceof HTMLOptionElement && (this.proxy.defaultSelected = this.defaultSelected) } selectedChanged() { this.ariaSelected = this.selected ? "true" : "false", this.dirtySelected || (this.dirtySelected = !0), this.proxy instanceof HTMLOptionElement && (this.proxy.selected = this.selected) } initialValueChanged(t, e) { this.dirtyValue || (this.value = this.initialValue, this.dirtyValue = !1) } get label() { var t; return null !== (t = this.value) && void 0 !== t ? t : this.text } get text() { var t, e; return null !== (e = null === (t = this.textContent) || void 0 === t ? void 0 : t.replace(/\s+/g, " ").trim()) && void 0 !== e ? e : "" } set value(t) { const e = "" + (null != t ? t : ""); this._value = e, this.dirtyValue = !0, this.proxy instanceof HTMLOptionElement && (this.proxy.value = e), g.notify(this, "value") } get value() { var t; return g.track(this, "value"), null !== (t = this._value) && void 0 !== t ? t : this.text } get form() { return this.proxy ? this.proxy.form : null } } Gt([f], zi.prototype, "checked", void 0), Gt([f], zi.prototype, "content", void 0), Gt([f], zi.prototype, "defaultSelected", void 0), Gt([it({ mode: "boolean" })], zi.prototype, "disabled", void 0), Gt([it({ attribute: "selected", mode: "boolean" })], zi.prototype, "selectedAttribute", void 0), Gt([f], zi.prototype, "selected", void 0), Gt([it({ attribute: "value", mode: "fromView" })], zi.prototype, "initialValue", void 0); class Hi { } Gt([f], Hi.prototype, "ariaChecked", void 0), Gt([f], Hi.prototype, "ariaPosInSet", void 0), Gt([f], Hi.prototype, "ariaSelected", void 0), Gt([f], Hi.prototype, "ariaSetSize", void 0), Ve(Hi, Qe), Ve(zi, Nt, Hi); class Mi extends Se { constructor() { super(...arguments), this._options = [], this.selectedIndex = -1, this.selectedOptions = [], this.shouldSkipFocus = !1, this.typeaheadBuffer = "", this.typeaheadExpired = !0, this.typeaheadTimeout = -1 } get firstSelectedOption() { var t; return null !== (t = this.selectedOptions[0]) && void 0 !== t ? t : null } get hasSelectableOptions() { return this.options.length > 0 && !this.options.every(t => t.disabled) } get length() { var t, e; return null !== (e = null === (t = this.options) || void 0 === t ? void 0 : t.length) && void 0 !== e ? e : 0 } get options() { return g.track(this, "options"), this._options } set options(t) { this._options = t, g.notify(this, "options") } get typeAheadExpired() { return this.typeaheadExpired } set typeAheadExpired(t) { this.typeaheadExpired = t } clickHandler(t) { const e = t.target.closest("option,[role=option]"); if (e && !e.disabled) return this.selectedIndex = this.options.indexOf(e), !0 } focusAndScrollOptionIntoView(t = this.firstSelectedOption) { this.contains(document.activeElement) && null !== t && (t.focus(), requestAnimationFrame(() => { t.scrollIntoView({ block: "nearest" }) })) } focusinHandler(t) { this.shouldSkipFocus || t.target !== t.currentTarget || (this.setSelectedOptions(), this.focusAndScrollOptionIntoView()), this.shouldSkipFocus = !1 } getTypeaheadMatches() { const t = this.typeaheadBuffer.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&"), e = new RegExp("^" + t, "gi"); return this.options.filter(t => t.text.trim().match(e)) } getSelectableIndex(t = this.selectedIndex, e) { const i = t > e ? -1 : t < e ? 1 : 0, o = t + i; let s = null; switch (i) { case -1: s = this.options.reduceRight((t, e, i) => !t && !e.disabled && i < o ? e : t, s); break; case 1: s = this.options.reduce((t, e, i) => !t && !e.disabled && i > o ? e : t, s) }return this.options.indexOf(s) } handleChange(t, e) { switch (e) { case "selected": Mi.slottedOptionFilter(t) && (this.selectedIndex = this.options.indexOf(t)), this.setSelectedOptions() } } handleTypeAhead(t) { this.typeaheadTimeout && window.clearTimeout(this.typeaheadTimeout), this.typeaheadTimeout = window.setTimeout(() => this.typeaheadExpired = !0, Mi.TYPE_AHEAD_TIMEOUT_MS), t.length > 1 || (this.typeaheadBuffer = `${this.typeaheadExpired ? "" : this.typeaheadBuffer}${t}`) } keydownHandler(t) { if (this.disabled) return !0; this.shouldSkipFocus = !1; const e = t.key; switch (e) { case "Home": t.shiftKey || (t.preventDefault(), this.selectFirstOption()); break; case "ArrowDown": t.shiftKey || (t.preventDefault(), this.selectNextOption()); break; case "ArrowUp": t.shiftKey || (t.preventDefault(), this.selectPreviousOption()); break; case "End": t.preventDefault(), this.selectLastOption(); break; case "Tab": return this.focusAndScrollOptionIntoView(), !0; case "Enter": case "Escape": return !0; case " ": if (this.typeaheadExpired) return !0; default: return 1 === e.length && this.handleTypeAhead("" + e), !0 } } mousedownHandler(t) { return this.shouldSkipFocus = !this.contains(document.activeElement), !0 } multipleChanged(t, e) { this.ariaMultiSelectable = e ? "true" : null } selectedIndexChanged(t, e) { var i; if (this.hasSelectableOptions) { if ((null === (i = this.options[this.selectedIndex]) || void 0 === i ? void 0 : i.disabled) && "number" == typeof t) { const i = this.getSelectableIndex(t, e), o = i > -1 ? i : t; return this.selectedIndex = o, void (e === o && this.selectedIndexChanged(e, o)) } this.setSelectedOptions() } else this.selectedIndex = -1 } selectedOptionsChanged(t, e) { var i; const o = e.filter(Mi.slottedOptionFilter); null === (i = this.options) || void 0 === i || i.forEach(t => { const e = g.getNotifier(t); e.unsubscribe(this, "selected"), t.selected = o.includes(t), e.subscribe(this, "selected") }) } selectFirstOption() { var t, e; this.disabled || (this.selectedIndex = null !== (e = null === (t = this.options) || void 0 === t ? void 0 : t.findIndex(t => !t.disabled)) && void 0 !== e ? e : -1) } selectLastOption() { this.disabled || (this.selectedIndex = function (t, e) { let i = t.length; for (; i--;)if (e(t[i], i, t)) return i; return -1 }(this.options, t => !t.disabled)) } selectNextOption() { !this.disabled && this.selectedIndex < this.options.length - 1 && (this.selectedIndex += 1) } selectPreviousOption() { !this.disabled && this.selectedIndex > 0 && (this.selectedIndex = this.selectedIndex - 1) } setDefaultSelectedOption() { var t, e; this.selectedIndex = null !== (e = null === (t = this.options) || void 0 === t ? void 0 : t.findIndex(t => t.defaultSelected)) && void 0 !== e ? e : -1 } setSelectedOptions() { var t, e, i; (null === (t = this.options) || void 0 === t ? void 0 : t.length) && (this.selectedOptions = [this.options[this.selectedIndex]], this.ariaActiveDescendant = null !== (i = null === (e = this.firstSelectedOption) || void 0 === e ? void 0 : e.id) && void 0 !== i ? i : "", this.focusAndScrollOptionIntoView()) } slottedOptionsChanged(t, e) { this.options = e.reduce((t, e) => (Pi(e) && t.push(e), t), []); const i = "" + this.options.length; this.options.forEach((t, e) => { t.id || (t.id = _e("option-")), t.ariaPosInSet = "" + (e + 1), t.ariaSetSize = i }), this.$fastController.isConnected && (this.setSelectedOptions(), this.setDefaultSelectedOption()) } typeaheadBufferChanged(t, e) { if (this.$fastController.isConnected) { const t = this.getTypeaheadMatches(); if (t.length) { const e = this.options.indexOf(t[0]); e > -1 && (this.selectedIndex = e) } this.typeaheadExpired = !1 } } } Mi.slottedOptionFilter = t => Pi(t) && !t.hidden, Mi.TYPE_AHEAD_TIMEOUT_MS = 1e3, Gt([it({ mode: "boolean" })], Mi.prototype, "disabled", void 0), Gt([f], Mi.prototype, "selectedIndex", void 0), Gt([f], Mi.prototype, "selectedOptions", void 0), Gt([f], Mi.prototype, "slottedOptions", void 0), Gt([f], Mi.prototype, "typeaheadBuffer", void 0); class Bi { } Gt([f], Bi.prototype, "ariaActiveDescendant", void 0), Gt([f], Bi.prototype, "ariaDisabled", void 0), Gt([f], Bi.prototype, "ariaExpanded", void 0), Gt([f], Bi.prototype, "ariaMultiSelectable", void 0), Ve(Bi, Qe), Ve(Mi, Bi); const Ni = "above", ji = "below"; class Ui extends Mi { } class qi extends (ai(Ui)) { constructor() { super(...arguments), this.proxy = document.createElement("input") } } const _i = "inline", Gi = "list", Wi = "both", Ki = "none"; class Xi extends qi { constructor() { super(...arguments), this._value = "", this.filteredOptions = [], this.filter = "", this.forcedPosition = !1, this.listboxId = _e("listbox-"), this.maxHeight = 0, this.open = !1 } formResetCallback() { super.formResetCallback(), this.setDefaultSelectedOption(), this.updateValue() } validate() { super.validate(this.control) } get isAutocompleteInline() { return this.autocomplete === _i || this.isAutocompleteBoth } get isAutocompleteList() { return this.autocomplete === Gi || this.isAutocompleteBoth } get isAutocompleteBoth() { return this.autocomplete === Wi } openChanged() { if (this.open) return this.ariaControls = this.listboxId, this.ariaExpanded = "true", this.setPositioning(), this.focusAndScrollOptionIntoView(), void d.queueUpdate(() => this.focus()); this.ariaControls = "", this.ariaExpanded = "false" } get options() { return g.track(this, "options"), this.filteredOptions.length ? this.filteredOptions : this._options } set options(t) { this._options = t, g.notify(this, "options") } placeholderChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.placeholder = this.placeholder) } positionChanged(t, e) { this.positionAttribute = e, this.setPositioning() } get value() { return g.track(this, "value"), this._value } set value(t) { var e, i, o; const s = "" + this._value; if (this.$fastController.isConnected && this.options) { const s = this.options.findIndex(e => e.text.toLowerCase() === t.toLowerCase()), n = null === (e = this.options[this.selectedIndex]) || void 0 === e ? void 0 : e.text, r = null === (i = this.options[s]) || void 0 === i ? void 0 : i.text; this.selectedIndex = n !== r ? s : this.selectedIndex, t = (null === (o = this.firstSelectedOption) || void 0 === o ? void 0 : o.text) || t } s !== t && (this._value = t, super.valueChanged(s, t), g.notify(this, "value")) } clickHandler(t) { if (!this.disabled) { if (this.open) { const e = t.target.closest("option,[role=option]"); if (!e || e.disabled) return; this.selectedOptions = [e], this.control.value = e.text, this.clearSelectionRange(), this.updateValue(!0) } return this.open = !this.open, this.open && this.control.focus(), !0 } } connectedCallback() { super.connectedCallback(), this.forcedPosition = !!this.positionAttribute, this.value && (this.initialValue = this.value) } disabledChanged(t, e) { super.disabledChanged && super.disabledChanged(t, e), this.ariaDisabled = this.disabled ? "true" : "false" } filterOptions() { this.autocomplete && this.autocomplete !== Ki || (this.filter = ""); const t = this.filter.toLowerCase(); this.filteredOptions = this._options.filter(t => t.text.toLowerCase().startsWith(this.filter.toLowerCase())), this.isAutocompleteList && (this.filteredOptions.length || t || (this.filteredOptions = this._options), this._options.forEach(t => { t.hidden = !this.filteredOptions.includes(t) })) } focusAndScrollOptionIntoView() { this.contains(document.activeElement) && (this.control.focus(), this.firstSelectedOption && requestAnimationFrame(() => { var t; null === (t = this.firstSelectedOption) || void 0 === t || t.scrollIntoView({ block: "nearest" }) })) } focusoutHandler(t) { if (this.syncValue(), !this.open) return !0; const e = t.relatedTarget; this.isSameNode(e) ? this.focus() : this.options && this.options.includes(e) || (this.open = !1) } inputHandler(t) { if (this.filter = this.control.value, this.filterOptions(), this.isAutocompleteInline || (this.selectedIndex = this.options.map(t => t.text).indexOf(this.control.value)), t.inputType.includes("deleteContent") || !this.filter.length) return !0; this.isAutocompleteList && !this.open && (this.open = !0), this.isAutocompleteInline && (this.filteredOptions.length ? (this.selectedOptions = [this.filteredOptions[0]], this.selectedIndex = this.options.indexOf(this.firstSelectedOption), this.setInlineSelection()) : this.selectedIndex = -1) } keydownHandler(t) { const e = t.key; if (t.ctrlKey || t.shiftKey) return !0; switch (e) { case "Enter": this.syncValue(), this.isAutocompleteInline && (this.filter = this.value), this.open = !1, this.clearSelectionRange(); break; case "Escape": if (this.isAutocompleteInline || (this.selectedIndex = -1), this.open) { this.open = !1; break } this.value = "", this.control.value = "", this.filter = "", this.filterOptions(); break; case "Tab": if (this.setInputToSelection(), !this.open) return !0; t.preventDefault(), this.open = !1; break; case "ArrowUp": case "ArrowDown": if (this.filterOptions(), !this.open) { this.open = !0; break } this.filteredOptions.length > 0 && super.keydownHandler(t), this.isAutocompleteInline && this.setInlineSelection(); break; default: return !0 } } keyupHandler(t) { switch (t.key) { case "ArrowLeft": case "ArrowRight": case "Backspace": case "Delete": case "Home": case "End": this.filter = this.control.value, this.selectedIndex = -1, this.filterOptions() } } selectedIndexChanged(t, e) { if (this.$fastController.isConnected) { if ((e = je(-1, this.options.length - 1, e)) !== this.selectedIndex) return void (this.selectedIndex = e); super.selectedIndexChanged(t, e) } } selectPreviousOption() { !this.disabled && this.selectedIndex >= 0 && (this.selectedIndex = this.selectedIndex - 1) } setDefaultSelectedOption() { if (this.$fastController.isConnected && this.options) { const t = this.options.findIndex(t => null !== t.getAttribute("selected") || t.selected); this.selectedIndex = t, !this.dirtyValue && this.firstSelectedOption && (this.value = this.firstSelectedOption.text), this.setSelectedOptions() } } setInputToSelection() { this.firstSelectedOption && (this.control.value = this.firstSelectedOption.text, this.control.focus()) } setInlineSelection() { this.firstSelectedOption && (this.setInputToSelection(), this.control.setSelectionRange(this.filter.length, this.control.value.length, "backward")) } syncValue() { var t; const e = this.selectedIndex > -1 ? null === (t = this.firstSelectedOption) || void 0 === t ? void 0 : t.text : this.control.value; this.updateValue(this.value !== e) } setPositioning() { const t = this.getBoundingClientRect(), e = window.innerHeight - t.bottom; this.position = this.forcedPosition ? this.positionAttribute : t.top > e ? Ni : ji, this.positionAttribute = this.forcedPosition ? this.positionAttribute : this.position, this.maxHeight = this.position === Ni ? ~~t.top : ~~e } selectedOptionsChanged(t, e) { this.$fastController.isConnected && this._options.forEach(t => { t.selected = e.includes(t) }) } slottedOptionsChanged(t, e) { super.slottedOptionsChanged(t, e), this.updateValue() } updateValue(t) { var e; this.$fastController.isConnected && (this.value = (null === (e = this.firstSelectedOption) || void 0 === e ? void 0 : e.text) || this.control.value, this.control.value = this.value), t && this.$emit("change") } clearSelectionRange() { const t = this.control.value.length; this.control.setSelectionRange(t, t) } } Gt([it({ attribute: "autocomplete", mode: "fromView" })], Xi.prototype, "autocomplete", void 0), Gt([f], Xi.prototype, "maxHeight", void 0), Gt([it({ attribute: "open", mode: "boolean" })], Xi.prototype, "open", void 0), Gt([it], Xi.prototype, "placeholder", void 0), Gt([it({ attribute: "position" })], Xi.prototype, "positionAttribute", void 0), Gt([f], Xi.prototype, "position", void 0); class Yi { } Gt([f], Yi.prototype, "ariaAutoComplete", void 0), Gt([f], Yi.prototype, "ariaControls", void 0), Ve(Yi, Bi), Ve(Xi, Nt, Yi); function Qi(t) { const e = t.parentElement; if (e) return e; { const e = t.getRootNode(); if (e.host instanceof HTMLElement) return e.host } return null } const Zi = document.createElement("div"); class Ji { setProperty(t, e) { d.queueUpdate(() => this.target.setProperty(t, e)) } removeProperty(t) { d.queueUpdate(() => this.target.removeProperty(t)) } } class to extends Ji { constructor() { super(); const t = new CSSStyleSheet; this.target = t.cssRules[t.insertRule(":root{}")].style, document.adoptedStyleSheets = [...document.adoptedStyleSheets, t] } } class eo extends Ji { constructor() { super(), this.style = document.createElement("style"), document.head.appendChild(this.style); const { sheet: t } = this.style; if (t) { const e = t.insertRule(":root{}", t.cssRules.length); this.target = t.cssRules[e].style } } } class io { constructor(t) { this.store = new Map, this.target = null; const e = t.$fastController; this.style = document.createElement("style"), e.addStyles(this.style), g.getNotifier(e).subscribe(this, "isConnected"), this.handleChange(e, "isConnected") } targetChanged() { if (null !== this.target) for (const [t, e] of this.store.entries()) this.target.setProperty(t, e) } setProperty(t, e) { this.store.set(t, e), d.queueUpdate(() => { null !== this.target && this.target.setProperty(t, e) }) } removeProperty(t) { this.store.delete(t), d.queueUpdate(() => { null !== this.target && this.target.removeProperty(t) }) } handleChange(t, e) { const { sheet: i } = this.style; if (i) { const t = i.insertRule(":host{}", i.cssRules.length); this.target = i.cssRules[t].style } else this.target = null } } Gt([f], io.prototype, "target", void 0); class oo { constructor(t) { this.target = t.style } setProperty(t, e) { d.queueUpdate(() => this.target.setProperty(t, e)) } removeProperty(t) { d.queueUpdate(() => this.target.removeProperty(t)) } } class so { setProperty(t, e) { so.properties[t] = e; for (const i of so.roots.values()) ao.getOrCreate(so.normalizeRoot(i)).setProperty(t, e) } removeProperty(t) { delete so.properties[t]; for (const e of so.roots.values()) ao.getOrCreate(so.normalizeRoot(e)).removeProperty(t) } static registerRoot(t) { const { roots: e } = so; if (!e.has(t)) { e.add(t); const i = ao.getOrCreate(this.normalizeRoot(t)); for (const t in so.properties) i.setProperty(t, so.properties[t]) } } static unregisterRoot(t) { const { roots: e } = so; if (e.has(t)) { e.delete(t); const i = ao.getOrCreate(so.normalizeRoot(t)); for (const t in so.properties) i.removeProperty(t) } } static normalizeRoot(t) { return t === Zi ? document : t } } so.roots = new Set, so.properties = {}; const no = new WeakMap, ro = d.supportsAdoptedStyleSheets ? class extends Ji { constructor(t) { super(); const e = new CSSStyleSheet; this.target = e.cssRules[e.insertRule(":host{}")].style, t.$fastController.addStyles(G.create([e])) } } : io, ao = Object.freeze({ getOrCreate(t) { if (no.has(t)) return no.get(t); let e; return t === Zi ? e = new so : t instanceof Document ? e = d.supportsAdoptedStyleSheets ? new to : new eo : e = t instanceof ut ? new ro(t) : new oo(t), no.set(t, e), e } }); class lo extends pt { constructor(t) { super(), this.subscribers = new WeakMap, this._appliedTo = new Set, this.name = t.name, null !== t.cssCustomPropertyName && (this.cssCustomProperty = "--" + t.cssCustomPropertyName, this.cssVar = `var(${this.cssCustomProperty})`), this.id = lo.uniqueId(), lo.tokensById.set(this.id, this) } get appliedTo() { return [...this._appliedTo] } static from(t) { return new lo({ name: "string" == typeof t ? t : t.name, cssCustomPropertyName: "string" == typeof t ? t : void 0 === t.cssCustomPropertyName ? t.name : t.cssCustomPropertyName }) } static isCSSDesignToken(t) { return "string" == typeof t.cssCustomProperty } static isDerivedDesignTokenValue(t) { return "function" == typeof t } static getTokenById(t) { return lo.tokensById.get(t) } getOrCreateSubscriberSet(t = this) { return this.subscribers.get(t) || this.subscribers.set(t, new Set) && this.subscribers.get(t) } createCSS() { return this.cssVar || "" } getValueFor(t) { const e = go.getOrCreate(t).get(this); if (void 0 !== e) return e; throw new Error(`Value could not be retrieved for token named "${this.name}". Ensure the value is set for ${t} or an ancestor of ${t}.`) } setValueFor(t, e) { return this._appliedTo.add(t), e instanceof lo && (e = this.alias(e)), go.getOrCreate(t).set(this, e), this } deleteValueFor(t) { return this._appliedTo.delete(t), go.existsFor(t) && go.getOrCreate(t).delete(this), this } withDefault(t) { return this.setValueFor(Zi, t), this } subscribe(t, e) { const i = this.getOrCreateSubscriberSet(e); e && !go.existsFor(e) && go.getOrCreate(e), i.has(t) || i.add(t) } unsubscribe(t, e) { const i = this.subscribers.get(e || this); i && i.has(t) && i.delete(t) } notify(t) { const e = Object.freeze({ token: this, target: t }); this.subscribers.has(this) && this.subscribers.get(this).forEach(t => t.handleChange(e)), this.subscribers.has(t) && this.subscribers.get(t).forEach(t => t.handleChange(e)) } alias(t) { return e => t.getValueFor(e) } } lo.uniqueId = (() => { let t = 0; return () => (t++, t.toString(16)) })(), lo.tokensById = new Map; class co { constructor(t, e, i) { this.source = t, this.token = e, this.node = i, this.dependencies = new Set, this.observer = g.binding(t, this, !1), this.observer.handleChange = this.observer.call, this.handleChange() } disconnect() { this.observer.disconnect() } handleChange() { this.node.store.set(this.token, this.observer.observe(this.node.target, b)) } } class ho { constructor() { this.values = new Map } set(t, e) { this.values.get(t) !== e && (this.values.set(t, e), g.getNotifier(this).notify(t.id)) } get(t) { return g.track(this, t.id), this.values.get(t) } delete(t) { this.values.delete(t) } all() { return this.values.entries() } } const uo = new WeakMap, po = new WeakMap; class go { constructor(t) { this.target = t, this.store = new ho, this.children = [], this.assignedValues = new Map, this.reflecting = new Set, this.bindingObservers = new Map, this.tokenValueChangeHandler = { handleChange: (t, e) => { const i = lo.getTokenById(e); if (i && (i.notify(this.target), lo.isCSSDesignToken(i))) { const e = this.parent, o = this.isReflecting(i); if (e) { const s = e.get(i), n = t.get(i); s === n || o ? s === n && o && this.stopReflectToCSS(i) : this.reflectToCSS(i) } else o || this.reflectToCSS(i) } } }, uo.set(t, this), g.getNotifier(this.store).subscribe(this.tokenValueChangeHandler), t instanceof ut ? t.$fastController.addBehaviors([this]) : t.isConnected && this.bind() } static getOrCreate(t) { return uo.get(t) || new go(t) } static existsFor(t) { return uo.has(t) } static findParent(t) { if (Zi !== t.target) { let e = Qi(t.target); for (; null !== e;) { if (uo.has(e)) return uo.get(e); e = Qi(e) } return go.getOrCreate(Zi) } return null } static findClosestAssignedNode(t, e) { let i = e; do { if (i.has(t)) return i; i = i.parent ? i.parent : i.target !== Zi ? go.getOrCreate(Zi) : null } while (null !== i); return null } get parent() { return po.get(this) || null } has(t) { return this.assignedValues.has(t) } get(t) { const e = this.store.get(t); if (void 0 !== e) return e; const i = this.getRaw(t); return void 0 !== i ? (this.hydrate(t, i), this.get(t)) : void 0 } getRaw(t) { var e; return this.assignedValues.has(t) ? this.assignedValues.get(t) : null === (e = go.findClosestAssignedNode(t, this)) || void 0 === e ? void 0 : e.getRaw(t) } set(t, e) { lo.isDerivedDesignTokenValue(this.assignedValues.get(t)) && this.tearDownBindingObserver(t), this.assignedValues.set(t, e), lo.isDerivedDesignTokenValue(e) ? this.setupBindingObserver(t, e) : this.store.set(t, e) } delete(t) { this.assignedValues.delete(t), this.tearDownBindingObserver(t); const e = this.getRaw(t); e ? this.hydrate(t, e) : this.store.delete(t) } bind() { const t = go.findParent(this); t && t.appendChild(this); for (const t of this.assignedValues.keys()) t.notify(this.target) } unbind() { if (this.parent) { po.get(this).removeChild(this) } } appendChild(t) { t.parent && po.get(t).removeChild(t); const e = this.children.filter(e => t.contains(e)); po.set(t, this), this.children.push(t), e.forEach(e => t.appendChild(e)), g.getNotifier(this.store).subscribe(t); for (const [e, i] of this.store.all()) t.hydrate(e, this.bindingObservers.has(e) ? this.getRaw(e) : i) } removeChild(t) { const e = this.children.indexOf(t); return -1 !== e && this.children.splice(e, 1), g.getNotifier(this.store).unsubscribe(t), t.parent === this && po.delete(t) } contains(t) { return function (t, e) { let i = e; for (; null !== i;) { if (i === t) return !0; i = Qi(i) } return !1 }(this.target, t.target) } reflectToCSS(t) { this.isReflecting(t) || (this.reflecting.add(t), go.cssCustomPropertyReflector.startReflection(t, this.target)) } stopReflectToCSS(t) { this.isReflecting(t) && (this.reflecting.delete(t), go.cssCustomPropertyReflector.stopReflection(t, this.target)) } isReflecting(t) { return this.reflecting.has(t) } handleChange(t, e) { const i = lo.getTokenById(e); i && this.hydrate(i, this.getRaw(i)) } hydrate(t, e) { if (!this.has(t)) { const i = this.bindingObservers.get(t); lo.isDerivedDesignTokenValue(e) ? i ? i.source !== e && (this.tearDownBindingObserver(t), this.setupBindingObserver(t, e)) : this.setupBindingObserver(t, e) : (i && this.tearDownBindingObserver(t), this.store.set(t, e)) } } setupBindingObserver(t, e) { const i = new co(e, t, this); return this.bindingObservers.set(t, i), i } tearDownBindingObserver(t) { return !!this.bindingObservers.has(t) && (this.bindingObservers.get(t).disconnect(), this.bindingObservers.delete(t), !0) } } go.cssCustomPropertyReflector = new class { startReflection(t, e) { t.subscribe(this, e), this.handleChange({ token: t, target: e }) } stopReflection(t, e) { t.unsubscribe(this, e), this.remove(t, e) } handleChange(t) { const { token: e, target: i } = t; this.add(e, i) } add(t, e) { ao.getOrCreate(e).setProperty(t.cssCustomProperty, this.resolveCSSValue(go.getOrCreate(e).get(t))) } remove(t, e) { ao.getOrCreate(e).removeProperty(t.cssCustomProperty) } resolveCSSValue(t) { return t && "function" == typeof t.createCSS ? t.createCSS() : t } }, Gt([f], go.prototype, "children", void 0); const fo = Object.freeze({ create: function (t) { return lo.from(t) }, notifyConnection: t => !(!t.isConnected || !go.existsFor(t)) && (go.getOrCreate(t).bind(), !0), notifyDisconnection: t => !(t.isConnected || !go.existsFor(t)) && (go.getOrCreate(t).unbind(), !0), registerRoot(t = Zi) { so.registerRoot(t) }, unregisterRoot(t = Zi) { so.unregisterRoot(t) } }), mo = Object.freeze({ definitionCallbackOnly: null, ignoreDuplicate: Symbol() }), vo = new Map, bo = new Map; let yo = null; const xo = ee.createInterface(t => t.cachedCallback(t => (null === yo && (yo = new wo(null, t)), yo))), $o = Object.freeze({ tagFor: t => bo.get(t), responsibleFor(t) { const e = t.$$designSystem$$; if (e) return e; return ee.findResponsibleContainer(t).get(xo) }, getOrCreate(t) { if (!t) return null === yo && (yo = ee.getOrCreateDOMContainer().get(xo)), yo; const e = t.$$designSystem$$; if (e) return e; const i = ee.getOrCreateDOMContainer(t); if (i.has(xo, !1)) return i.get(xo); { const e = new wo(t, i); return i.register(ve.instance(xo, e)), e } } }); class wo { constructor(t, e) { this.owner = t, this.container = e, this.designTokensInitialized = !1, this.prefix = "fast", this.shadowRootMode = void 0, this.disambiguate = () => mo.definitionCallbackOnly, null !== t && (t.$$designSystem$$ = this) } withPrefix(t) { return this.prefix = t, this } withShadowRootMode(t) { return this.shadowRootMode = t, this } withElementDisambiguation(t) { return this.disambiguate = t, this } withDesignTokenRoot(t) { return this.designTokenRoot = t, this } register(...t) { const e = this.container, i = [], o = this.disambiguate, s = this.shadowRootMode, n = { elementPrefix: this.prefix, tryDefineElement(t, n, r) { const a = function (t, e, i) { return "string" == typeof t ? { name: t, type: e, callback: i } : t }(t, n, r), { name: l, callback: c, baseClass: h } = a; let { type: d } = a, u = l, p = vo.get(u), g = !0; for (; p;) { const t = o(u, d, p); switch (t) { case mo.ignoreDuplicate: return; case mo.definitionCallbackOnly: g = !1, p = void 0; break; default: u = t, p = vo.get(u) } } g && ((bo.has(d) || d === Se) && (d = class extends d { }), vo.set(u, d), bo.set(d, u), h && bo.set(h, u)), i.push(new ko(e, u, d, s, c, g)) } }; this.designTokensInitialized || (this.designTokensInitialized = !0, null !== this.designTokenRoot && fo.registerRoot(this.designTokenRoot)), e.registerWithContext(n, ...t); for (const t of i) t.callback(t), t.willDefine && null !== t.definition && t.definition.define(); return this } } class ko { constructor(t, e, i, o, s, n) { this.container = t, this.name = e, this.type = i, this.shadowRootMode = o, this.callback = s, this.willDefine = n, this.definition = null } definePresentation(t) { De.define(this.name, t, this.container) } defineElement(t) { this.definition = new rt(this.type, Object.assign(Object.assign({}, t), { name: this.name })) } tagFor(t) { return $o.tagFor(t) } }
/*!
* tabbable 5.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var Co = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"], Io = Co.join(","), Fo = "undefined" == typeof Element ? function () { } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, Do = function (t) { return "INPUT" === t.tagName }, To = function (t) { return function (t) { return Do(t) && "radio" === t.type }(t) && !function (t) { if (!t.name) return !0; var e, i = t.form || t.ownerDocument, o = function (t) { return i.querySelectorAll('input[type="radio"][name="' + t + '"]') }; if ("undefined" != typeof window && void 0 !== window.CSS && "function" == typeof window.CSS.escape) e = o(window.CSS.escape(t.name)); else try { e = o(t.name) } catch (t) { return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", t.message), !1 } var s = function (t, e) { for (var i = 0; i < t.length; i++)if (t[i].checked && t[i].form === e) return t[i] }(e, t.form); return !s || s === t }(t) }, So = function (t, e) { return !(e.disabled || function (t) { return Do(t) && "hidden" === t.type }(e) || function (t, e) { if ("hidden" === getComputedStyle(t).visibility) return !0; var i = Fo.call(t, "details>summary:first-of-type") ? t.parentElement : t; if (Fo.call(i, "details:not([open]) *")) return !0; if (e && "full" !== e) { if ("non-zero-area" === e) { var o = t.getBoundingClientRect(), s = o.width, n = o.height; return 0 === s && 0 === n } } else for (; t;) { if ("none" === getComputedStyle(t).display) return !0; t = t.parentElement } return !1 }(e, t.displayCheck) || function (t) { return "DETAILS" === t.tagName && Array.prototype.slice.apply(t.children).some((function (t) { return "SUMMARY" === t.tagName })) }(e)) }, Oo = function (t, e) { return !(!So(t, e) || To(e) || function (t) { var e = parseInt(t.getAttribute("tabindex"), 10); return isNaN(e) ? function (t) { return "true" === t.contentEditable }(t) ? 0 : "AUDIO" !== t.nodeName && "VIDEO" !== t.nodeName && "DETAILS" !== t.nodeName || null !== t.getAttribute("tabindex") ? t.tabIndex : 0 : e }(e) < 0) }, Eo = function (t, e) { if (e = e || {}, !t) throw new Error("No node provided"); return !1 !== Fo.call(t, Io) && Oo(e, t) }, Vo = Co.concat("iframe").join(","), Ro = function (t, e) { if (e = e || {}, !t) throw new Error("No node provided"); return !1 !== Fo.call(t, Vo) && So(e, t) }; class Ao extends Se { constructor() { super(...arguments), this.modal = !0, this.hidden = !1, this.trapFocus = !0, this.trapFocusChanged = () => { this.$fastController.isConnected && this.updateTrapFocus() }, this.isTrappingFocus = !1, this.handleDocumentKeydown = t => { if (!t.defaultPrevented && !this.hidden) switch (t.key) { case "Escape": this.dismiss(), t.preventDefault(); break; case "Tab": this.handleTabKeyDown(t) } }, this.handleDocumentFocus = t => { !t.defaultPrevented && this.shouldForceFocus(t.target) && (this.focusFirstElement(), t.preventDefault()) }, this.handleTabKeyDown = t => { if (!this.trapFocus || this.hidden) return; const e = this.getTabQueueBounds(); return 0 !== e.length ? 1 === e.length ? (e[0].focus(), void t.preventDefault()) : void (t.shiftKey && t.target === e[0] ? (e[e.length - 1].focus(), t.preventDefault()) : t.shiftKey || t.target !== e[e.length - 1] || (e[0].focus(), t.preventDefault())) : void 0 }, this.getTabQueueBounds = () => Ao.reduceTabbableItems([], this), this.focusFirstElement = () => { const t = this.getTabQueueBounds(); t.length > 0 ? t[0].focus() : this.dialog instanceof HTMLElement && this.dialog.focus() }, this.shouldForceFocus = t => this.isTrappingFocus && !this.contains(t), this.shouldTrapFocus = () => this.trapFocus && !this.hidden, this.updateTrapFocus = t => { const e = void 0 === t ? this.shouldTrapFocus() : t; e && !this.isTrappingFocus ? (this.isTrappingFocus = !0, document.addEventListener("focusin", this.handleDocumentFocus), d.queueUpdate(() => { this.shouldForceFocus(document.activeElement) && this.focusFirstElement() })) : !e && this.isTrappingFocus && (this.isTrappingFocus = !1, document.removeEventListener("focusin", this.handleDocumentFocus)) } } dismiss() { this.$emit("dismiss"), this.$emit("cancel") } show() { this.hidden = !1 } hide() { this.hidden = !0, this.$emit("close") } connectedCallback() { super.connectedCallback(), document.addEventListener("keydown", this.handleDocumentKeydown), this.notifier = g.getNotifier(this), this.notifier.subscribe(this, "hidden"), this.updateTrapFocus() } disconnectedCallback() { super.disconnectedCallback(), document.removeEventListener("keydown", this.handleDocumentKeydown), this.updateTrapFocus(!1), this.notifier.unsubscribe(this, "hidden") } handleChange(t, e) { switch (e) { case "hidden": this.updateTrapFocus() } } static reduceTabbableItems(t, e) { return "-1" === e.getAttribute("tabindex") ? t : Eo(e) || Ao.isFocusableFastElement(e) && Ao.hasTabbableShadow(e) ? (t.push(e), t) : e.childElementCount ? t.concat(Array.from(e.children).reduce(Ao.reduceTabbableItems, [])) : t } static isFocusableFastElement(t) { var e, i; return !!(null === (i = null === (e = t.$fastController) || void 0 === e ? void 0 : e.definition.shadowOptions) || void 0 === i ? void 0 : i.delegatesFocus) } static hasTabbableShadow(t) { var e, i; return Array.from(null !== (i = null === (e = t.shadowRoot) || void 0 === e ? void 0 : e.querySelectorAll("*")) && void 0 !== i ? i : []).some(t => Eo(t)) } } Gt([it({ mode: "boolean" })], Ao.prototype, "modal", void 0), Gt([it({ mode: "boolean" })], Ao.prototype, "hidden", void 0), Gt([it({ attribute: "trap-focus", mode: "boolean" })], Ao.prototype, "trapFocus", void 0), Gt([it({ attribute: "aria-describedby" })], Ao.prototype, "ariaDescribedby", void 0), Gt([it({ attribute: "aria-labelledby" })], Ao.prototype, "ariaLabelledby", void 0), Gt([it({ attribute: "aria-label" })], Ao.prototype, "ariaLabel", void 0); const Lo = "separator"; class Po extends Se { constructor() { super(...arguments), this.role = Lo, this.orientation = Ae } } Gt([it], Po.prototype, "role", void 0), Gt([it], Po.prototype, "orientation", void 0); const zo = "next", Ho = "previous"; class Mo extends Se { constructor() { super(...arguments), this.hiddenFromAT = !0, this.direction = zo } keyupHandler(t) { if (!this.hiddenFromAT) { const e = t.key; "Enter" !== e && "Space" !== e || this.$emit("click", t), "Escape" === e && this.blur() } } } Gt([it({ mode: "boolean" })], Mo.prototype, "disabled", void 0), Gt([it({ attribute: "aria-hidden", converter: J })], Mo.prototype, "hiddenFromAT", void 0), Gt([it], Mo.prototype, "direction", void 0); class Bo extends Mi { constructor() { super(...arguments), this.activeIndex = -1, this.rangeStartIndex = -1 } get activeOption() { return this.options[this.activeIndex] } get checkedOptions() { var t; return null === (t = this.options) || void 0 === t ? void 0 : t.filter(t => t.checked) } get firstSelectedOptionIndex() { return this.options.indexOf(this.firstSelectedOption) } activeIndexChanged(t, e) { var i, o; this.ariaActiveDescendant = null !== (o = null === (i = this.options[e]) || void 0 === i ? void 0 : i.id) && void 0 !== o ? o : "", this.focusAndScrollOptionIntoView() } checkActiveIndex() { if (!this.multiple) return; const t = this.activeOption; t && (t.checked = !0) } checkFirstOption(t = !1) { t ? (-1 === this.rangeStartIndex && (this.rangeStartIndex = this.activeIndex + 1), this.options.forEach((t, e) => { t.checked = Ue(e, this.rangeStartIndex) })) : this.uncheckAllOptions(), this.activeIndex = 0, this.checkActiveIndex() } checkLastOption(t = !1) { t ? (-1 === this.rangeStartIndex && (this.rangeStartIndex = this.activeIndex), this.options.forEach((t, e) => { t.checked = Ue(e, this.rangeStartIndex, this.options.length) })) : this.uncheckAllOptions(), this.activeIndex = this.options.length - 1, this.checkActiveIndex() } connectedCallback() { super.connectedCallback(), this.addEventListener("focusout", this.focusoutHandler) } disconnectedCallback() { this.removeEventListener("focusout", this.focusoutHandler), super.disconnectedCallback() } checkNextOption(t = !1) { t ? (-1 === this.rangeStartIndex && (this.rangeStartIndex = this.activeIndex), this.options.forEach((t, e) => { t.checked = Ue(e, this.rangeStartIndex, this.activeIndex + 1) })) : this.uncheckAllOptions(), this.activeIndex += this.activeIndex < this.options.length - 1 ? 1 : 0, this.checkActiveIndex() } checkPreviousOption(t = !1) { t ? (-1 === this.rangeStartIndex && (this.rangeStartIndex = this.activeIndex), 1 === this.checkedOptions.length && (this.rangeStartIndex += 1), this.options.forEach((t, e) => { t.checked = Ue(e, this.activeIndex, this.rangeStartIndex) })) : this.uncheckAllOptions(), this.activeIndex -= this.activeIndex > 0 ? 1 : 0, this.checkActiveIndex() } clickHandler(t) { var e; if (!this.multiple) return super.clickHandler(t); const i = null === (e = t.target) || void 0 === e ? void 0 : e.closest("[role=option]"); return i && !i.disabled ? (this.uncheckAllOptions(), this.activeIndex = this.options.indexOf(i), this.checkActiveIndex(), this.toggleSelectedForAllCheckedOptions(), !0) : void 0 } focusAndScrollOptionIntoView() { super.focusAndScrollOptionIntoView(this.activeOption) } focusinHandler(t) { if (!this.multiple) return super.focusinHandler(t); this.shouldSkipFocus || t.target !== t.currentTarget || (this.uncheckAllOptions(), -1 === this.activeIndex && (this.activeIndex = -1 !== this.firstSelectedOptionIndex ? this.firstSelectedOptionIndex : 0), this.checkActiveIndex(), this.setSelectedOptions(), this.focusAndScrollOptionIntoView()), this.shouldSkipFocus = !1 } focusoutHandler(t) { this.multiple && this.uncheckAllOptions() } keydownHandler(t) { if (!this.multiple) return super.keydownHandler(t); if (this.disabled) return !0; const { key: e, shiftKey: i } = t; switch (this.shouldSkipFocus = !1, e) { case "Home": return void this.checkFirstOption(i); case "ArrowDown": return void this.checkNextOption(i); case "ArrowUp": return void this.checkPreviousOption(i); case "End": return void this.checkLastOption(i); case "Tab": return this.focusAndScrollOptionIntoView(), !0; case "Escape": return this.uncheckAllOptions(), this.checkActiveIndex(), !0; case " ": if (t.preventDefault(), this.typeAheadExpired) return void this.toggleSelectedForAllCheckedOptions(); default: return 1 === e.length && this.handleTypeAhead("" + e), !0 } } mousedownHandler(t) { if (t.offsetX >= 0 && t.offsetX <= this.scrollWidth) return super.mousedownHandler(t) } multipleChanged(t, e) { var i; this.ariaMultiSelectable = e ? "true" : null, null === (i = this.options) || void 0 === i || i.forEach(t => { t.checked = !e && void 0 }), this.setSelectedOptions() } setSelectedOptions() { this.multiple ? this.$fastController.isConnected && this.options && (this.selectedOptions = this.options.filter(t => t.selected), this.focusAndScrollOptionIntoView()) : super.setSelectedOptions() } sizeChanged(t, e) { var i; const o = Math.max(0, parseInt(null !== (i = null == e ? void 0 : e.toFixed()) && void 0 !== i ? i : "", 10)); o !== e && d.queueUpdate(() => { this.size = o }) } toggleSelectedForAllCheckedOptions() { const t = this.checkedOptions.filter(t => !t.disabled), e = !t.every(t => t.selected); t.forEach(t => t.selected = e), this.selectedIndex = this.options.indexOf(t[t.length - 1]), this.setSelectedOptions() } typeaheadBufferChanged(t, e) { if (this.multiple) { if (this.$fastController.isConnected) { const t = this.getTypeaheadMatches(), e = this.options.indexOf(t[0]); e > -1 && (this.activeIndex = e, this.uncheckAllOptions(), this.checkActiveIndex()), this.typeAheadExpired = !1 } } else super.typeaheadBufferChanged(t, e) } uncheckAllOptions(t = !1) { this.options.forEach(t => t.checked = !this.multiple && void 0), t || (this.rangeStartIndex = -1) } } Gt([f], Bo.prototype, "activeIndex", void 0), Gt([it({ mode: "boolean" })], Bo.prototype, "multiple", void 0), Gt([it({ converter: tt })], Bo.prototype, "size", void 0); const No = "menuitem", jo = "menuitemcheckbox", Uo = "menuitemradio", qo = { [No]: "menuitem", [jo]: "menuitemcheckbox", [Uo]: "menuitemradio" }; class _o extends Se { constructor() { super(...arguments), this.role = No, this.hasSubmenu = !1, this.currentDirection = Be.ltr, this.focusSubmenuOnLoad = !1, this.handleMenuItemKeyDown = t => { if (t.defaultPrevented) return !1; switch (t.key) { case "Enter": case " ": return this.invoke(), !1; case "ArrowRight": return this.expandAndFocus(), !1; case "ArrowLeft": if (this.expanded) return this.expanded = !1, this.focus(), !1 }return !0 }, this.handleMenuItemClick = t => (t.defaultPrevented || this.disabled || this.invoke(), !1), this.submenuLoaded = () => { this.focusSubmenuOnLoad && (this.focusSubmenuOnLoad = !1, this.hasSubmenu && (this.submenu.focus(), this.setAttribute("tabindex", "-1"))) }, this.handleMouseOver = t => (this.disabled || !this.hasSubmenu || this.expanded || (this.expanded = !0), !1), this.handleMouseOut = t => (!this.expanded || this.contains(document.activeElement) || (this.expanded = !1), !1), this.expandAndFocus = () => { this.hasSubmenu && (this.focusSubmenuOnLoad = !0, this.expanded = !0) }, this.invoke = () => { if (!this.disabled) switch (this.role) { case jo: this.checked = !this.checked; break; case No: this.updateSubmenu(), this.hasSubmenu ? this.expandAndFocus() : this.$emit("change"); break; case Uo: this.checked || (this.checked = !0) } }, this.updateSubmenu = () => { this.submenu = this.domChildren().find(t => "menu" === t.getAttribute("role")), this.hasSubmenu = void 0 !== this.submenu } } expandedChanged(t) { if (this.$fastController.isConnected) { if (void 0 === this.submenu) return; !1 === this.expanded ? this.submenu.collapseExpandedItem() : this.currentDirection = ti(this), this.$emit("expanded-change", this, { bubbles: !1 }) } } checkedChanged(t, e) { this.$fastController.isConnected && this.$emit("change") } connectedCallback() { super.connectedCallback(), d.queueUpdate(() => { this.updateSubmenu() }), this.startColumnCount || (this.startColumnCount = 1), this.observer = new MutationObserver(this.updateSubmenu) } disconnectedCallback() { super.disconnectedCallback(), this.submenu = void 0, void 0 !== this.observer && (this.observer.disconnect(), this.observer = void 0) } domChildren() { return Array.from(this.children).filter(t => !t.hasAttribute("hidden")) } } Gt([it({ mode: "boolean" })], _o.prototype, "disabled", void 0), Gt([it({ mode: "boolean" })], _o.prototype, "expanded", void 0), Gt([f], _o.prototype, "startColumnCount", void 0), Gt([it], _o.prototype, "role", void 0), Gt([it({ mode: "boolean" })], _o.prototype, "checked", void 0), Gt([f], _o.prototype, "submenuRegion", void 0), Gt([f], _o.prototype, "hasSubmenu", void 0), Gt([f], _o.prototype, "currentDirection", void 0), Gt([f], _o.prototype, "submenu", void 0), Ve(_o, Nt); class Go extends Se { constructor() { super(...arguments), this.expandedItem = null, this.focusIndex = -1, this.isNestedMenu = () => null !== this.parentElement && Pe(this.parentElement) && "menuitem" === this.parentElement.getAttribute("role"), this.handleFocusOut = t => { if (!this.contains(t.relatedTarget) && void 0 !== this.menuItems) { this.collapseExpandedItem(); const t = this.menuItems.findIndex(this.isFocusableElement); this.menuItems[this.focusIndex].setAttribute("tabindex", "-1"), this.menuItems[t].setAttribute("tabindex", "0"), this.focusIndex = t } }, this.handleItemFocus = t => { const e = t.target; void 0 !== this.menuItems && e !== this.menuItems[this.focusIndex] && (this.menuItems[this.focusIndex].setAttribute("tabindex", "-1"), this.focusIndex = this.menuItems.indexOf(e), e.setAttribute("tabindex", "0")) }, this.handleExpandedChanged = t => { if (t.defaultPrevented || null === t.target || void 0 === this.menuItems || this.menuItems.indexOf(t.target) < 0) return; t.preventDefault(); const e = t.target; null === this.expandedItem || e !== this.expandedItem || !1 !== e.expanded ? e.expanded && (null !== this.expandedItem && this.expandedItem !== e && (this.expandedItem.expanded = !1), this.menuItems[this.focusIndex].setAttribute("tabindex", "-1"), this.expandedItem = e, this.focusIndex = this.menuItems.indexOf(e), e.setAttribute("tabindex", "0")) : this.expandedItem = null }, this.removeItemListeners = () => { void 0 !== this.menuItems && this.menuItems.forEach(t => { t.removeEventListener("expanded-change", this.handleExpandedChanged), t.removeEventListener("focus", this.handleItemFocus) }) }, this.setItems = () => { const t = this.domChildren(); this.removeItemListeners(), this.menuItems = t; const e = this.menuItems.filter(this.isMenuItemElement); e.length && (this.focusIndex = 0); const i = e.reduce((t, e) => { const i = function (t) { const e = t.getAttribute("role"), i = t.querySelector("[slot=start]"); return e !== No && null === i || e === No && null !== i ? 1 : e !== No && null !== i ? 2 : 0 }(e); return t > i ? t : i }, 0); e.forEach((t, e) => { t.setAttribute("tabindex", 0 === e ? "0" : "-1"), t.addEventListener("expanded-change", this.handleExpandedChanged), t.addEventListener("focus", this.handleItemFocus), t instanceof _o && (t.startColumnCount = i) }) }, this.changeHandler = t => { if (void 0 === this.menuItems) return; const e = t.target, i = this.menuItems.indexOf(e); if (-1 !== i && "menuitemradio" === e.role && !0 === e.checked) { for (let t = i - 1; t >= 0; --t) { const e = this.menuItems[t], i = e.getAttribute("role"); if (i === Uo && (e.checked = !1), "separator" === i) break } const t = this.menuItems.length - 1; for (let e = i + 1; e <= t; ++e) { const t = this.menuItems[e], i = t.getAttribute("role"); if (i === Uo && (t.checked = !1), "separator" === i) break } } }, this.isMenuItemElement = t => Pe(t) && Go.focusableElementRoles.hasOwnProperty(t.getAttribute("role")), this.isFocusableElement = t => this.isMenuItemElement(t) } itemsChanged(t, e) { this.$fastController.isConnected && void 0 !== this.menuItems && this.setItems() } connectedCallback() { super.connectedCallback(), d.queueUpdate(() => { this.setItems() }), this.addEventListener("change", this.changeHandler) } disconnectedCallback() { super.disconnectedCallback(), this.removeItemListeners(), this.menuItems = void 0, this.removeEventListener("change", this.changeHandler) } focus() { this.setFocus(0, 1) } collapseExpandedItem() { null !== this.expandedItem && (this.expandedItem.expanded = !1, this.expandedItem = null) } handleMenuKeyDown(t) { if (!t.defaultPrevented && void 0 !== this.menuItems) switch (t.key) { case "ArrowDown": return void this.setFocus(this.focusIndex + 1, 1); case "ArrowUp": return void this.setFocus(this.focusIndex - 1, -1); case "End": return void this.setFocus(this.menuItems.length - 1, -1); case "Home": return void this.setFocus(0, 1); default: return !0 } } domChildren() { return Array.from(this.children).filter(t => !t.hasAttribute("hidden")) } setFocus(t, e) { if (void 0 !== this.menuItems) for (; t >= 0 && t < this.menuItems.length;) { const i = this.menuItems[t]; if (this.isFocusableElement(i)) { this.focusIndex > -1 && this.menuItems.length >= this.focusIndex - 1 && this.menuItems[this.focusIndex].setAttribute("tabindex", "-1"), this.focusIndex = t, i.setAttribute("tabindex", "0"), i.focus(); break } t += e } } } Go.focusableElementRoles = qo, Gt([f], Go.prototype, "items", void 0); class Wo extends Se { } class Ko extends (ai(Wo)) { constructor() { super(...arguments), this.proxy = document.createElement("input") } } const Xo = "text"; class Yo extends Ko { constructor() { super(...arguments), this.type = Xo } readOnlyChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.readOnly = this.readOnly, this.validate()) } autofocusChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.autofocus = this.autofocus, this.validate()) } placeholderChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.placeholder = this.placeholder) } typeChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.type = this.type, this.validate()) } listChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.setAttribute("list", this.list), this.validate()) } maxlengthChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.maxLength = this.maxlength, this.validate()) } minlengthChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.minLength = this.minlength, this.validate()) } patternChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.pattern = this.pattern, this.validate()) } sizeChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.size = this.size) } spellcheckChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.spellcheck = this.spellcheck) } connectedCallback() { super.connectedCallback(), this.proxy.setAttribute("type", this.type), this.validate(), this.autofocus && d.queueUpdate(() => { this.focus() }) } select() { this.control.select(), this.$emit("select") } handleTextInput() { this.value = this.control.value } handleChange() { this.$emit("change") } validate() { super.validate(this.control) } } Gt([it({ attribute: "readonly", mode: "boolean" })], Yo.prototype, "readOnly", void 0), Gt([it({ mode: "boolean" })], Yo.prototype, "autofocus", void 0), Gt([it], Yo.prototype, "placeholder", void 0), Gt([it], Yo.prototype, "type", void 0), Gt([it], Yo.prototype, "list", void 0), Gt([it({ converter: tt })], Yo.prototype, "maxlength", void 0), Gt([it({ converter: tt })], Yo.prototype, "minlength", void 0), Gt([it], Yo.prototype, "pattern", void 0), Gt([it({ converter: tt })], Yo.prototype, "size", void 0), Gt([it({ mode: "boolean" })], Yo.prototype, "spellcheck", void 0), Gt([f], Yo.prototype, "defaultSlottedNodes", void 0); class Qo { } Ve(Qo, Qe), Ve(Yo, Nt, Qo); class Zo extends Se { } class Jo extends (ai(Zo)) { constructor() { super(...arguments), this.proxy = document.createElement("input") } } class ts extends Jo { constructor() { super(...arguments), this.hideStep = !1, this.step = 1, this.isUserInput = !1 } maxChanged(t, e) { var i; this.max = Math.max(e, null !== (i = this.min) && void 0 !== i ? i : e); const o = Math.min(this.min, this.max); void 0 !== this.min && this.min !== o && (this.min = o), this.value = this.getValidValue(this.value) } minChanged(t, e) { var i; this.min = Math.min(e, null !== (i = this.max) && void 0 !== i ? i : e); const o = Math.max(this.min, this.max); void 0 !== this.max && this.max !== o && (this.max = o), this.value = this.getValidValue(this.value) } get valueAsNumber() { return parseFloat(super.value) } set valueAsNumber(t) { this.value = t.toString() } valueChanged(t, e) { this.value = this.getValidValue(e), e === this.value && (this.control && !this.isUserInput && (this.control.value = this.value), super.valueChanged(t, this.value), void 0 === t || this.isUserInput || (this.$emit("input"), this.$emit("change")), this.isUserInput = !1) } validate() { super.validate(this.control) } getValidValue(t) { var e, i; let o = parseFloat(parseFloat(t).toPrecision(12)); return isNaN(o) ? o = "" : (o = Math.min(o, null !== (e = this.max) && void 0 !== e ? e : o), o = Math.max(o, null !== (i = this.min) && void 0 !== i ? i : o).toString()), o } stepUp() { const t = parseFloat(this.value), e = isNaN(t) ? this.min > 0 ? this.min : this.max < 0 ? this.max : this.min ? 0 : this.step : t + this.step; this.value = e.toString() } stepDown() { const t = parseFloat(this.value), e = isNaN(t) ? this.min > 0 ? this.min : this.max < 0 ? this.max : this.min ? 0 : 0 - this.step : t - this.step; this.value = e.toString() } connectedCallback() { super.connectedCallback(), this.proxy.setAttribute("type", "number"), this.validate(), this.control.value = this.value, this.autofocus && d.queueUpdate(() => { this.focus() }) } select() { this.control.select(), this.$emit("select") } handleTextInput() { this.control.value = this.control.value.replace(/[^0-9\-+e.]/g, ""), this.isUserInput = !0, this.value = this.control.value } handleChange() { this.$emit("change") } handleKeyDown(t) { switch (t.key) { case "ArrowUp": return this.stepUp(), !1; case "ArrowDown": return this.stepDown(), !1 }return !0 } handleBlur() { this.control.value = this.value } } Gt([it({ attribute: "readonly", mode: "boolean" })], ts.prototype, "readOnly", void 0), Gt([it({ mode: "boolean" })], ts.prototype, "autofocus", void 0), Gt([it({ attribute: "hide-step", mode: "boolean" })], ts.prototype, "hideStep", void 0), Gt([it], ts.prototype, "placeholder", void 0), Gt([it], ts.prototype, "list", void 0), Gt([it({ converter: tt })], ts.prototype, "maxlength", void 0), Gt([it({ converter: tt })], ts.prototype, "minlength", void 0), Gt([it({ converter: tt })], ts.prototype, "size", void 0), Gt([it({ converter: tt })], ts.prototype, "step", void 0), Gt([it({ converter: tt })], ts.prototype, "max", void 0), Gt([it({ converter: tt })], ts.prototype, "min", void 0), Gt([f], ts.prototype, "defaultSlottedNodes", void 0), Ve(ts, Nt, Qo); class es extends Se { constructor() { super(...arguments), this.percentComplete = 0 } valueChanged() { this.$fastController.isConnected && this.updatePercentComplete() } minChanged() { this.$fastController.isConnected && this.updatePercentComplete() } maxChanged() { this.$fastController.isConnected && this.updatePercentComplete() } connectedCallback() { super.connectedCallback(), this.updatePercentComplete() } updatePercentComplete() { const t = "number" == typeof this.min ? this.min : 0, e = "number" == typeof this.max ? this.max : 100, i = "number" == typeof this.value ? this.value : 0, o = e - t; this.percentComplete = 0 === o ? 0 : Math.fround((i - t) / o * 100) } } Gt([it({ converter: tt })], es.prototype, "value", void 0), Gt([it({ converter: tt })], es.prototype, "min", void 0), Gt([it({ converter: tt })], es.prototype, "max", void 0), Gt([it({ mode: "boolean" })], es.prototype, "paused", void 0), Gt([f], es.prototype, "percentComplete", void 0); class is extends Se { constructor() { super(...arguments), this.orientation = Ae, this.radioChangeHandler = t => { const e = t.target; e.checked && (this.slottedRadioButtons.forEach(t => { t !== e && (t.checked = !1, this.isInsideFoundationToolbar || t.setAttribute("tabindex", "-1")) }), this.selectedRadio = e, this.value = e.value, e.setAttribute("tabindex", "0"), this.focusedRadio = e), t.stopPropagation() }, this.moveToRadioByIndex = (t, e) => { const i = t[e]; this.isInsideToolbar || (i.setAttribute("tabindex", "0"), i.readOnly ? this.slottedRadioButtons.forEach(t => { t !== i && t.setAttribute("tabindex", "-1") }) : (i.checked = !0, this.selectedRadio = i)), this.focusedRadio = i, i.focus() }, this.moveRightOffGroup = () => { var t; null === (t = this.nextElementSibling) || void 0 === t || t.focus() }, this.moveLeftOffGroup = () => { var t; null === (t = this.previousElementSibling) || void 0 === t || t.focus() }, this.focusOutHandler = t => { const e = this.slottedRadioButtons, i = t.target, o = null !== i ? e.indexOf(i) : 0, s = this.focusedRadio ? e.indexOf(this.focusedRadio) : -1; return (0 === s && o === s || s === e.length - 1 && s === o) && (this.selectedRadio ? (this.focusedRadio = this.selectedRadio, this.isInsideFoundationToolbar || (this.selectedRadio.setAttribute("tabindex", "0"), e.forEach(t => { t !== this.selectedRadio && t.setAttribute("tabindex", "-1") }))) : (this.focusedRadio = e[0], this.focusedRadio.setAttribute("tabindex", "0"), e.forEach(t => { t !== this.focusedRadio && t.setAttribute("tabindex", "-1") }))), !0 }, this.clickHandler = t => { const e = t.target; if (e) { const t = this.slottedRadioButtons; e.checked || 0 === t.indexOf(e) ? (e.setAttribute("tabindex", "0"), this.selectedRadio = e) : (e.setAttribute("tabindex", "-1"), this.selectedRadio = null), this.focusedRadio = e } t.preventDefault() }, this.shouldMoveOffGroupToTheRight = (t, e, i) => t === e.length && this.isInsideToolbar && "ArrowRight" === i, this.shouldMoveOffGroupToTheLeft = (t, e) => (this.focusedRadio ? t.indexOf(this.focusedRadio) - 1 : 0) < 0 && this.isInsideToolbar && "ArrowLeft" === e, this.checkFocusedRadio = () => { null === this.focusedRadio || this.focusedRadio.readOnly || this.focusedRadio.checked || (this.focusedRadio.checked = !0, this.focusedRadio.setAttribute("tabindex", "0"), this.focusedRadio.focus(), this.selectedRadio = this.focusedRadio) }, this.moveRight = t => { const e = this.slottedRadioButtons; let i = 0; if (i = this.focusedRadio ? e.indexOf(this.focusedRadio) + 1 : 1, this.shouldMoveOffGroupToTheRight(i, e, t.key)) this.moveRightOffGroup(); else for (i === e.length && (i = 0); i < e.length && e.length > 1;) { if (!e[i].disabled) { this.moveToRadioByIndex(e, i); break } if (this.focusedRadio && i === e.indexOf(this.focusedRadio)) break; if (i + 1 >= e.length) { if (this.isInsideToolbar) break; i = 0 } else i += 1 } }, this.moveLeft = t => { const e = this.slottedRadioButtons; let i = 0; if (i = this.focusedRadio ? e.indexOf(this.focusedRadio) - 1 : 0, i = i < 0 ? e.length - 1 : i, this.shouldMoveOffGroupToTheLeft(e, t.key)) this.moveLeftOffGroup(); else for (; i >= 0 && e.length > 1;) { if (!e[i].disabled) { this.moveToRadioByIndex(e, i); break } if (this.focusedRadio && i === e.indexOf(this.focusedRadio)) break; i - 1 < 0 ? i = e.length - 1 : i -= 1 } }, this.keydownHandler = t => { const e = t.key; if (e in Me && this.isInsideFoundationToolbar) return !0; switch (e) { case "Enter": this.checkFocusedRadio(); break; case "ArrowRight": case "ArrowDown": this.direction === Be.ltr ? this.moveRight(t) : this.moveLeft(t); break; case "ArrowLeft": case "ArrowUp": this.direction === Be.ltr ? this.moveLeft(t) : this.moveRight(t); break; default: return !0 } } } readOnlyChanged() { void 0 !== this.slottedRadioButtons && this.slottedRadioButtons.forEach(t => { this.readOnly ? t.readOnly = !0 : t.readOnly = !1 }) } disabledChanged() { void 0 !== this.slottedRadioButtons && this.slottedRadioButtons.forEach(t => { this.disabled ? t.disabled = !0 : t.disabled = !1 }) } nameChanged() { this.slottedRadioButtons && this.slottedRadioButtons.forEach(t => { t.setAttribute("name", this.name) }) } valueChanged() { this.slottedRadioButtons && this.slottedRadioButtons.forEach(t => { t.value === this.value && (t.checked = !0, this.selectedRadio = t) }), this.$emit("change") } slottedRadioButtonsChanged(t, e) { this.slottedRadioButtons && this.slottedRadioButtons.length > 0 && this.setupRadioButtons() } get parentToolbar() { return this.closest('[role="toolbar"]') } get isInsideToolbar() { var t; return null !== (t = this.parentToolbar) && void 0 !== t && t } get isInsideFoundationToolbar() { var t; return !!(null === (t = this.parentToolbar) || void 0 === t ? void 0 : t.$fastController) } connectedCallback() { super.connectedCallback(), this.direction = ti(this), this.setupRadioButtons() } disconnectedCallback() { this.slottedRadioButtons.forEach(t => { t.removeEventListener("change", this.radioChangeHandler) }) } setupRadioButtons() { const t = this.slottedRadioButtons.filter(t => t.hasAttribute("checked")), e = t ? t.length : 0; if (e > 1) { t[e - 1].checked = !0 } let i = !1; if (this.slottedRadioButtons.forEach(t => { void 0 !== this.name && t.setAttribute("name", this.name), this.disabled && (t.disabled = !0), this.readOnly && (t.readOnly = !0), this.value && this.value === t.value ? (this.selectedRadio = t, this.focusedRadio = t, t.checked = !0, t.setAttribute("tabindex", "0"), i = !0) : (this.isInsideFoundationToolbar || t.setAttribute("tabindex", "-1"), t.checked = !1), t.addEventListener("change", this.radioChangeHandler) }), void 0 === this.value && this.slottedRadioButtons.length > 0) { const t = this.slottedRadioButtons.filter(t => t.hasAttribute("checked")), e = null !== t ? t.length : 0; if (e > 0 && !i) { const i = t[e - 1]; i.checked = !0, this.focusedRadio = i, i.setAttribute("tabindex", "0") } else this.slottedRadioButtons[0].setAttribute("tabindex", "0"), this.focusedRadio = this.slottedRadioButtons[0] } } } Gt([it({ attribute: "readonly", mode: "boolean" })], is.prototype, "readOnly", void 0), Gt([it({ attribute: "disabled", mode: "boolean" })], is.prototype, "disabled", void 0), Gt([it], is.prototype, "name", void 0), Gt([it], is.prototype, "value", void 0), Gt([it], is.prototype, "orientation", void 0), Gt([f], is.prototype, "childItems", void 0), Gt([f], is.prototype, "slottedRadioButtons", void 0); class os extends Se { } class ss extends (li(os)) { constructor() { super(...arguments), this.proxy = document.createElement("input") } } class ns extends ss { constructor() { super(), this.initialValue = "on", this.keypressHandler = t => { switch (t.key) { case " ": return void (this.checked || this.readOnly || (this.checked = !0)) }return !0 }, this.proxy.setAttribute("type", "radio") } readOnlyChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.readOnly = this.readOnly) } defaultCheckedChanged() { var t; this.$fastController.isConnected && !this.dirtyChecked && (this.isInsideRadioGroup() || (this.checked = null !== (t = this.defaultChecked) && void 0 !== t && t, this.dirtyChecked = !1)) } connectedCallback() { var t, e; super.connectedCallback(), this.validate(), "radiogroup" !== (null === (t = this.parentElement) || void 0 === t ? void 0 : t.getAttribute("role")) && null === this.getAttribute("tabindex") && (this.disabled || this.setAttribute("tabindex", "0")), this.checkedAttribute && (this.dirtyChecked || this.isInsideRadioGroup() || (this.checked = null !== (e = this.defaultChecked) && void 0 !== e && e, this.dirtyChecked = !1)) } isInsideRadioGroup() { return null !== this.closest("[role=radiogroup]") } clickHandler(t) { this.disabled || this.readOnly || this.checked || (this.checked = !0) } } Gt([it({ attribute: "readonly", mode: "boolean" })], ns.prototype, "readOnly", void 0), Gt([f], ns.prototype, "name", void 0), Gt([f], ns.prototype, "defaultSlottedNodes", void 0); class rs extends Se { constructor() { super(...arguments), this.framesPerSecond = 60, this.updatingItems = !1, this.speed = 600, this.easing = "ease-in-out", this.flippersHiddenFromAT = !1, this.scrolling = !1, this.resizeDetector = null } get frameTime() { return 1e3 / this.framesPerSecond } scrollingChanged(t, e) { if (this.scrollContainer) { const t = 1 == this.scrolling ? "scrollstart" : "scrollend"; this.$emit(t, this.scrollContainer.scrollLeft) } } get isRtl() { return this.scrollItems.length > 1 && this.scrollItems[0].offsetLeft > this.scrollItems[1].offsetLeft } connectedCallback() { super.connectedCallback(), this.initializeResizeDetector() } disconnectedCallback() { this.disconnectResizeDetector(), super.disconnectedCallback() } scrollItemsChanged(t, e) { e && !this.updatingItems && d.queueUpdate(() => this.setStops()) } disconnectResizeDetector() { this.resizeDetector && (this.resizeDetector.disconnect(), this.resizeDetector = null) } initializeResizeDetector() { this.disconnectResizeDetector(), this.resizeDetector = new window.ResizeObserver(this.resized.bind(this)), this.resizeDetector.observe(this) } updateScrollStops() { this.updatingItems = !0; const t = this.scrollItems.reduce((t, e) => e instanceof HTMLSlotElement ? t.concat(e.assignedElements()) : (t.push(e), t), []); this.scrollItems = t, this.updatingItems = !1 } setStops() { this.updateScrollStops(); const { scrollContainer: t } = this, { scrollLeft: e } = t, { width: i, left: o } = t.getBoundingClientRect(); this.width = i; let s = 0, n = this.scrollItems.map((t, i) => { const { left: n, width: r } = t.getBoundingClientRect(), a = Math.round(n + e - o), l = Math.round(a + r); return this.isRtl ? -l : (s = l, 0 === i ? 0 : a) }).concat(s); n = this.fixScrollMisalign(n), n.sort((t, e) => Math.abs(t) - Math.abs(e)), this.scrollStops = n, this.setFlippers() } fixScrollMisalign(t) { if (this.isRtl && t.some(t => t > 0)) { t.sort((t, e) => e - t); const e = t[0]; t = t.map(t => t - e) } return t } setFlippers() { var t, e; const i = this.scrollContainer.scrollLeft; if (null === (t = this.previousFlipperContainer) || void 0 === t || t.classList.toggle("disabled", 0 === i), this.scrollStops) { const t = Math.abs(this.scrollStops[this.scrollStops.length - 1]); null === (e = this.nextFlipperContainer) || void 0 === e || e.classList.toggle("disabled", Math.abs(i) + this.width >= t) } } scrollInView(t, e = 0, i) { var o; if ("number" != typeof t && t && (t = this.scrollItems.findIndex(e => e === t || e.contains(t))), void 0 !== t) { i = null != i ? i : e; const { scrollContainer: s, scrollStops: n, scrollItems: r } = this, { scrollLeft: a } = this.scrollContainer, { width: l } = s.getBoundingClientRect(), c = n[t], { width: h } = r[t].getBoundingClientRect(), d = c + h, u = a + e > c; if (u || a + l - i < d) { const t = null !== (o = [...n].sort((t, e) => u ? e - t : t - e).find(t => u ? t + e < c : t + l - (null != i ? i : 0) > d)) && void 0 !== o ? o : 0; this.scrollToPosition(t) } } } keyupHandler(t) { switch (t.key) { case "ArrowLeft": this.scrollToPrevious(); break; case "ArrowRight": this.scrollToNext() } } scrollToPrevious() { const t = this.scrollContainer.scrollLeft, e = this.scrollStops.findIndex((e, i) => e >= t && (this.isRtl || i === this.scrollStops.length - 1 || this.scrollStops[i + 1] > t)), i = Math.abs(this.scrollStops[e + 1]); let o = this.scrollStops.findIndex(t => Math.abs(t) + this.width > i); (o >= e || -1 === o) && (o = e > 0 ? e - 1 : 0), this.scrollToPosition(this.scrollStops[o], t) } scrollToNext() { const t = this.scrollContainer.scrollLeft, e = this.scrollStops.findIndex(e => Math.abs(e) >= Math.abs(t)), i = this.scrollStops.findIndex(e => Math.abs(t) + this.width <= Math.abs(e)); let o = e; i > e + 2 ? o = i - 2 : e < this.scrollStops.length - 2 && (o = e + 1), this.scrollToPosition(this.scrollStops[o], t) } scrollToPosition(t, e = this.scrollContainer.scrollLeft) { var i; if (this.scrolling) return; this.scrolling = !0; const o = null !== (i = this.duration) && void 0 !== i ? i : Math.abs(t - e) / this.speed + "s"; this.content.style.setProperty("transition-duration", o); const s = parseFloat(getComputedStyle(this.content).getPropertyValue("transition-duration")), n = e => { e && e.target !== e.currentTarget || (this.content.style.setProperty("transition-duration", "0s"), this.content.style.removeProperty("transform"), this.scrollContainer.style.setProperty("scroll-behavior", "auto"), this.scrollContainer.scrollLeft = t, this.setFlippers(), this.content.removeEventListener("transitionend", n), this.scrolling = !1) }; if (0 === s) return void n(); this.content.addEventListener("transitionend", n); const r = this.scrollContainer.scrollWidth - this.scrollContainer.clientWidth; let a = this.scrollContainer.scrollLeft - Math.min(t, r); this.isRtl && (a = this.scrollContainer.scrollLeft + Math.min(Math.abs(t), r)), this.content.style.setProperty("transition-property", "transform"), this.content.style.setProperty("transition-timing-function", this.easing), this.content.style.setProperty("transform", `translateX(${a}px)`) } resized() { this.resizeTimeout && (this.resizeTimeout = clearTimeout(this.resizeTimeout)), this.resizeTimeout = setTimeout(() => { this.width = this.scrollContainer.offsetWidth, this.setFlippers() }, this.frameTime) } scrolled() { this.scrollTimeout && (this.scrollTimeout = clearTimeout(this.scrollTimeout)), this.scrollTimeout = setTimeout(() => { this.setFlippers() }, this.frameTime) } } Gt([it({ converter: tt })], rs.prototype, "speed", void 0), Gt([it], rs.prototype, "duration", void 0), Gt([it], rs.prototype, "easing", void 0), Gt([it({ attribute: "flippers-hidden-from-at", converter: J })], rs.prototype, "flippersHiddenFromAT", void 0), Gt([f], rs.prototype, "scrolling", void 0), Gt([f], rs.prototype, "scrollItems", void 0), Gt([it({ attribute: "view" })], rs.prototype, "view", void 0); function as(t, e, i) { return t.nodeType !== Node.TEXT_NODE || "string" == typeof t.nodeValue && !!t.nodeValue.trim().length } class ls extends Se { } class cs extends (ai(ls)) { constructor() { super(...arguments), this.proxy = document.createElement("input") } } class hs extends cs { readOnlyChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.readOnly = this.readOnly, this.validate()) } autofocusChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.autofocus = this.autofocus, this.validate()) } placeholderChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.placeholder = this.placeholder) } listChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.setAttribute("list", this.list), this.validate()) } maxlengthChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.maxLength = this.maxlength, this.validate()) } minlengthChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.minLength = this.minlength, this.validate()) } patternChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.pattern = this.pattern, this.validate()) } sizeChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.size = this.size) } spellcheckChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.spellcheck = this.spellcheck) } connectedCallback() { super.connectedCallback(), this.validate(), this.autofocus && d.queueUpdate(() => { this.focus() }) } validate() { super.validate(this.control) } handleTextInput() { this.value = this.control.value } handleClearInput() { this.value = "", this.control.focus(), this.handleChange() } handleChange() { this.$emit("change") } } Gt([it({ attribute: "readonly", mode: "boolean" })], hs.prototype, "readOnly", void 0), Gt([it({ mode: "boolean" })], hs.prototype, "autofocus", void 0), Gt([it], hs.prototype, "placeholder", void 0), Gt([it], hs.prototype, "list", void 0), Gt([it({ converter: tt })], hs.prototype, "maxlength", void 0), Gt([it({ converter: tt })], hs.prototype, "minlength", void 0), Gt([it], hs.prototype, "pattern", void 0), Gt([it({ converter: tt })], hs.prototype, "size", void 0), Gt([it({ mode: "boolean" })], hs.prototype, "spellcheck", void 0), Gt([f], hs.prototype, "defaultSlottedNodes", void 0); class ds { } Ve(ds, Qe), Ve(hs, Nt, ds); class us extends Bo { } class ps extends (ai(us)) { constructor() { super(...arguments), this.proxy = document.createElement("select") } } class gs extends ps { constructor() { super(...arguments), this.open = !1, this.forcedPosition = !1, this.listboxId = _e("listbox-"), this.maxHeight = 0 } openChanged(t, e) { if (this.collapsible) { if (this.open) return this.ariaControls = this.listboxId, this.ariaExpanded = "true", this.setPositioning(), this.focusAndScrollOptionIntoView(), this.indexWhenOpened = this.selectedIndex, void d.queueUpdate(() => this.focus()); this.ariaControls = "", this.ariaExpanded = "false" } } get collapsible() { return !(this.multiple || "number" == typeof this.size) } get value() { return g.track(this, "value"), this._value } set value(t) { var e, i, o, s, n, r, a; const l = "" + this._value; if (null === (e = this._options) || void 0 === e ? void 0 : e.length) { const e = this._options.findIndex(e => e.value === t), l = null !== (o = null === (i = this._options[this.selectedIndex]) || void 0 === i ? void 0 : i.value) && void 0 !== o ? o : null, c = null !== (n = null === (s = this._options[e]) || void 0 === s ? void 0 : s.value) && void 0 !== n ? n : null; -1 !== e && l === c || (t = "", this.selectedIndex = e), t = null !== (a = null === (r = this.firstSelectedOption) || void 0 === r ? void 0 : r.value) && void 0 !== a ? a : t } l !== t && (this._value = t, super.valueChanged(l, t), g.notify(this, "value"), this.updateDisplayValue()) } updateValue(t) { var e, i; this.$fastController.isConnected && (this.value = null !== (i = null === (e = this.firstSelectedOption) || void 0 === e ? void 0 : e.value) && void 0 !== i ? i : ""), t && (this.$emit("input"), this.$emit("change", this, { bubbles: !0, composed: void 0 })) } selectedIndexChanged(t, e) { super.selectedIndexChanged(t, e), this.updateValue() } positionChanged(t, e) { this.positionAttribute = e, this.setPositioning() } setPositioning() { const t = this.getBoundingClientRect(), e = window.innerHeight - t.bottom; this.position = this.forcedPosition ? this.positionAttribute : t.top > e ? Ni : ji, this.positionAttribute = this.forcedPosition ? this.positionAttribute : this.position, this.maxHeight = this.position === Ni ? ~~t.top : ~~e } get displayValue() { var t, e; return g.track(this, "displayValue"), null !== (e = null === (t = this.firstSelectedOption) || void 0 === t ? void 0 : t.text) && void 0 !== e ? e : "" } disabledChanged(t, e) { super.disabledChanged && super.disabledChanged(t, e), this.ariaDisabled = this.disabled ? "true" : "false" } formResetCallback() { this.setProxyOptions(), super.setDefaultSelectedOption(), -1 === this.selectedIndex && (this.selectedIndex = 0) } clickHandler(t) { if (!this.disabled) { if (this.open) { const e = t.target.closest("option,[role=option]"); if (e && e.disabled) return } return super.clickHandler(t), this.open = this.collapsible && !this.open, this.open || this.indexWhenOpened === this.selectedIndex || this.updateValue(!0), !0 } } focusoutHandler(t) { var e; if (super.focusoutHandler(t), !this.open) return !0; const i = t.relatedTarget; this.isSameNode(i) ? this.focus() : (null === (e = this.options) || void 0 === e ? void 0 : e.includes(i)) || (this.open = !1, this.indexWhenOpened !== this.selectedIndex && this.updateValue(!0)) } handleChange(t, e) { super.handleChange(t, e), "value" === e && this.updateValue() } slottedOptionsChanged(t, e) { this.options.forEach(t => { g.getNotifier(t).unsubscribe(this, "value") }), super.slottedOptionsChanged(t, e), this.options.forEach(t => { g.getNotifier(t).subscribe(this, "value") }), this.setProxyOptions(), this.updateValue() } mousedownHandler(t) { var e; return t.offsetX >= 0 && t.offsetX <= (null === (e = this.listbox) || void 0 === e ? void 0 : e.scrollWidth) ? super.mousedownHandler(t) : this.collapsible } multipleChanged(t, e) { super.multipleChanged(t, e), this.proxy && (this.proxy.multiple = e) } selectedOptionsChanged(t, e) { var i; super.selectedOptionsChanged(t, e), null === (i = this.options) || void 0 === i || i.forEach((t, e) => { var i; const o = null === (i = this.proxy) || void 0 === i ? void 0 : i.options.item(e); o && (o.selected = t.selected) }) } setDefaultSelectedOption() { var t; const e = null !== (t = this.options) && void 0 !== t ? t : Array.from(this.children).filter(Mi.slottedOptionFilter), i = null == e ? void 0 : e.findIndex(t => t.hasAttribute("selected") || t.selected || t.value === this.value); this.selectedIndex = -1 === i ? 0 : i } setProxyOptions() { this.proxy instanceof HTMLSelectElement && this.options && (this.proxy.options.length = 0, this.options.forEach(t => { const e = t.proxy || (t instanceof HTMLOptionElement ? t.cloneNode() : null); e && this.proxy.options.add(e) })) } keydownHandler(t) { super.keydownHandler(t); const e = t.key || t.key.charCodeAt(0); switch (e) { case " ": t.preventDefault(), this.collapsible && this.typeAheadExpired && (this.open = !this.open); break; case "Home": case "End": t.preventDefault(); break; case "Enter": t.preventDefault(), this.open = !this.open; break; case "Escape": this.collapsible && this.open && (t.preventDefault(), this.open = !1); break; case "Tab": return this.collapsible && this.open && (t.preventDefault(), this.open = !1), !0 }return this.open || this.indexWhenOpened === this.selectedIndex || (this.updateValue(!0), this.indexWhenOpened = this.selectedIndex), !("ArrowDown" === e || "ArrowUp" === e) } connectedCallback() { super.connectedCallback(), this.forcedPosition = !!this.positionAttribute, this.addEventListener("contentchange", this.updateDisplayValue) } disconnectedCallback() { this.removeEventListener("contentchange", this.updateDisplayValue), super.disconnectedCallback() } sizeChanged(t, e) { super.sizeChanged(t, e), this.proxy && (this.proxy.size = e) } updateDisplayValue() { this.collapsible && g.notify(this, "displayValue") } } Gt([it({ attribute: "open", mode: "boolean" })], gs.prototype, "open", void 0), Gt([function (t, e, i) { return Object.assign({}, i, { get: function () { return g.trackVolatile(), i.get.apply(this) } }) }], gs.prototype, "collapsible", null), Gt([f], gs.prototype, "control", void 0), Gt([it({ attribute: "position" })], gs.prototype, "positionAttribute", void 0), Gt([f], gs.prototype, "position", void 0), Gt([f], gs.prototype, "maxHeight", void 0); class fs { } Gt([f], fs.prototype, "ariaControls", void 0), Ve(fs, Bi), Ve(gs, Nt, fs); class ms extends Se { constructor() { super(...arguments), this.shape = "rect" } } Gt([it], ms.prototype, "fill", void 0), Gt([it], ms.prototype, "shape", void 0), Gt([it], ms.prototype, "pattern", void 0), Gt([it({ mode: "boolean" })], ms.prototype, "shimmer", void 0); function vs(t, e, i, o) { let s = je(0, 1, (t - e) / (i - e)); return o === Be.rtl && (s = 1 - s), s } const bs = { min: 0, max: 0, direction: Be.ltr, orientation: Ae, disabled: !1 }; class ys extends Se { constructor() { super(...arguments), this.hideMark = !1, this.sliderDirection = Be.ltr, this.getSliderConfiguration = () => { if (this.isSliderConfig(this.parentNode)) { const t = this.parentNode, { min: e, max: i, direction: o, orientation: s, disabled: n } = t; void 0 !== n && (this.disabled = n), this.sliderDirection = o || Be.ltr, this.sliderOrientation = s || Ae, this.sliderMaxPosition = i, this.sliderMinPosition = e } else this.sliderDirection = bs.direction || Be.ltr, this.sliderOrientation = bs.orientation, this.sliderMaxPosition = bs.max, this.sliderMinPosition = bs.min }, this.positionAsStyle = () => { const t = this.sliderDirection ? this.sliderDirection : Be.ltr, e = vs(Number(this.position), Number(this.sliderMinPosition), Number(this.sliderMaxPosition)); let i = Math.round(100 * (1 - e)), o = Math.round(100 * e); return Number.isNaN(o) && Number.isNaN(i) && (i = 50, o = 50), this.sliderOrientation === Ae ? t === Be.rtl ? `right: ${o}%; left: ${i}%;` : `left: ${o}%; right: ${i}%;` : `top: ${o}%; bottom: ${i}%;` } } positionChanged() { this.positionStyle = this.positionAsStyle() } sliderOrientationChanged() { } connectedCallback() { super.connectedCallback(), this.getSliderConfiguration(), this.positionStyle = this.positionAsStyle(), this.notifier = g.getNotifier(this.parentNode), this.notifier.subscribe(this, "orientation"), this.notifier.subscribe(this, "direction"), this.notifier.subscribe(this, "max"), this.notifier.subscribe(this, "min") } disconnectedCallback() { super.disconnectedCallback(), this.notifier.unsubscribe(this, "orientation"), this.notifier.unsubscribe(this, "direction"), this.notifier.unsubscribe(this, "max"), this.notifier.unsubscribe(this, "min") } handleChange(t, e) { switch (e) { case "direction": this.sliderDirection = t.direction; break; case "orientation": this.sliderOrientation = t.orientation; break; case "max": this.sliderMaxPosition = t.max; break; case "min": this.sliderMinPosition = t.min }this.positionStyle = this.positionAsStyle() } isSliderConfig(t) { return void 0 !== t.max && void 0 !== t.min } } Gt([f], ys.prototype, "positionStyle", void 0), Gt([it], ys.prototype, "position", void 0), Gt([it({ attribute: "hide-mark", mode: "boolean" })], ys.prototype, "hideMark", void 0), Gt([it({ attribute: "disabled", mode: "boolean" })], ys.prototype, "disabled", void 0), Gt([f], ys.prototype, "sliderOrientation", void 0), Gt([f], ys.prototype, "sliderMinPosition", void 0), Gt([f], ys.prototype, "sliderMaxPosition", void 0), Gt([f], ys.prototype, "sliderDirection", void 0); class xs extends Se { } class $s extends (ai(xs)) { constructor() { super(...arguments), this.proxy = document.createElement("input") } } const ws = "single-value"; class ks extends $s { constructor() { super(...arguments), this.direction = Be.ltr, this.isDragging = !1, this.trackWidth = 0, this.trackMinWidth = 0, this.trackHeight = 0, this.trackLeft = 0, this.trackMinHeight = 0, this.valueTextFormatter = () => null, this.min = 0, this.max = 10, this.step = 1, this.orientation = Ae, this.mode = ws, this.keypressHandler = t => { if (!this.readOnly) if ("Home" === t.key) t.preventDefault(), this.value = "" + this.min; else if ("End" === t.key) t.preventDefault(), this.value = "" + this.max; else if (!t.shiftKey) switch (t.key) { case "ArrowRight": case "ArrowUp": t.preventDefault(), this.increment(); break; case "ArrowLeft": case "ArrowDown": t.preventDefault(), this.decrement() } }, this.setupTrackConstraints = () => { const t = this.track.getBoundingClientRect(); this.trackWidth = this.track.clientWidth, this.trackMinWidth = this.track.clientLeft, this.trackHeight = t.bottom, this.trackMinHeight = t.top, this.trackLeft = this.getBoundingClientRect().left, 0 === this.trackWidth && (this.trackWidth = 1) }, this.setupListeners = (t = !1) => { const e = (t ? "remove" : "add") + "EventListener"; this[e]("keydown", this.keypressHandler), this[e]("mousedown", this.handleMouseDown), this.thumb[e]("mousedown", this.handleThumbMouseDown, { passive: !0 }), this.thumb[e]("touchstart", this.handleThumbMouseDown, { passive: !0 }), t && (this.handleMouseDown(null), this.handleThumbMouseDown(null)) }, this.initialValue = "", this.handleThumbMouseDown = t => { if (t) { if (this.readOnly || this.disabled || t.defaultPrevented) return; t.target.focus() } const e = (null !== t ? "add" : "remove") + "EventListener"; window[e]("mouseup", this.handleWindowMouseUp), window[e]("mousemove", this.handleMouseMove, { passive: !0 }), window[e]("touchmove", this.handleMouseMove, { passive: !0 }), window[e]("touchend", this.handleWindowMouseUp), this.isDragging = null !== t }, this.handleMouseMove = t => { if (this.readOnly || this.disabled || t.defaultPrevented) return; const e = window.TouchEvent && t instanceof TouchEvent ? t.touches[0] : t, i = this.orientation === Ae ? e.pageX - document.documentElement.scrollLeft - this.trackLeft : e.pageY - document.documentElement.scrollTop; this.value = "" + this.calculateNewValue(i) }, this.calculateNewValue = t => { const e = vs(t, this.orientation === Ae ? this.trackMinWidth : this.trackMinHeight, this.orientation === Ae ? this.trackWidth : this.trackHeight, this.direction), i = (this.max - this.min) * e + this.min; return this.convertToConstrainedValue(i) }, this.handleWindowMouseUp = t => { this.stopDragging() }, this.stopDragging = () => { this.isDragging = !1, this.handleMouseDown(null), this.handleThumbMouseDown(null) }, this.handleMouseDown = t => { const e = (null !== t ? "add" : "remove") + "EventListener"; if ((null === t || !this.disabled && !this.readOnly) && (window[e]("mouseup", this.handleWindowMouseUp), window.document[e]("mouseleave", this.handleWindowMouseUp), window[e]("mousemove", this.handleMouseMove), t)) { t.preventDefault(), this.setupTrackConstraints(), t.target.focus(); const e = this.orientation === Ae ? t.pageX - document.documentElement.scrollLeft - this.trackLeft : t.pageY - document.documentElement.scrollTop; this.value = "" + this.calculateNewValue(e) } }, this.convertToConstrainedValue = t => { isNaN(t) && (t = this.min); let e = t - this.min; const i = e - Math.round(e / this.step) * (this.stepMultiplier * this.step) / this.stepMultiplier; return e = i >= Number(this.step) / 2 ? e - i + Number(this.step) : e - i, e + this.min } } readOnlyChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.readOnly = this.readOnly) } get valueAsNumber() { return parseFloat(super.value) } set valueAsNumber(t) { this.value = t.toString() } valueChanged(t, e) { super.valueChanged(t, e), this.$fastController.isConnected && this.setThumbPositionForOrientation(this.direction), this.$emit("change") } minChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.min = "" + this.min), this.validate() } maxChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.max = "" + this.max), this.validate() } stepChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.step = "" + this.step), this.updateStepMultiplier(), this.validate() } orientationChanged() { this.$fastController.isConnected && this.setThumbPositionForOrientation(this.direction) } connectedCallback() { super.connectedCallback(), this.proxy.setAttribute("type", "range"), this.direction = ti(this), this.updateStepMultiplier(), this.setupTrackConstraints(), this.setupListeners(), this.setupDefaultValue(), this.setThumbPositionForOrientation(this.direction) } disconnectedCallback() { this.setupListeners(!0) } increment() { const t = this.direction !== Be.rtl && this.orientation !== Le ? Number(this.value) + Number(this.step) : Number(this.value) - Number(this.step), e = this.convertToConstrainedValue(t), i = e < Number(this.max) ? "" + e : "" + this.max; this.value = i } decrement() { const t = this.direction !== Be.rtl && this.orientation !== Le ? Number(this.value) - Number(this.step) : Number(this.value) + Number(this.step), e = this.convertToConstrainedValue(t), i = e > Number(this.min) ? "" + e : "" + this.min; this.value = i } setThumbPositionForOrientation(t) { const e = 100 * (1 - vs(Number(this.value), Number(this.min), Number(this.max), t)); this.orientation === Ae ? this.position = this.isDragging ? `right: ${e}%; transition: none;` : `right: ${e}%; transition: all 0.2s ease;` : this.position = this.isDragging ? `bottom: ${e}%; transition: none;` : `bottom: ${e}%; transition: all 0.2s ease;` } updateStepMultiplier() { const t = this.step + "", e = this.step % 1 ? t.length - t.indexOf(".") - 1 : 0; this.stepMultiplier = Math.pow(10, e) } get midpoint() { return "" + this.convertToConstrainedValue((this.max + this.min) / 2) } setupDefaultValue() { if ("string" == typeof this.value) if (0 === this.value.length) this.initialValue = this.midpoint; else { const t = parseFloat(this.value); !Number.isNaN(t) && (t < this.min || t > this.max) && (this.value = this.midpoint) } } } Gt([it({ attribute: "readonly", mode: "boolean" })], ks.prototype, "readOnly", void 0), Gt([f], ks.prototype, "direction", void 0), Gt([f], ks.prototype, "isDragging", void 0), Gt([f], ks.prototype, "position", void 0), Gt([f], ks.prototype, "trackWidth", void 0), Gt([f], ks.prototype, "trackMinWidth", void 0), Gt([f], ks.prototype, "trackHeight", void 0), Gt([f], ks.prototype, "trackLeft", void 0), Gt([f], ks.prototype, "trackMinHeight", void 0), Gt([f], ks.prototype, "valueTextFormatter", void 0), Gt([it({ converter: tt })], ks.prototype, "min", void 0), Gt([it({ converter: tt })], ks.prototype, "max", void 0), Gt([it({ converter: tt })], ks.prototype, "step", void 0), Gt([it], ks.prototype, "orientation", void 0), Gt([it], ks.prototype, "mode", void 0); class Cs extends Se { } class Is extends (li(Cs)) { constructor() { super(...arguments), this.proxy = document.createElement("input") } } class Fs extends Is { constructor() { super(), this.initialValue = "on", this.keypressHandler = t => { if (!this.readOnly) switch (t.key) { case "Enter": case " ": this.checked = !this.checked } }, this.clickHandler = t => { this.disabled || this.readOnly || (this.checked = !this.checked) }, this.proxy.setAttribute("type", "checkbox") } readOnlyChanged() { this.proxy instanceof HTMLInputElement && (this.proxy.readOnly = this.readOnly), this.readOnly ? this.classList.add("readonly") : this.classList.remove("readonly") } checkedChanged(t, e) { super.checkedChanged(t, e), this.checked ? this.classList.add("checked") : this.classList.remove("checked") } } Gt([it({ attribute: "readonly", mode: "boolean" })], Fs.prototype, "readOnly", void 0), Gt([f], Fs.prototype, "defaultSlottedNodes", void 0); class Ds extends Se { } class Ts extends Se { } Gt([it({ mode: "boolean" })], Ts.prototype, "disabled", void 0); const Ss = "horizontal"; class Os extends Se { constructor() { super(...arguments), this.orientation = Ss, this.activeindicator = !0, this.showActiveIndicator = !0, this.prevActiveTabIndex = 0, this.activeTabIndex = 0, this.ticking = !1, this.change = () => { this.$emit("change", this.activetab) }, this.isDisabledElement = t => "true" === t.getAttribute("aria-disabled"), this.isFocusableElement = t => !this.isDisabledElement(t), this.setTabs = () => { const t = this.isHorizontal() ? "gridColumn" : "gridRow"; this.activeTabIndex = this.getActiveIndex(), this.showActiveIndicator = !1, this.tabs.forEach((e, i) => { if ("tab" === e.slot) { const t = this.activeTabIndex === i && this.isFocusableElement(e); this.activeindicator && this.isFocusableElement(e) && (this.showActiveIndicator = !0); const o = this.tabIds[i], s = this.tabpanelIds[i]; e.setAttribute("id", o), e.setAttribute("aria-selected", t ? "true" : "false"), e.setAttribute("aria-controls", s), e.addEventListener("click", this.handleTabClick), e.addEventListener("keydown", this.handleTabKeyDown), e.setAttribute("tabindex", t ? "0" : "-1"), t && (this.activetab = e) } e.style.gridColumn = "", e.style.gridRow = "", e.style[t] = "" + (i + 1), this.isHorizontal() ? e.classList.remove("vertical") : e.classList.add("vertical") }) }, this.setTabPanels = () => { this.tabpanels.forEach((t, e) => { const i = this.tabIds[e], o = this.tabpanelIds[e]; t.setAttribute("id", o), t.setAttribute("aria-labelledby", i), this.activeTabIndex !== e ? t.setAttribute("hidden", "") : t.removeAttribute("hidden") }) }, this.handleTabClick = t => { const e = t.currentTarget; 1 === e.nodeType && this.isFocusableElement(e) && (this.prevActiveTabIndex = this.activeTabIndex, this.activeTabIndex = this.tabs.indexOf(e), this.setComponent()) }, this.handleTabKeyDown = t => { if (this.isHorizontal()) switch (t.key) { case "ArrowLeft": t.preventDefault(), this.adjustBackward(t); break; case "ArrowRight": t.preventDefault(), this.adjustForward(t) } else switch (t.key) { case "ArrowUp": t.preventDefault(), this.adjustBackward(t); break; case "ArrowDown": t.preventDefault(), this.adjustForward(t) }switch (t.key) { case "Home": t.preventDefault(), this.adjust(-this.activeTabIndex); break; case "End": t.preventDefault(), this.adjust(this.tabs.length - this.activeTabIndex - 1) } }, this.adjustForward = t => { const e = this.tabs; let i = 0; for (i = this.activetab ? e.indexOf(this.activetab) + 1 : 1, i === e.length && (i = 0); i < e.length && e.length > 1;) { if (this.isFocusableElement(e[i])) { this.moveToTabByIndex(e, i); break } if (this.activetab && i === e.indexOf(this.activetab)) break; i + 1 >= e.length ? i = 0 : i += 1 } }, this.adjustBackward = t => { const e = this.tabs; let i = 0; for (i = this.activetab ? e.indexOf(this.activetab) - 1 : 0, i = i < 0 ? e.length - 1 : i; i >= 0 && e.length > 1;) { if (this.isFocusableElement(e[i])) { this.moveToTabByIndex(e, i); break } i - 1 < 0 ? i = e.length - 1 : i -= 1 } }, this.moveToTabByIndex = (t, e) => { const i = t[e]; this.activetab = i, this.prevActiveTabIndex = this.activeTabIndex, this.activeTabIndex = e, i.focus(), this.setComponent() } } orientationChanged() { this.$fastController.isConnected && (this.setTabs(), this.setTabPanels(), this.handleActiveIndicatorPosition()) } activeidChanged(t, e) { this.$fastController.isConnected && this.tabs.length <= this.tabpanels.length && (this.prevActiveTabIndex = this.tabs.findIndex(e => e.id === t), this.setTabs(), this.setTabPanels(), this.handleActiveIndicatorPosition()) } tabsChanged() { this.$fastController.isConnected && this.tabs.length <= this.tabpanels.length && (this.tabIds = this.getTabIds(), this.tabpanelIds = this.getTabPanelIds(), this.setTabs(), this.setTabPanels(), this.handleActiveIndicatorPosition()) } tabpanelsChanged() { this.$fastController.isConnected && this.tabpanels.length <= this.tabs.length && (this.tabIds = this.getTabIds(), this.tabpanelIds = this.getTabPanelIds(), this.setTabs(), this.setTabPanels(), this.handleActiveIndicatorPosition()) } getActiveIndex() { return void 0 !== this.activeid ? -1 === this.tabIds.indexOf(this.activeid) ? 0 : this.tabIds.indexOf(this.activeid) : 0 } getTabIds() { return this.tabs.map(t => { var e; return null !== (e = t.getAttribute("id")) && void 0 !== e ? e : "tab-" + _e() }) } getTabPanelIds() { return this.tabpanels.map(t => { var e; return null !== (e = t.getAttribute("id")) && void 0 !== e ? e : "panel-" + _e() }) } setComponent() { this.activeTabIndex !== this.prevActiveTabIndex && (this.activeid = this.tabIds[this.activeTabIndex], this.focusTab(), this.change()) } isHorizontal() { return this.orientation === Ss } handleActiveIndicatorPosition() { this.showActiveIndicator && this.activeindicator && this.activeTabIndex !== this.prevActiveTabIndex && (this.ticking ? this.ticking = !1 : (this.ticking = !0, this.animateActiveIndicator())) } animateActiveIndicator() { this.ticking = !0; const t = this.isHorizontal() ? "gridColumn" : "gridRow", e = this.isHorizontal() ? "translateX" : "translateY", i = this.isHorizontal() ? "offsetLeft" : "offsetTop", o = this.activeIndicatorRef[i]; this.activeIndicatorRef.style[t] = "" + (this.activeTabIndex + 1); const s = this.activeIndicatorRef[i]; this.activeIndicatorRef.style[t] = "" + (this.prevActiveTabIndex + 1); const n = s - o; this.activeIndicatorRef.style.transform = `${e}(${n}px)`, this.activeIndicatorRef.classList.add("activeIndicatorTransition"), this.activeIndicatorRef.addEventListener("transitionend", () => { this.ticking = !1, this.activeIndicatorRef.style[t] = "" + (this.activeTabIndex + 1), this.activeIndicatorRef.style.transform = e + "(0px)", this.activeIndicatorRef.classList.remove("activeIndicatorTransition") }) } adjust(t) { this.prevActiveTabIndex = this.activeTabIndex, this.activeTabIndex = Ne(0, this.tabs.length - 1, this.activeTabIndex + t), this.setComponent() } focusTab() { this.tabs[this.activeTabIndex].focus() } connectedCallback() { super.connectedCallback(), this.tabIds = this.getTabIds(), this.tabpanelIds = this.getTabPanelIds(), this.activeTabIndex = this.getActiveIndex() } } Gt([it], Os.prototype, "orientation", void 0), Gt([it], Os.prototype, "activeid", void 0), Gt([f], Os.prototype, "tabs", void 0), Gt([f], Os.prototype, "tabpanels", void 0), Gt([it({ mode: "boolean" })], Os.prototype, "activeindicator", void 0), Gt([f], Os.prototype, "activeIndicatorRef", void 0), Gt([f], Os.prototype, "showActiveIndicator", void 0), Ve(Os, Nt); class Es extends Se { } class Vs extends (ai(Es)) { constructor() { super(...arguments), this.proxy = document.createElement("textarea") } } const Rs = "none"; class As extends Vs { constructor() { super(...arguments), this.resize = Rs, this.cols = 20, this.handleTextInput = () => { this.value = this.control.value } } readOnlyChanged() { this.proxy instanceof HTMLTextAreaElement && (this.proxy.readOnly = this.readOnly) } autofocusChanged() { this.proxy instanceof HTMLTextAreaElement && (this.proxy.autofocus = this.autofocus) } listChanged() { this.proxy instanceof HTMLTextAreaElement && this.proxy.setAttribute("list", this.list) } maxlengthChanged() { this.proxy instanceof HTMLTextAreaElement && (this.proxy.maxLength = this.maxlength) } minlengthChanged() { this.proxy instanceof HTMLTextAreaElement && (this.proxy.minLength = this.minlength) } spellcheckChanged() { this.proxy instanceof HTMLTextAreaElement && (this.proxy.spellcheck = this.spellcheck) } select() { this.control.select(), this.$emit("select") } handleChange() { this.$emit("change") } validate() { super.validate(this.control) } } Gt([it({ mode: "boolean" })], As.prototype, "readOnly", void 0), Gt([it], As.prototype, "resize", void 0), Gt([it({ mode: "boolean" })], As.prototype, "autofocus", void 0), Gt([it({ attribute: "form" })], As.prototype, "formId", void 0), Gt([it], As.prototype, "list", void 0), Gt([it({ converter: tt })], As.prototype, "maxlength", void 0), Gt([it({ converter: tt })], As.prototype, "minlength", void 0), Gt([it], As.prototype, "name", void 0), Gt([it], As.prototype, "placeholder", void 0), Gt([it({ converter: tt, mode: "fromView" })], As.prototype, "cols", void 0), Gt([it({ converter: tt, mode: "fromView" })], As.prototype, "rows", void 0), Gt([it({ mode: "boolean" })], As.prototype, "spellcheck", void 0), Gt([f], As.prototype, "defaultSlottedNodes", void 0), Ve(As, Qo); const Ls = Object.freeze({ [Me.ArrowUp]: { [Le]: -1 }, [Me.ArrowDown]: { [Le]: 1 }, [Me.ArrowLeft]: { [Ae]: { [Be.ltr]: -1, [Be.rtl]: 1 } }, [Me.ArrowRight]: { [Ae]: { [Be.ltr]: 1, [Be.rtl]: -1 } } }); class Ps extends Se { constructor() { super(...arguments), this._activeIndex = 0, this.direction = Be.ltr, this.orientation = Ae } get activeIndex() { return g.track(this, "activeIndex"), this._activeIndex } set activeIndex(t) { this.$fastController.isConnected && (this._activeIndex = je(0, this.focusableElements.length - 1, t), g.notify(this, "activeIndex")) } slottedItemsChanged() { this.$fastController.isConnected && this.reduceFocusableElements() } clickHandler(t) { var e; const i = null === (e = this.focusableElements) || void 0 === e ? void 0 : e.indexOf(t.target); return i > -1 && this.activeIndex !== i && this.setFocusedElement(i), !0 } childItemsChanged(t, e) { this.$fastController.isConnected && this.reduceFocusableElements() } connectedCallback() { super.connectedCallback(), this.direction = ti(this) } focusinHandler(t) { const e = t.relatedTarget; e && !this.contains(e) && this.setFocusedElement() } getDirectionalIncrementer(t) { var e, i, o, s, n; return null !== (n = null !== (o = null === (i = null === (e = Ls[t]) || void 0 === e ? void 0 : e[this.orientation]) || void 0 === i ? void 0 : i[this.direction]) && void 0 !== o ? o : null === (s = Ls[t]) || void 0 === s ? void 0 : s[this.orientation]) && void 0 !== n ? n : 0 } keydownHandler(t) { const e = t.key; if (!(e in Me) || t.defaultPrevented || t.shiftKey) return !0; const i = this.getDirectionalIncrementer(e); if (!i) return !t.target.closest("[role=radiogroup]"); const o = this.activeIndex + i; return this.focusableElements[o] && t.preventDefault(), this.setFocusedElement(o), !0 } get allSlottedItems() { return [...this.start.assignedElements(), ...this.slottedItems, ...this.end.assignedElements()] } reduceFocusableElements() { var t; const e = null === (t = this.focusableElements) || void 0 === t ? void 0 : t[this.activeIndex]; this.focusableElements = this.allSlottedItems.reduce(Ps.reduceFocusableItems, []); const i = this.focusableElements.indexOf(e); this.activeIndex = Math.max(0, i), this.setFocusableElements() } setFocusedElement(t = this.activeIndex) { var e; this.activeIndex = t, this.setFocusableElements(), null === (e = this.focusableElements[this.activeIndex]) || void 0 === e || e.focus() } static reduceFocusableItems(t, e) { var i, o, s, n; const r = "radio" === e.getAttribute("role"), a = null === (o = null === (i = e.$fastController) || void 0 === i ? void 0 : i.definition.shadowOptions) || void 0 === o ? void 0 : o.delegatesFocus, l = Array.from(null !== (n = null === (s = e.shadowRoot) || void 0 === s ? void 0 : s.querySelectorAll("*")) && void 0 !== n ? n : []).some(t => Ro(t)); return e.hasAttribute("disabled") || e.hasAttribute("hidden") || !(Ro(e) || r || a || l) ? e.childElementCount ? t.concat(Array.from(e.children).reduce(Ps.reduceFocusableItems, [])) : t : (t.push(e), t) } setFocusableElements() { this.$fastController.isConnected && this.focusableElements.length > 0 && this.focusableElements.forEach((t, e) => { t.tabIndex = this.activeIndex === e ? 0 : -1 }) } } Gt([f], Ps.prototype, "direction", void 0), Gt([it], Ps.prototype, "orientation", void 0), Gt([f], Ps.prototype, "slottedItems", void 0), Gt([f], Ps.prototype, "slottedLabel", void 0), Gt([f], Ps.prototype, "childItems", void 0); class zs { } Gt([it({ attribute: "aria-labelledby" })], zs.prototype, "ariaLabelledby", void 0), Gt([it({ attribute: "aria-label" })], zs.prototype, "ariaLabel", void 0), Ve(zs, Qe), Ve(Ps, Nt, zs); const Hs = "top", Ms = "right", Bs = "bottom", Ns = "left", js = "start", Us = "end", qs = "top-left", _s = "top-right", Gs = "bottom-left", Ws = "bottom-right", Ks = "top-start", Xs = "top-end", Ys = "bottom-start", Qs = "bottom-end"; class Zs extends Se { constructor() { super(...arguments), this.anchor = "", this.delay = 300, this.autoUpdateMode = "anchor", this.anchorElement = null, this.viewportElement = null, this.verticalPositioningMode = "dynamic", this.horizontalPositioningMode = "dynamic", this.horizontalInset = "false", this.verticalInset = "false", this.horizontalScaling = "content", this.verticalScaling = "content", this.verticalDefaultPosition = void 0, this.horizontalDefaultPosition = void 0, this.tooltipVisible = !1, this.currentDirection = Be.ltr, this.showDelayTimer = null, this.hideDelayTimer = null, this.isAnchorHoveredFocused = !1, this.isRegionHovered = !1, this.handlePositionChange = t => { this.classList.toggle("top", "start" === this.region.verticalPosition), this.classList.toggle("bottom", "end" === this.region.verticalPosition), this.classList.toggle("inset-top", "insetStart" === this.region.verticalPosition), this.classList.toggle("inset-bottom", "insetEnd" === this.region.verticalPosition), this.classList.toggle("center-vertical", "center" === this.region.verticalPosition), this.classList.toggle("left", "start" === this.region.horizontalPosition), this.classList.toggle("right", "end" === this.region.horizontalPosition), this.classList.toggle("inset-left", "insetStart" === this.region.horizontalPosition), this.classList.toggle("inset-right", "insetEnd" === this.region.horizontalPosition), this.classList.toggle("center-horizontal", "center" === this.region.horizontalPosition) }, this.handleRegionMouseOver = t => { this.isRegionHovered = !0 }, this.handleRegionMouseOut = t => { this.isRegionHovered = !1, this.startHideDelayTimer() }, this.handleAnchorMouseOver = t => { this.tooltipVisible ? this.isAnchorHoveredFocused = !0 : this.startShowDelayTimer() }, this.handleAnchorMouseOut = t => { this.isAnchorHoveredFocused = !1, this.clearShowDelayTimer(), this.startHideDelayTimer() }, this.handleAnchorFocusIn = t => { this.startShowDelayTimer() }, this.handleAnchorFocusOut = t => { this.isAnchorHoveredFocused = !1, this.clearShowDelayTimer(), this.startHideDelayTimer() }, this.startHideDelayTimer = () => { this.clearHideDelayTimer(), this.tooltipVisible && (this.hideDelayTimer = window.setTimeout(() => { this.updateTooltipVisibility() }, 60)) }, this.clearHideDelayTimer = () => { null !== this.hideDelayTimer && (clearTimeout(this.hideDelayTimer), this.hideDelayTimer = null) }, this.startShowDelayTimer = () => { this.isAnchorHoveredFocused || (this.delay > 1 ? null === this.showDelayTimer && (this.showDelayTimer = window.setTimeout(() => { this.startHover() }, this.delay)) : this.startHover()) }, this.startHover = () => { this.isAnchorHoveredFocused = !0, this.updateTooltipVisibility() }, this.clearShowDelayTimer = () => { null !== this.showDelayTimer && (clearTimeout(this.showDelayTimer), this.showDelayTimer = null) }, this.getAnchor = () => { const t = this.getRootNode(); return t instanceof ShadowRoot ? t.getElementById(this.anchor) : document.getElementById(this.anchor) }, this.handleDocumentKeydown = t => { if (!t.defaultPrevented && this.tooltipVisible) switch (t.key) { case "Escape": this.isAnchorHoveredFocused = !1, this.updateTooltipVisibility(), this.$emit("dismiss") } }, this.updateTooltipVisibility = () => { if (!1 === this.visible) this.hideTooltip(); else { if (!0 === this.visible) return void this.showTooltip(); if (this.isAnchorHoveredFocused || this.isRegionHovered) return void this.showTooltip(); this.hideTooltip() } }, this.showTooltip = () => { this.tooltipVisible || (this.currentDirection = ti(this), this.tooltipVisible = !0, document.addEventListener("keydown", this.handleDocumentKeydown), d.queueUpdate(this.setRegionProps)) }, this.hideTooltip = () => { this.tooltipVisible && (this.clearHideDelayTimer(), null !== this.region && void 0 !== this.region && (this.region.removeEventListener("positionchange", this.handlePositionChange), this.region.viewportElement = null, this.region.anchorElement = null, this.region.removeEventListener("mouseover", this.handleRegionMouseOver), this.region.removeEventListener("mouseout", this.handleRegionMouseOut)), document.removeEventListener("keydown", this.handleDocumentKeydown), this.tooltipVisible = !1) }, this.setRegionProps = () => { this.tooltipVisible && (this.region.viewportElement = this.viewportElement, this.region.anchorElement = this.anchorElement, this.region.addEventListener("positionchange", this.handlePositionChange), this.region.addEventListener("mouseover", this.handleRegionMouseOver, { passive: !0 }), this.region.addEventListener("mouseout", this.handleRegionMouseOut, { passive: !0 })) } } visibleChanged() { this.$fastController.isConnected && (this.updateTooltipVisibility(), this.updateLayout()) } anchorChanged() { this.$fastController.isConnected && (this.anchorElement = this.getAnchor()) } positionChanged() { this.$fastController.isConnected && this.updateLayout() } anchorElementChanged(t) { if (this.$fastController.isConnected) { if (null != t && (t.removeEventListener("mouseover", this.handleAnchorMouseOver), t.removeEventListener("mouseout", this.handleAnchorMouseOut), t.removeEventListener("focusin", this.handleAnchorFocusIn), t.removeEventListener("focusout", this.handleAnchorFocusOut)), null !== this.anchorElement && void 0 !== this.anchorElement) { this.anchorElement.addEventListener("mouseover", this.handleAnchorMouseOver, { passive: !0 }), this.anchorElement.addEventListener("mouseout", this.handleAnchorMouseOut, { passive: !0 }), this.anchorElement.addEventListener("focusin", this.handleAnchorFocusIn, { passive: !0 }), this.anchorElement.addEventListener("focusout", this.handleAnchorFocusOut, { passive: !0 }); const t = this.anchorElement.id; null !== this.anchorElement.parentElement && this.anchorElement.parentElement.querySelectorAll(":hover").forEach(e => { e.id === t && this.startShowDelayTimer() }) } null !== this.region && void 0 !== this.region && this.tooltipVisible && (this.region.anchorElement = this.anchorElement), this.updateLayout() } } viewportElementChanged() { null !== this.region && void 0 !== this.region && (this.region.viewportElement = this.viewportElement), this.updateLayout() } connectedCallback() { super.connectedCallback(), this.anchorElement = this.getAnchor(), this.updateTooltipVisibility() } disconnectedCallback() { this.hideTooltip(), this.clearShowDelayTimer(), this.clearHideDelayTimer(), super.disconnectedCallback() } updateLayout() { switch (this.verticalPositioningMode = "locktodefault", this.horizontalPositioningMode = "locktodefault", this.position) { case Hs: case Bs: this.verticalDefaultPosition = this.position, this.horizontalDefaultPosition = "center"; break; case Ms: case Ns: case js: case Us: this.verticalDefaultPosition = "center", this.horizontalDefaultPosition = this.position; break; case qs: this.verticalDefaultPosition = "top", this.horizontalDefaultPosition = "left"; break; case _s: this.verticalDefaultPosition = "top", this.horizontalDefaultPosition = "right"; break; case Gs: this.verticalDefaultPosition = "bottom", this.horizontalDefaultPosition = "left"; break; case Ws: this.verticalDefaultPosition = "bottom", this.horizontalDefaultPosition = "right"; break; case Ks: this.verticalDefaultPosition = "top", this.horizontalDefaultPosition = "start"; break; case Xs: this.verticalDefaultPosition = "top", this.horizontalDefaultPosition = "end"; break; case Ys: this.verticalDefaultPosition = "bottom", this.horizontalDefaultPosition = "start"; break; case Qs: this.verticalDefaultPosition = "bottom", this.horizontalDefaultPosition = "end"; break; default: this.verticalPositioningMode = "dynamic", this.horizontalPositioningMode = "dynamic", this.verticalDefaultPosition = void 0, this.horizontalDefaultPosition = "center" } } } Gt([it({ mode: "boolean" })], Zs.prototype, "visible", void 0), Gt([it], Zs.prototype, "anchor", void 0), Gt([it], Zs.prototype, "delay", void 0), Gt([it], Zs.prototype, "position", void 0), Gt([it({ attribute: "auto-update-mode" })], Zs.prototype, "autoUpdateMode", void 0), Gt([it({ attribute: "horizontal-viewport-lock" })], Zs.prototype, "horizontalViewportLock", void 0), Gt([it({ attribute: "vertical-viewport-lock" })], Zs.prototype, "verticalViewportLock", void 0), Gt([f], Zs.prototype, "anchorElement", void 0), Gt([f], Zs.prototype, "viewportElement", void 0), Gt([f], Zs.prototype, "verticalPositioningMode", void 0), Gt([f], Zs.prototype, "horizontalPositioningMode", void 0), Gt([f], Zs.prototype, "horizontalInset", void 0), Gt([f], Zs.prototype, "verticalInset", void 0), Gt([f], Zs.prototype, "horizontalScaling", void 0), Gt([f], Zs.prototype, "verticalScaling", void 0), Gt([f], Zs.prototype, "verticalDefaultPosition", void 0), Gt([f], Zs.prototype, "horizontalDefaultPosition", void 0), Gt([f], Zs.prototype, "tooltipVisible", void 0), Gt([f], Zs.prototype, "currentDirection", void 0); function Js(t) { return Pe(t) && "treeitem" === t.getAttribute("role") } class tn extends Se { constructor() { super(...arguments), this.expanded = !1, this.focusable = !1, this.isNestedItem = () => Js(this.parentElement), this.handleExpandCollapseButtonClick = t => { this.disabled || t.defaultPrevented || (this.expanded = !this.expanded) }, this.handleFocus = t => { this.setAttribute("tabindex", "0") }, this.handleBlur = t => { this.setAttribute("tabindex", "-1") } } expandedChanged() { this.$fastController.isConnected && this.$emit("expanded-change", this) } selectedChanged() { this.$fastController.isConnected && this.$emit("selected-change", this) } itemsChanged(t, e) { this.$fastController.isConnected && this.items.forEach(t => { Js(t) && (t.nested = !0) }) } static focusItem(t) { t.focusable = !0, t.focus() } childItemLength() { const t = this.childItems.filter(t => Js(t)); return t ? t.length : 0 } } Gt([it({ mode: "boolean" })], tn.prototype, "expanded", void 0), Gt([it({ mode: "boolean" })], tn.prototype, "selected", void 0), Gt([it({ mode: "boolean" })], tn.prototype, "disabled", void 0), Gt([f], tn.prototype, "focusable", void 0), Gt([f], tn.prototype, "childItems", void 0), Gt([f], tn.prototype, "items", void 0), Gt([f], tn.prototype, "nested", void 0), Gt([f], tn.prototype, "renderCollapsedChildren", void 0), Ve(tn, Nt); class en extends Se { constructor() { super(...arguments), this.currentFocused = null, this.handleFocus = t => { if (!(this.slottedTreeItems.length < 1)) return t.target === this ? (null === this.currentFocused && (this.currentFocused = this.getValidFocusableItem()), void (null !== this.currentFocused && tn.focusItem(this.currentFocused))) : void (this.contains(t.target) && (this.setAttribute("tabindex", "-1"), this.currentFocused = t.target)) }, this.handleBlur = t => { t.target instanceof HTMLElement && (null === t.relatedTarget || !this.contains(t.relatedTarget)) && this.setAttribute("tabindex", "0") }, this.handleKeyDown = t => { if (t.defaultPrevented) return; if (this.slottedTreeItems.length < 1) return !0; const e = this.getVisibleNodes(); switch (t.key) { case "Home": return void (e.length && tn.focusItem(e[0])); case "End": return void (e.length && tn.focusItem(e[e.length - 1])); case "ArrowLeft": if (t.target && this.isFocusableElement(t.target)) { const e = t.target; e instanceof tn && e.childItemLength() > 0 && e.expanded ? e.expanded = !1 : e instanceof tn && e.parentElement instanceof tn && tn.focusItem(e.parentElement) } return !1; case "ArrowRight": if (t.target && this.isFocusableElement(t.target)) { const e = t.target; e instanceof tn && e.childItemLength() > 0 && !e.expanded ? e.expanded = !0 : e instanceof tn && e.childItemLength() > 0 && this.focusNextNode(1, t.target) } return; case "ArrowDown": return void (t.target && this.isFocusableElement(t.target) && this.focusNextNode(1, t.target)); case "ArrowUp": return void (t.target && this.isFocusableElement(t.target) && this.focusNextNode(-1, t.target)); case "Enter": return void this.handleClick(t) }return !0 }, this.handleSelectedChange = t => { if (t.defaultPrevented) return; if (!(t.target instanceof Element && Js(t.target))) return !0; const e = t.target; e.selected ? (this.currentSelected && this.currentSelected !== e && (this.currentSelected.selected = !1), this.currentSelected = e) : e.selected || this.currentSelected !== e || (this.currentSelected = null) }, this.setItems = () => { const t = this.treeView.querySelector("[aria-selected='true']"); this.currentSelected = t, null !== this.currentFocused && this.contains(this.currentFocused) || (this.currentFocused = this.getValidFocusableItem()), this.nested = this.checkForNestedItems(); this.getVisibleNodes().forEach(t => { Js(t) && (t.nested = this.nested) }) }, this.isFocusableElement = t => Js(t), this.isSelectedElement = t => t.selected } slottedTreeItemsChanged() { this.$fastController.isConnected && this.setItems() } connectedCallback() { super.connectedCallback(), this.setAttribute("tabindex", "0"), d.queueUpdate(() => { this.setItems() }) } handleClick(t) { if (t.defaultPrevented) return; if (!(t.target instanceof Element && Js(t.target))) return !0; const e = t.target; e.disabled || (e.selected = !e.selected) } focusNextNode(t, e) { const i = this.getVisibleNodes(); if (!i) return; const o = i[i.indexOf(e) + t]; Pe(o) && tn.focusItem(o) } getValidFocusableItem() { const t = this.getVisibleNodes(); let e = t.findIndex(this.isSelectedElement); return -1 === e && (e = t.findIndex(this.isFocusableElement)), -1 !== e ? t[e] : null } checkForNestedItems() { return this.slottedTreeItems.some(t => Js(t) && t.querySelector("[role='treeitem']")) } getVisibleNodes() { return function (t, e) { if (!t || !e || !Pe(t)) return; return Array.from(t.querySelectorAll(e)).filter(t => null !== t.offsetParent) }(this, "[role='treeitem']") || [] } } Gt([it({ attribute: "render-collapsed-nodes" })], en.prototype, "renderCollapsedNodes", void 0), Gt([f], en.prototype, "currentSelected", void 0), Gt([f], en.prototype, "slottedTreeItems", void 0); class on extends class { constructor(t) { this.listenerCache = new WeakMap, this.query = t } bind(t) { const { query: e } = this, i = this.constructListener(t); i.bind(e)(), e.addListener(i), this.listenerCache.set(t, i) } unbind(t) { const e = this.listenerCache.get(t); e && (this.query.removeListener(e), this.listenerCache.delete(t)) } }{ constructor(t, e) { super(t), this.styles = e } static with(t) { return e => new on(t, e) } constructListener(t) { let e = !1; const i = this.styles; return function () { const { matches: o } = this; o && !e ? (t.$fastController.addStyles(i), e = o) : !o && e && (t.$fastController.removeStyles(i), e = o) } } unbind(t) { super.unbind(t), t.$fastController.removeStyles(this.styles) } } const sn = on.with(window.matchMedia("(forced-colors)")); on.with(window.matchMedia("(prefers-color-scheme: dark)")), on.with(window.matchMedia("(prefers-color-scheme: light)")); class nn { constructor(t, e, i) { this.propertyName = t, this.value = e, this.styles = i } bind(t) { g.getNotifier(t).subscribe(this, this.propertyName), this.handleChange(t, this.propertyName) } unbind(t) { g.getNotifier(t).unsubscribe(this, this.propertyName), t.$fastController.removeStyles(this.styles) } handleChange(t, e) { t[e] === this.value ? t.$fastController.addStyles(this.styles) : t.$fastController.removeStyles(this.styles) } } function rn(t) { return `:host([hidden]){display:none}:host{display:${t}}` } const an = function () { if ("boolean" == typeof ze) return ze; if ("undefined" == typeof window || !window.document || !window.document.createElement) return ze = !1, ze; const t = document.createElement("style"), e = function () { const t = document.querySelector('meta[property="csp-nonce"]'); return t ? t.getAttribute("content") : null }(); null !== e && t.setAttribute("nonce", e), document.head.appendChild(t); try { t.sheet.insertRule("foo:focus-visible {color:inherit}", 0), ze = !0 } catch (t) { ze = !1 } finally { document.head.removeChild(t) } return ze }() ? "focus-visible" : "focus"; function ln(t, e, i) { return isNaN(t) || t <= e ? e : t >= i ? i : t } function cn(t, e, i) { return isNaN(t) || t <= e ? 0 : t >= i ? 1 : t / (i - e) } function hn(t, e, i) { return isNaN(t) ? e : e + t * (i - e) } function dn(t, e, i) { return isNaN(t) || t <= 0 ? e : t >= 1 ? i : e + t * (i - e) } function un(t, e) { const i = Math.pow(10, e); return Math.round(t * i) / i } class pn { constructor(t, e, i) { this.h = t, this.s = e, this.l = i } static fromObject(t) { return !t || isNaN(t.h) || isNaN(t.s) || isNaN(t.l) ? null : new pn(t.h, t.s, t.l) } equalValue(t) { return this.h === t.h && this.s === t.s && this.l === t.l } roundToPrecision(t) { return new pn(un(this.h, t), un(this.s, t), un(this.l, t)) } toObject() { return { h: this.h, s: this.s, l: this.l } } } class gn { constructor(t, e, i) { this.l = t, this.a = e, this.b = i } static fromObject(t) { return !t || isNaN(t.l) || isNaN(t.a) || isNaN(t.b) ? null : new gn(t.l, t.a, t.b) } equalValue(t) { return this.l === t.l && this.a === t.a && this.b === t.b } roundToPrecision(t) { return new gn(un(this.l, t), un(this.a, t), un(this.b, t)) } toObject() { return { l: this.l, a: this.a, b: this.b } } } gn.epsilon = 216 / 24389, gn.kappa = 24389 / 27; class fn { constructor(t, e, i, o) { this.r = t, this.g = e, this.b = i, this.a = "number" != typeof o || isNaN(o) ? 1 : o } static fromObject(t) { return !t || isNaN(t.r) || isNaN(t.g) || isNaN(t.b) ? null : new fn(t.r, t.g, t.b, t.a) } equalValue(t) { return this.r === t.r && this.g === t.g && this.b === t.b && this.a === t.a } toStringHexRGB() { return "#" + [this.r, this.g, this.b].map(this.formatHexValue).join("") } toStringHexRGBA() { return this.toStringHexRGB() + this.formatHexValue(this.a) } toStringHexARGB() { return "#" + [this.a, this.r, this.g, this.b].map(this.formatHexValue).join("") } toStringWebRGB() { return `rgb(${Math.round(hn(this.r, 0, 255))},${Math.round(hn(this.g, 0, 255))},${Math.round(hn(this.b, 0, 255))})` } toStringWebRGBA() { return `rgba(${Math.round(hn(this.r, 0, 255))},${Math.round(hn(this.g, 0, 255))},${Math.round(hn(this.b, 0, 255))},${ln(this.a, 0, 1)})` } roundToPrecision(t) { return new fn(un(this.r, t), un(this.g, t), un(this.b, t), un(this.a, t)) } clamp() { return new fn(ln(this.r, 0, 1), ln(this.g, 0, 1), ln(this.b, 0, 1), ln(this.a, 0, 1)) } toObject() { return { r: this.r, g: this.g, b: this.b, a: this.a } } formatHexValue(t) { return function (t) { const e = Math.round(ln(t, 0, 255)).toString(16); return 1 === e.length ? "0" + e : e }(hn(t, 0, 255)) } } class mn { constructor(t, e, i) { this.x = t, this.y = e, this.z = i } static fromObject(t) { return !t || isNaN(t.x) || isNaN(t.y) || isNaN(t.z) ? null : new mn(t.x, t.y, t.z) } equalValue(t) { return this.x === t.x && this.y === t.y && this.z === t.z } roundToPrecision(t) { return new mn(un(this.x, t), un(this.y, t), un(this.z, t)) } toObject() { return { x: this.x, y: this.y, z: this.z } } } function vn(t) { function e(t) { return t <= .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4) } return function (t) { return .2126 * t.r + .7152 * t.g + .0722 * t.b }(new fn(e(t.r), e(t.g), e(t.b), 1)) } function bn(t, e, i) { return i - e == 0 ? 0 : (t - e) / (i - e) } function yn(t, e, i) { return (bn(t.r, e.r, i.r) + bn(t.g, e.g, i.g) + bn(t.b, e.b, i.b)) / 3 } function xn(t) { const e = Math.max(t.r, t.g, t.b), i = Math.min(t.r, t.g, t.b), o = e - i; let s = 0; 0 !== o && (s = e === t.r ? (t.g - t.b) / o % 6 * 60 : e === t.g ? 60 * ((t.b - t.r) / o + 2) : 60 * ((t.r - t.g) / o + 4)), s < 0 && (s += 360); const n = (e + i) / 2; let r = 0; return 0 !== o && (r = o / (1 - Math.abs(2 * n - 1))), new pn(s, r, n) } function $n(t) { return function (t) { function e(t) { return t > gn.epsilon ? Math.pow(t, 1 / 3) : (gn.kappa * t + 16) / 116 } const i = e(t.x / mn.whitePoint.x), o = e(t.y / mn.whitePoint.y), s = e(t.z / mn.whitePoint.z); return new gn(116 * o - 16, 500 * (i - o), 200 * (o - s)) }(function (t) { function e(t) { return t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4) } const i = e(t.r), o = e(t.g), s = e(t.b); return new mn(.4124564 * i + .3575761 * o + .1804375 * s, .2126729 * i + .7151522 * o + .072175 * s, .0193339 * i + .119192 * o + .9503041 * s) }(t)) } function wn(t, e = 1) { return function (t, e = 1) { function i(t) { return t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055 } const o = i(3.2404542 * t.x - 1.5371385 * t.y - .4985314 * t.z), s = i(-.969266 * t.x + 1.8760108 * t.y + .041556 * t.z), n = i(.0556434 * t.x - .2040259 * t.y + 1.0572252 * t.z); return new fn(o, s, n, e) }(function (t) { const e = (t.l + 16) / 116, i = e + t.a / 500, o = e - t.b / 200, s = Math.pow(i, 3), n = Math.pow(e, 3), r = Math.pow(o, 3); let a = 0; a = s > gn.epsilon ? s : (116 * i - 16) / gn.kappa; let l = 0; l = t.l > gn.epsilon * gn.kappa ? n : t.l / gn.kappa; let c = 0; return c = r > gn.epsilon ? r : (116 * o - 16) / gn.kappa, a = mn.whitePoint.x * a, l = mn.whitePoint.y * l, c = mn.whitePoint.z * c, new mn(a, l, c) }(t), e) } var kn, Cn; function In(t, e, i) { return isNaN(t) || t <= 0 ? e : t >= 1 ? i : new fn(dn(t, e.r, i.r), dn(t, e.g, i.g), dn(t, e.b, i.b), dn(t, e.a, i.a)) } mn.whitePoint = new mn(.95047, 1, 1.08883), function (t) { t[t.Burn = 0] = "Burn", t[t.Color = 1] = "Color", t[t.Darken = 2] = "Darken", t[t.Dodge = 3] = "Dodge", t[t.Lighten = 4] = "Lighten", t[t.Multiply = 5] = "Multiply", t[t.Overlay = 6] = "Overlay", t[t.Screen = 7] = "Screen" }(kn || (kn = {})), function (t) { t[t.RGB = 0] = "RGB", t[t.HSL = 1] = "HSL", t[t.HSV = 2] = "HSV", t[t.XYZ = 3] = "XYZ", t[t.LAB = 4] = "LAB", t[t.LCH = 5] = "LCH" }(Cn || (Cn = {})); const Fn = /^#((?:[0-9a-f]{6}|[0-9a-f]{3}))$/i; function Dn(t) { const e = Fn.exec(t); if (null === e) return null; let i = e[1]; if (3 === i.length) { const t = i.charAt(0), e = i.charAt(1), o = i.charAt(2); i = t.concat(t, e, e, o, o) } const o = parseInt(i, 16); return isNaN(o) ? null : new fn(cn((16711680 & o) >>> 16, 0, 255), cn((65280 & o) >>> 8, 0, 255), cn(255 & o, 0, 255), 1) } function Tn(t, e) { const i = t.relativeLuminance > e.relativeLuminance ? t : e, o = t.relativeLuminance > e.relativeLuminance ? e : t; return (i.relativeLuminance + .05) / (o.relativeLuminance + .05) } const Sn = Object.freeze({ create: (t, e, i) => new On(t, e, i), from: t => new On(t.r, t.g, t.b) }); class On extends fn { constructor(t, e, i) { super(t, e, i, 1), this.toColorString = this.toStringHexRGB, this.contrast = Tn.bind(null, this), this.createCSS = this.toColorString, this.relativeLuminance = vn(this) } static fromObject(t) { return new On(t.r, t.g, t.b) } } const En = (-.1 + Math.sqrt(.21)) / 2; function Vn(t) { return t.relativeLuminance <= En } function Rn(t) { return Vn(t) ? -1 : 1 } const An = { stepContrast: 1.03, stepContrastRamp: .03, preserveSource: !1 }; const Ln = Object.freeze({ create: function (t, e, i) { return "number" == typeof t ? Ln.from(Sn.create(t, e, i)) : Ln.from(t) }, from: function (t, e) { return function (t) { const e = { r: 0, g: 0, b: 0, toColorString: () => "", contrast: () => 0, relativeLuminance: 0 }; for (const i in e) if (typeof e[i] != typeof t[i]) return !1; return !0 }(t) ? Pn.from(t, e) : Pn.from(Sn.create(t.r, t.g, t.b), e) } }); class Pn { constructor(t, e) { this.closestIndexCache = new Map, this.source = t, this.swatches = e, this.reversedSwatches = Object.freeze([...this.swatches].reverse()), this.lastIndex = this.swatches.length - 1 } colorContrast(t, e, i, o) { void 0 === i && (i = this.closestIndexOf(t)); let s = this.swatches; const n = this.lastIndex; let r = i; void 0 === o && (o = Rn(t)); return -1 === o && (s = this.reversedSwatches, r = n - r), function t(e, i, o = 0, s = e.length - 1) { if (s === o) return e[o]; const n = Math.floor((s - o) / 2) + o; return i(e[n]) ? t(e, i, o, n) : t(e, i, n + 1, s) }(s, i => Tn(t, i) >= e, r, n) } get(t) { return this.swatches[t] || this.swatches[ln(t, 0, this.lastIndex)] } closestIndexOf(t) { if (this.closestIndexCache.has(t.relativeLuminance)) return this.closestIndexCache.get(t.relativeLuminance); let e = this.swatches.indexOf(t); if (-1 !== e) return this.closestIndexCache.set(t.relativeLuminance, e), e; const i = this.swatches.reduce((e, i) => Math.abs(i.relativeLuminance - t.relativeLuminance) < Math.abs(e.relativeLuminance - t.relativeLuminance) ? i : e); return e = this.swatches.indexOf(i), this.closestIndexCache.set(t.relativeLuminance, e), e } static saturationBump(t, e) { const i = xn(t).s, o = xn(e); if (o.s < i) { return function (t, e = 1) { const i = (1 - Math.abs(2 * t.l - 1)) * t.s, o = i * (1 - Math.abs(t.h / 60 % 2 - 1)), s = t.l - i / 2; let n = 0, r = 0, a = 0; return t.h < 60 ? (n = i, r = o, a = 0) : t.h < 120 ? (n = o, r = i, a = 0) : t.h < 180 ? (n = 0, r = i, a = o) : t.h < 240 ? (n = 0, r = o, a = i) : t.h < 300 ? (n = o, r = 0, a = i) : t.h < 360 && (n = i, r = 0, a = o), new fn(n + s, r + s, a + s, e) }(new pn(o.h, i, o.l)) } return e } static ramp(t) { const e = t / 100; return e > .5 ? (e - .5) / .5 : 2 * e } static createHighResolutionPalette(t) { const e = [], i = $n(fn.fromObject(t).roundToPrecision(4)), o = wn(new gn(0, i.a, i.b)).clamp().roundToPrecision(4), s = wn(new gn(50, i.a, i.b)).clamp().roundToPrecision(4), n = wn(new gn(100, i.a, i.b)).clamp().roundToPrecision(4), r = new fn(0, 0, 0), a = new fn(1, 1, 1), l = n.equalValue(a) ? 0 : 14, c = o.equalValue(r) ? 0 : 14; for (let t = 100 + l; t >= 0 - c; t -= .5) { let i; if (t < 0) { i = In(t / c + 1, r, o) } else if (t <= 50) i = In(Pn.ramp(t), o, s); else if (t <= 100) i = In(Pn.ramp(t), s, n); else { i = In((t - 100) / l, n, a) } i = Pn.saturationBump(s, i).roundToPrecision(4), e.push(Sn.from(i)) } return new Pn(t, e) } static adjustEnd(t, e, i, o) { const s = -1 === o ? e.swatches : e.reversedSwatches, n = t => { const i = e.closestIndexOf(t); return 1 === o ? e.lastIndex - i : i }; 1 === o && i.reverse(); const r = t(i[i.length - 2]); if (un(Tn(i[i.length - 1], i[i.length - 2]), 2) < r) { i.pop(); const t = n(e.colorContrast(s[e.lastIndex], r, void 0, o)) - n(i[i.length - 2]); let a = 1; for (let o = i.length - t - 1; o < i.length; o++) { const t = n(i[o]), r = o === i.length - 1 ? e.lastIndex : t + a; i[o] = s[r], a++ } } 1 === o && i.reverse() } static createColorPaletteByContrast(t, e) { const i = Pn.createHighResolutionPalette(t), o = t => un(e.stepContrast + e.stepContrast * (1 - t.relativeLuminance) * e.stepContrastRamp, 2), s = []; let n = e.preserveSource ? t : i.swatches[0]; s.push(n); do { const t = o(n); n = i.colorContrast(n, t, void 0, 1), s.push(n) } while (n.relativeLuminance > 0); if (e.preserveSource) { n = t; do { const t = o(n); n = i.colorContrast(n, t, void 0, -1), s.unshift(n) } while (n.relativeLuminance < 1) } return this.adjustEnd(o, i, s, -1), e.preserveSource && this.adjustEnd(o, i, s, 1), s } static from(t, e) { const i = void 0 === e ? An : Object.assign(Object.assign({}, An), e); return new Pn(t, Object.freeze(Pn.createColorPaletteByContrast(t, i))) } } const zn = Sn.create(1, 1, 1), Hn = Sn.create(0, 0, 0), Mn = Sn.create(.5, .5, .5), Bn = Dn("#0078D4"), Nn = Sn.create(Bn.r, Bn.g, Bn.b); function jn(t, e, i, o, s) { const n = t => t.contrast(zn) >= s ? zn : Hn, r = n(t), a = n(e); return { rest: r, hover: a, active: r.relativeLuminance === a.relativeLuminance ? r : n(i), focus: n(o) } } class Un { constructor(t, e, i, o) { this.toColorString = () => this.cssGradient, this.contrast = Tn.bind(null, this), this.createCSS = this.toColorString, this.color = new fn(t, e, i), this.cssGradient = o, this.relativeLuminance = vn(this.color), this.r = t, this.g = e, this.b = i } static fromObject(t, e) { return new Un(t.r, t.g, t.b, e) } } const qn = new fn(0, 0, 0), _n = new fn(1, 1, 1); function Gn(t, e, i, o, s, n, r, a, l = 10, c = !1) { const h = t.closestIndexOf(e); function d(i) { if (c) { const o = t.closestIndexOf(e), s = t.get(o), n = i.relativeLuminance < e.relativeLuminance ? qn : _n, r = function (t, e, i = null) { let o = 0, s = i; return null !== s ? o = yn(t, e, s) : (s = new fn(0, 0, 0, 1), o = yn(t, e, s), o <= 0 && (s = new fn(1, 1, 1, 1), o = yn(t, e, s))), o = Math.round(1e3 * o) / 1e3, new fn(s.r, s.g, s.b, o) }(Dn(i.toColorString()), Dn(s.toColorString()), n).roundToPrecision(2), a = function (t, e) { if (e.a >= 1) return e; if (e.a <= 0) return new fn(t.r, t.g, t.b, 1); const i = e.a * e.r + (1 - e.a) * t.r, o = e.a * e.g + (1 - e.a) * t.g, s = e.a * e.b + (1 - e.a) * t.b; return new fn(i, o, s, 1) }(Dn(e.toColorString()), r); return Sn.from(a) } return i } void 0 === a && (a = Rn(e)); const u = h + a * i, p = u + a * (o - i), g = u + a * (s - i), f = u + a * (n - i), m = -1 === a ? 0 : 100 - l, v = -1 === a ? l : 100; function b(e, i) { const o = t.get(e); if (i) { const i = t.get(e + a * r), s = -1 === a ? i : o, n = -1 === a ? o : i, l = `linear-gradient(${d(s).toColorString()} ${m}%, ${d(n).toColorString()} ${v}%)`; return Un.fromObject(s, l) } return d(o) } return { rest: b(u, !0), hover: b(p, !0), active: b(g, !1), focus: b(f, !0) } } function Wn(t, e, i, o, s, n, r, a) { null == a && (a = Rn(e)); const l = t.closestIndexOf(t.colorContrast(e, i)); return { rest: t.get(l + a * o), hover: t.get(l + a * s), active: t.get(l + a * n), focus: t.get(l + a * r) } } function Kn(t, e, i, o, s, n, r) { const a = t.closestIndexOf(e); return null == r && (r = Rn(e)), { rest: t.get(a + r * i), hover: t.get(a + r * o), active: t.get(a + r * s), focus: t.get(a + r * n) } } function Xn(t, e, i, o, s, n, r, a, l, c, h, d) { return Vn(e) ? Kn(t, e, a, l, c, h, d) : Kn(t, e, i, o, s, n, r) } var Yn; function Qn(t, e) { return t.closestIndexOf((i = e, Sn.create(i, i, i))); var i } function Zn(t, e, i) { return t.get(Qn(t, e) + -1 * i) } !function (t) { t[t.LightMode = .98] = "LightMode", t[t.DarkMode = .15] = "DarkMode" }(Yn || (Yn = {})); const { create: Jn } = fo; function tr(t) { return fo.create({ name: t, cssCustomPropertyName: null }) } const er = Jn("direction").withDefault(Be.ltr), ir = Jn("disabled-opacity").withDefault(.3), or = Jn("base-height-multiplier").withDefault(8), sr = Jn("base-horizontal-spacing-multiplier").withDefault(3), nr = Jn("density").withDefault(0), rr = Jn("design-unit").withDefault(4), ar = Jn("control-corner-radius").withDefault(4), lr = Jn("layer-corner-radius").withDefault(8), cr = Jn("stroke-width").withDefault(1), hr = Jn("focus-stroke-width").withDefault(2), dr = Jn("body-font").withDefault('"Segoe UI Variable", "Segoe UI", sans-serif'), ur = Jn("font-weight").withDefault(400); function pr(t) { return e => { const i = t.getValueFor(e), o = ur.getValueFor(e); if (i.endsWith("px")) { const t = Number.parseFloat(i.replace("px", "")); if (t <= 12) return `"wght" ${o}, "opsz" 8`; if (t > 24) return `"wght" ${o}, "opsz" 36` } return `"wght" ${o}, "opsz" 10.5` } } const gr = Jn("type-ramp-base-font-size").withDefault("14px"), fr = Jn("type-ramp-base-line-height").withDefault("20px"), mr = Jn("type-ramp-base-font-variations").withDefault(pr(gr)), vr = Jn("type-ramp-minus-1-font-size").withDefault("12px"), br = Jn("type-ramp-minus-1-line-height").withDefault("16px"), yr = Jn("type-ramp-minus-1-font-variations").withDefault(pr(vr)), xr = Jn("type-ramp-minus-2-font-size").withDefault("10px"), $r = Jn("type-ramp-minus-2-line-height").withDefault("14px"), wr = Jn("type-ramp-minus-2-font-variations").withDefault(pr(xr)), kr = Jn("type-ramp-plus-1-font-size").withDefault("16px"), Cr = Jn("type-ramp-plus-1-line-height").withDefault("22px"), Ir = Jn("type-ramp-plus-1-font-variations").withDefault(pr(kr)), Fr = Jn("type-ramp-plus-2-font-size").withDefault("20px"), Dr = Jn("type-ramp-plus-2-line-height").withDefault("26px"), Tr = Jn("type-ramp-plus-2-font-variations").withDefault(pr(Fr)), Sr = Jn("type-ramp-plus-3-font-size").withDefault("24px"), Or = Jn("type-ramp-plus-3-line-height").withDefault("32px"), Er = Jn("type-ramp-plus-3-font-variations").withDefault(pr(Sr)), Vr = Jn("type-ramp-plus-4-font-size").withDefault("28px"), Rr = Jn("type-ramp-plus-4-line-height").withDefault("36px"), Ar = Jn("type-ramp-plus-4-font-variations").withDefault(pr(Vr)), Lr = Jn("type-ramp-plus-5-font-size").withDefault("32px"), Pr = Jn("type-ramp-plus-5-line-height").withDefault("40px"), zr = Jn("type-ramp-plus-5-font-variations").withDefault(pr(Lr)), Hr = Jn("type-ramp-plus-6-font-size").withDefault("40px"), Mr = Jn("type-ramp-plus-6-line-height").withDefault("52px"), Br = Jn("type-ramp-plus-6-font-variations").withDefault(pr(Hr)), Nr = Jn("base-layer-luminance").withDefault(Yn.LightMode), jr = tr("accent-fill-rest-delta").withDefault(0), Ur = tr("accent-fill-hover-delta").withDefault(-2), qr = tr("accent-fill-active-delta").withDefault(-5), _r = tr("accent-fill-focus-delta").withDefault(0), Gr = tr("accent-foreground-rest-delta").withDefault(0), Wr = tr("accent-foreground-hover-delta").withDefault(3), Kr = tr("accent-foreground-active-delta").withDefault(-8), Xr = tr("accent-foreground-focus-delta").withDefault(0), Yr = tr("neutral-fill-rest-delta").withDefault(-1), Qr = tr("neutral-fill-hover-delta").withDefault(1), Zr = tr("neutral-fill-active-delta").withDefault(0), Jr = tr("neutral-fill-focus-delta").withDefault(0), ta = tr("neutral-fill-input-rest-delta").withDefault(-1), ea = tr("neutral-fill-input-hover-delta").withDefault(1), ia = tr("neutral-fill-input-active-delta").withDefault(0), oa = tr("neutral-fill-input-focus-delta").withDefault(-2), sa = tr("neutral-fill-input-alt-rest-delta").withDefault(2), na = tr("neutral-fill-input-alt-hover-delta").withDefault(4), ra = tr("neutral-fill-input-alt-active-delta").withDefault(6), aa = tr("neutral-fill-input-alt-focus-delta").withDefault(2), la = tr("neutral-fill-layer-rest-delta").withDefault(-2), ca = tr("neutral-fill-layer-hover-delta").withDefault(-3), ha = tr("neutral-fill-layer-active-delta").withDefault(-3), da = tr("neutral-fill-layer-alt-rest-delta").withDefault(-1), ua = tr("neutral-fill-secondary-rest-delta").withDefault(3), pa = tr("neutral-fill-secondary-hover-delta").withDefault(2), ga = tr("neutral-fill-secondary-active-delta").withDefault(1), fa = tr("neutral-fill-secondary-focus-delta").withDefault(3), ma = tr("neutral-fill-stealth-rest-delta").withDefault(0), va = tr("neutral-fill-stealth-hover-delta").withDefault(3), ba = tr("neutral-fill-stealth-active-delta").withDefault(2), ya = tr("neutral-fill-stealth-focus-delta").withDefault(0), xa = tr("neutral-fill-strong-rest-delta").withDefault(0), $a = tr("neutral-fill-strong-hover-delta").withDefault(8), wa = tr("neutral-fill-strong-active-delta").withDefault(-5), ka = tr("neutral-fill-strong-focus-delta").withDefault(0), Ca = tr("neutral-stroke-rest-delta").withDefault(8), Ia = tr("neutral-stroke-hover-delta").withDefault(12), Fa = tr("neutral-stroke-active-delta").withDefault(6), Da = tr("neutral-stroke-focus-delta").withDefault(8), Ta = tr("neutral-stroke-control-rest-delta").withDefault(3), Sa = tr("neutral-stroke-control-hover-delta").withDefault(5), Oa = tr("neutral-stroke-control-active-delta").withDefault(5), Ea = tr("neutral-stroke-control-focus-delta").withDefault(5), Va = tr("neutral-stroke-divider-rest-delta").withDefault(4), Ra = tr("neutral-stroke-layer-rest-delta").withDefault(3), Aa = tr("neutral-stroke-layer-hover-delta").withDefault(3), La = tr("neutral-stroke-layer-active-delta").withDefault(3), Pa = tr("neutral-stroke-strong-hover-delta").withDefault(0), za = tr("neutral-stroke-strong-active-delta").withDefault(0), Ha = tr("neutral-stroke-strong-focus-delta").withDefault(0), Ma = Jn("neutral-base-color").withDefault(Mn), Ba = tr("neutral-palette").withDefault(t => Ln.from(Ma.getValueFor(t))), Na = Jn("accent-base-color").withDefault(Nn), ja = tr("accent-palette").withDefault(t => Ln.from(Na.getValueFor(t))), Ua = tr("neutral-layer-card-container-recipe").withDefault({ evaluate: t => Zn(Ba.getValueFor(t), Nr.getValueFor(t), la.getValueFor(t)) }), qa = Jn("neutral-layer-card-container").withDefault(t => Ua.getValueFor(t).evaluate(t)), _a = tr("neutral-layer-floating-recipe").withDefault({ evaluate: t => function (t, e, i) { return t.get(Qn(t, e) + i) }(Ba.getValueFor(t), Nr.getValueFor(t), la.getValueFor(t)) }), Ga = Jn("neutral-layer-floating").withDefault(t => _a.getValueFor(t).evaluate(t)), Wa = tr("neutral-layer-1-recipe").withDefault({ evaluate: t => function (t, e) { return t.get(Qn(t, e)) }(Ba.getValueFor(t), Nr.getValueFor(t)) }), Ka = Jn("neutral-layer-1").withDefault(t => Wa.getValueFor(t).evaluate(t)), Xa = tr("neutral-layer-2-recipe").withDefault({ evaluate: t => Zn(Ba.getValueFor(t), Nr.getValueFor(t), la.getValueFor(t)) }), Ya = Jn("neutral-layer-2").withDefault(t => Xa.getValueFor(t).evaluate(t)), Qa = tr("neutral-layer-3-recipe").withDefault({ evaluate: t => function (t, e, i) { return t.get(Qn(t, e) + -1 * i * 2) }(Ba.getValueFor(t), Nr.getValueFor(t), la.getValueFor(t)) }), Za = Jn("neutral-layer-3").withDefault(t => Qa.getValueFor(t).evaluate(t)), Ja = tr("neutral-layer-4-recipe").withDefault({ evaluate: t => function (t, e, i) { return t.get(Qn(t, e) + -1 * i * 3) }(Ba.getValueFor(t), Nr.getValueFor(t), la.getValueFor(t)) }), tl = Jn("neutral-layer-4").withDefault(t => Ja.getValueFor(t).evaluate(t)), el = Jn("fill-color").withDefault(t => Ka.getValueFor(t)); var il; !function (t) { t[t.normal = 4.5] = "normal", t[t.large = 3] = "large" }(il || (il = {})); const ol = tr("accent-fill-recipe").withDefault({ evaluate: (t, e) => function (t, e, i, o, s, n, r, a, l, c, h, d, u, p) { return Vn(e) ? Wn(t, e, l, c, h, d, u, p) : Wn(t, e, i, o, s, n, r, a) }(ja.getValueFor(t), e || el.getValueFor(t), 5, jr.getValueFor(t), Ur.getValueFor(t), qr.getValueFor(t), _r.getValueFor(t), void 0, 8, jr.getValueFor(t), Ur.getValueFor(t), qr.getValueFor(t), _r.getValueFor(t), void 0) }), sl = Jn("accent-fill-rest").withDefault(t => ol.getValueFor(t).evaluate(t).rest), nl = Jn("accent-fill-hover").withDefault(t => ol.getValueFor(t).evaluate(t).hover), rl = Jn("accent-fill-active").withDefault(t => ol.getValueFor(t).evaluate(t).active), al = Jn("accent-fill-focus").withDefault(t => ol.getValueFor(t).evaluate(t).focus), ll = tr("foreground-on-accent-recipe").withDefault({ evaluate: t => jn(sl.getValueFor(t), nl.getValueFor(t), rl.getValueFor(t), al.getValueFor(t), il.normal) }), cl = Jn("foreground-on-accent-rest").withDefault(t => ll.getValueFor(t).evaluate(t).rest), hl = Jn("foreground-on-accent-hover").withDefault(t => ll.getValueFor(t).evaluate(t).hover), dl = Jn("foreground-on-accent-active").withDefault(t => ll.getValueFor(t).evaluate(t).active), ul = Jn("foreground-on-accent-focus").withDefault(t => ll.getValueFor(t).evaluate(t).focus), pl = tr("accent-foreground-recipe").withDefault({ evaluate: (t, e) => Wn(ja.getValueFor(t), e || el.getValueFor(t), 9.5, Gr.getValueFor(t), Wr.getValueFor(t), Kr.getValueFor(t), Xr.getValueFor(t)) }), gl = Jn("accent-foreground-rest").withDefault(t => pl.getValueFor(t).evaluate(t).rest), fl = Jn("accent-foreground-hover").withDefault(t => pl.getValueFor(t).evaluate(t).hover), ml = Jn("accent-foreground-active").withDefault(t => pl.getValueFor(t).evaluate(t).active), vl = Jn("accent-foreground-focus").withDefault(t => pl.getValueFor(t).evaluate(t).focus), bl = tr("accent-stroke-control-recipe").withDefault({ evaluate: (t, e) => Gn(Ba.getValueFor(t), e || el.getValueFor(t), -3, -3, -3, -3, 10, 1, void 0, !0) }), yl = Jn("accent-stroke-control-rest").withDefault(t => bl.getValueFor(t).evaluate(t, sl.getValueFor(t)).rest), xl = Jn("accent-stroke-control-hover").withDefault(t => bl.getValueFor(t).evaluate(t, nl.getValueFor(t)).hover), $l = Jn("accent-stroke-control-active").withDefault(t => bl.getValueFor(t).evaluate(t, rl.getValueFor(t)).active), wl = Jn("accent-stroke-control-focus").withDefault(t => bl.getValueFor(t).evaluate(t, al.getValueFor(t)).focus), kl = tr("neutral-fill-recipe").withDefault({ evaluate: (t, e) => Xn(Ba.getValueFor(t), e || el.getValueFor(t), Yr.getValueFor(t), Qr.getValueFor(t), Zr.getValueFor(t), Jr.getValueFor(t), void 0, 2, 3, 1, 2, void 0) }), Cl = Jn("neutral-fill-rest").withDefault(t => kl.getValueFor(t).evaluate(t).rest), Il = Jn("neutral-fill-hover").withDefault(t => kl.getValueFor(t).evaluate(t).hover), Fl = Jn("neutral-fill-active").withDefault(t => kl.getValueFor(t).evaluate(t).active), Dl = Jn("neutral-fill-focus").withDefault(t => kl.getValueFor(t).evaluate(t).focus), Tl = tr("neutral-fill-input-recipe").withDefault({ evaluate: (t, e) => Xn(Ba.getValueFor(t), e || el.getValueFor(t), ta.getValueFor(t), ea.getValueFor(t), ia.getValueFor(t), oa.getValueFor(t), void 0, 2, 3, 1, 0, void 0) }), Sl = Jn("neutral-fill-input-rest").withDefault(t => Tl.getValueFor(t).evaluate(t).rest), Ol = Jn("neutral-fill-input-hover").withDefault(t => Tl.getValueFor(t).evaluate(t).hover), El = Jn("neutral-fill-input-active").withDefault(t => Tl.getValueFor(t).evaluate(t).active), Vl = Jn("neutral-fill-input-focus").withDefault(t => Tl.getValueFor(t).evaluate(t).focus), Rl = tr("neutral-fill-input-alt-recipe").withDefault({ evaluate: (t, e) => Xn(Ba.getValueFor(t), e || el.getValueFor(t), sa.getValueFor(t), na.getValueFor(t), ra.getValueFor(t), aa.getValueFor(t), 1, sa.getValueFor(t), sa.getValueFor(t) - na.getValueFor(t), sa.getValueFor(t) - ra.getValueFor(t), aa.getValueFor(t), 1) }), Al = Jn("neutral-fill-input-alt-rest").withDefault(t => Rl.getValueFor(t).evaluate(t).rest), Ll = Jn("neutral-fill-input-alt-hover").withDefault(t => Rl.getValueFor(t).evaluate(t).hover), Pl = Jn("neutral-fill-input-alt-active").withDefault(t => Rl.getValueFor(t).evaluate(t).active), zl = Jn("neutral-fill-input-alt-focus").withDefault(t => Rl.getValueFor(t).evaluate(t).focus), Hl = tr("neutral-fill-layer-recipe").withDefault({ evaluate: (t, e) => Kn(Ba.getValueFor(t), e || el.getValueFor(t), la.getValueFor(t), ca.getValueFor(t), ha.getValueFor(t), la.getValueFor(t), 1) }), Ml = Jn("neutral-fill-layer-rest").withDefault(t => Hl.getValueFor(t).evaluate(t).rest), Bl = Jn("neutral-fill-layer-hover").withDefault(t => Hl.getValueFor(t).evaluate(t).hover), Nl = Jn("neutral-fill-layer-active").withDefault(t => Hl.getValueFor(t).evaluate(t).active), jl = tr("neutral-fill-layer-alt-recipe").withDefault({ evaluate: (t, e) => Kn(Ba.getValueFor(t), e || el.getValueFor(t), da.getValueFor(t), da.getValueFor(t), da.getValueFor(t), da.getValueFor(t)) }), Ul = Jn("neutral-fill-layer-alt-rest").withDefault(t => jl.getValueFor(t).evaluate(t).rest), ql = tr("neutral-fill-secondary-recipe").withDefault({ evaluate: (t, e) => Kn(Ba.getValueFor(t), e || el.getValueFor(t), ua.getValueFor(t), pa.getValueFor(t), ga.getValueFor(t), fa.getValueFor(t)) }), _l = Jn("neutral-fill-secondary-rest").withDefault(t => ql.getValueFor(t).evaluate(t).rest), Gl = Jn("neutral-fill-secondary-hover").withDefault(t => ql.getValueFor(t).evaluate(t).hover), Wl = Jn("neutral-fill-secondary-active").withDefault(t => ql.getValueFor(t).evaluate(t).active), Kl = Jn("neutral-fill-secondary-focus").withDefault(t => ql.getValueFor(t).evaluate(t).focus), Xl = tr("neutral-fill-stealth-recipe").withDefault({ evaluate: (t, e) => Kn(Ba.getValueFor(t), e || el.getValueFor(t), ma.getValueFor(t), va.getValueFor(t), ba.getValueFor(t), ya.getValueFor(t)) }), Yl = Jn("neutral-fill-stealth-rest").withDefault(t => Xl.getValueFor(t).evaluate(t).rest), Ql = Jn("neutral-fill-stealth-hover").withDefault(t => Xl.getValueFor(t).evaluate(t).hover), Zl = Jn("neutral-fill-stealth-active").withDefault(t => Xl.getValueFor(t).evaluate(t).active), Jl = Jn("neutral-fill-stealth-focus").withDefault(t => Xl.getValueFor(t).evaluate(t).focus), tc = tr("neutral-fill-strong-recipe").withDefault({ evaluate: (t, e) => Wn(Ba.getValueFor(t), e || el.getValueFor(t), 4.5, xa.getValueFor(t), $a.getValueFor(t), wa.getValueFor(t), ka.getValueFor(t)) }), ec = Jn("neutral-fill-strong-rest").withDefault(t => tc.getValueFor(t).evaluate(t).rest), ic = Jn("neutral-fill-strong-hover").withDefault(t => tc.getValueFor(t).evaluate(t).hover), oc = Jn("neutral-fill-strong-active").withDefault(t => tc.getValueFor(t).evaluate(t).active), sc = Jn("neutral-fill-strong-focus").withDefault(t => tc.getValueFor(t).evaluate(t).focus), nc = tr("neutral-foreground-recipe").withDefault({ evaluate: (t, e) => Wn(Ba.getValueFor(t), e || el.getValueFor(t), 16, 0, -19, -30, 0) }), rc = Jn("neutral-foreground-rest").withDefault(t => nc.getValueFor(t).evaluate(t).rest), ac = Jn("neutral-foreground-hover").withDefault(t => nc.getValueFor(t).evaluate(t).hover), lc = Jn("neutral-foreground-active").withDefault(t => nc.getValueFor(t).evaluate(t).active), cc = Jn("neutral-foreground-focus").withDefault(t => nc.getValueFor(t).evaluate(t).focus), hc = tr("neutral-foreground-hint-recipe").withDefault({ evaluate: (t, e) => function (t, e, i) { return t.colorContrast(e, i) }(Ba.getValueFor(t), e || el.getValueFor(t), 4.5) }), dc = Jn("neutral-foreground-hint").withDefault(t => hc.getValueFor(t).evaluate(t)), uc = tr("neutral-stroke-recipe").withDefault({ evaluate: (t, e) => Kn(Ba.getValueFor(t), e || el.getValueFor(t), Ca.getValueFor(t), Ia.getValueFor(t), Fa.getValueFor(t), Da.getValueFor(t)) }), pc = Jn("neutral-stroke-rest").withDefault(t => uc.getValueFor(t).evaluate(t).rest), gc = Jn("neutral-stroke-hover").withDefault(t => uc.getValueFor(t).evaluate(t).hover), fc = Jn("neutral-stroke-active").withDefault(t => uc.getValueFor(t).evaluate(t).active), mc = Jn("neutral-stroke-focus").withDefault(t => uc.getValueFor(t).evaluate(t).focus), vc = tr("neutral-stroke-control-recipe").withDefault({ evaluate: (t, e) => Gn(Ba.getValueFor(t), e || el.getValueFor(t), Ta.getValueFor(t), Sa.getValueFor(t), Oa.getValueFor(t), Ea.getValueFor(t), 5) }), bc = Jn("neutral-stroke-control-rest").withDefault(t => vc.getValueFor(t).evaluate(t).rest), yc = Jn("neutral-stroke-control-hover").withDefault(t => vc.getValueFor(t).evaluate(t).hover), xc = Jn("neutral-stroke-control-active").withDefault(t => vc.getValueFor(t).evaluate(t).active), $c = Jn("neutral-stroke-control-focus").withDefault(t => vc.getValueFor(t).evaluate(t).focus), wc = tr("neutral-stroke-divider-recipe").withDefault({ evaluate: (t, e) => function (t, e, i) { return t.get(t.closestIndexOf(e) + Rn(e) * i) }(Ba.getValueFor(t), e || el.getValueFor(t), Va.getValueFor(t)) }), kc = Jn("neutral-stroke-divider-rest").withDefault(t => wc.getValueFor(t).evaluate(t)), Cc = tr("neutral-stroke-input-recipe").withDefault({ evaluate: (t, e) => function (t, e, i, o, s, n, r, a) { const l = t.closestIndexOf(e), c = Rn(e), h = l + c * i, d = h + c * (o - i), u = h + c * (s - i), p = h + c * (n - i), g = `calc(100% - ${a})`; function f(e, i) { const o = t.get(e); if (i) { const i = t.get(e + c * r), s = `linear-gradient(${o.toColorString()} ${g}, ${i.toColorString()} ${g}, ${i.toColorString()})`; return Un.fromObject(o, s) } return o } return { rest: f(h, !0), hover: f(d, !0), active: f(u, !1), focus: f(p, !0) } }(Ba.getValueFor(t), e || el.getValueFor(t), Ta.getValueFor(t), Sa.getValueFor(t), Oa.getValueFor(t), Ea.getValueFor(t), 20, cr.getValueFor(t) + "px") }), Ic = Jn("neutral-stroke-input-rest").withDefault(t => Cc.getValueFor(t).evaluate(t).rest), Fc = Jn("neutral-stroke-input-hover").withDefault(t => Cc.getValueFor(t).evaluate(t).hover), Dc = Jn("neutral-stroke-input-active").withDefault(t => Cc.getValueFor(t).evaluate(t).active), Tc = Jn("neutral-stroke-input-focus").withDefault(t => Cc.getValueFor(t).evaluate(t).focus), Sc = tr("neutral-stroke-layer-recipe").withDefault({ evaluate: (t, e) => Kn(Ba.getValueFor(t), e || el.getValueFor(t), Ra.getValueFor(t), Aa.getValueFor(t), La.getValueFor(t), Ra.getValueFor(t)) }), Oc = Jn("neutral-stroke-layer-rest").withDefault(t => Sc.getValueFor(t).evaluate(t).rest), Ec = Jn("neutral-stroke-layer-hover").withDefault(t => Sc.getValueFor(t).evaluate(t).hover), Vc = Jn("neutral-stroke-layer-active").withDefault(t => Sc.getValueFor(t).evaluate(t).active), Rc = tr("neutral-stroke-strong-recipe").withDefault({ evaluate: (t, e) => Wn(Ba.getValueFor(t), e || el.getValueFor(t), 5.5, 0, Pa.getValueFor(t), za.getValueFor(t), Ha.getValueFor(t)) }), Ac = Jn("neutral-stroke-strong-rest").withDefault(t => Rc.getValueFor(t).evaluate(t).rest), Lc = Jn("neutral-stroke-strong-hover").withDefault(t => Rc.getValueFor(t).evaluate(t).hover), Pc = Jn("neutral-stroke-strong-active").withDefault(t => Rc.getValueFor(t).evaluate(t).active), zc = Jn("neutral-stroke-strong-focus").withDefault(t => Rc.getValueFor(t).evaluate(t).focus), Hc = tr("focus-stroke-outer-recipe").withDefault({ evaluate: t => (Ba.getValueFor(t), Vn(el.getValueFor(t)) ? zn : Hn) }), Mc = Jn("focus-stroke-outer").withDefault(t => Hc.getValueFor(t).evaluate(t)), Bc = tr("focus-stroke-inner-recipe").withDefault({ evaluate: t => { return ja.getValueFor(t), e = el.getValueFor(t), Mc.getValueFor(t), Vn(e) ? Hn : zn; var e } }), Nc = Jn("focus-stroke-inner").withDefault(t => Bc.getValueFor(t).evaluate(t)), jc = tr("foreground-on-accent-large-recipe").withDefault({ evaluate: t => jn(sl.getValueFor(t), nl.getValueFor(t), rl.getValueFor(t), al.getValueFor(t), il.large) }), Uc = Jn("foreground-on-accent-rest-large").withDefault(t => jc.getValueFor(t).evaluate(t).rest), qc = Jn("foreground-on-accent-hover-large").withDefault(t => jc.getValueFor(t).evaluate(t, nl.getValueFor(t)).hover), _c = Jn("foreground-on-accent-active-large").withDefault(t => jc.getValueFor(t).evaluate(t, rl.getValueFor(t)).active), Gc = Jn("foreground-on-accent-focus-large").withDefault(t => jc.getValueFor(t).evaluate(t, al.getValueFor(t)).focus), Wc = Jn("neutral-fill-inverse-rest-delta").withDefault(0), Kc = Jn("neutral-fill-inverse-hover-delta").withDefault(-3), Xc = Jn("neutral-fill-inverse-active-delta").withDefault(7), Yc = Jn("neutral-fill-inverse-focus-delta").withDefault(0); const Qc = tr("neutral-fill-inverse-recipe").withDefault({ evaluate: (t, e) => function (t, e, i, o, s, n) { const r = Rn(e), a = t.closestIndexOf(t.colorContrast(e, 14)), l = a + r * Math.abs(i - o); let c, h; return (1 === r ? i < o : r * i > r * o) ? (c = a, h = l) : (c = l, h = a), { rest: t.get(c), hover: t.get(h), active: t.get(c + r * s), focus: t.get(c + r * n) } }(Ba.getValueFor(t), e || el.getValueFor(t), Wc.getValueFor(t), Kc.getValueFor(t), Xc.getValueFor(t), Yc.getValueFor(t)) }), Zc = Jn("neutral-fill-inverse-rest").withDefault(t => Qc.getValueFor(t).evaluate(t).rest), Jc = Jn("neutral-fill-inverse-hover").withDefault(t => Qc.getValueFor(t).evaluate(t).hover), th = Jn("neutral-fill-inverse-active").withDefault(t => Qc.getValueFor(t).evaluate(t).active), eh = Jn("neutral-fill-inverse-focus").withDefault(t => Qc.getValueFor(t).evaluate(t).focus), ih = ar, oh = lr, sh = cr, nh = hr, rh = Wc, ah = Kc, lh = Xc, ch = Yc, hh = la, dh = xa, uh = $a, ph = wa, gh = ka, fh = Va, mh = Ka, vh = Ya, bh = Za, yh = tl, xh = cl, $h = Uc, wh = kc, kh = Ml, Ch = Zc, Ih = Jc, Fh = th, Dh = eh, Th = ec, Sh = ic, Oh = oc, Eh = sc, Vh = Mc, Rh = Nc, Ah = pc, Lh = gc, Ph = fc, zh = mc, Hh = vt`
  font-family: ${dr};
  font-size: ${gr};
  line-height: ${fr};
  font-weight: initial;
  font-variation-settings: ${mr};
`, Mh = vt`
  font-family: ${dr};
  font-size: ${vr};
  line-height: ${br};
  font-weight: initial;
  font-variation-settings: ${yr};
`, Bh = vt`
  font-family: ${dr};
  font-size: ${xr};
  line-height: ${$r};
  font-weight: initial;
  font-variation-settings: ${wr};
`, Nh = vt`
  font-family: ${dr};
  font-size: ${kr};
  line-height: ${Cr};
  font-weight: initial;
  font-variation-settings: ${Ir};
`, jh = vt`
  font-family: ${dr};
  font-size: ${Fr};
  line-height: ${Dr};
  font-weight: initial;
  font-variation-settings: ${Tr};
`, Uh = vt`
  font-family: ${dr};
  font-size: ${Sr};
  line-height: ${Or};
  font-weight: initial;
  font-variation-settings: ${Er};
`, qh = vt`
  font-family: ${dr};
  font-size: ${Vr};
  line-height: ${Rr};
  font-weight: initial;
  font-variation-settings: ${Ar};
`, _h = vt`
  font-family: ${dr};
  font-size: ${Lr};
  line-height: ${Pr};
  font-weight: initial;
  font-variation-settings: ${zr};
`, Gh = vt`
  font-family: ${dr};
  font-size: ${Hr};
  line-height: ${Mr};
  font-weight: initial;
  font-variation-settings: ${Br};
`, Wh = (t, e) => ft`
    ${rn("flex")} :host{box-sizing:border-box;flex-direction:column;${Hh}
      color:${rc};gap:calc(${rr} * 1px)}`, Kh = vt`
  outline: calc(${hr} * 1px) solid ${Mc};
  outline-offset: calc(${hr} * -1px);
`, Xh = vt`
  outline: calc(${hr} * 1px) solid ${Mc};
  outline-offset: calc(${cr} * 1px);
`, Yh = vt`(${or} + ${nr}) * ${rr}`, Qh = fo.create("neutral-fill-stealth-rest-on-neutral-fill-layer-rest").withDefault(t => { const e = Hl.getValueFor(t); return Xl.getValueFor(t).evaluate(t, e.evaluate(t).rest).rest }), Zh = fo.create("neutral-fill-stealth-hover-on-neutral-fill-layer-rest").withDefault(t => { const e = Hl.getValueFor(t); return Xl.getValueFor(t).evaluate(t, e.evaluate(t).rest).hover }), Jh = fo.create("neutral-fill-stealth-active-on-neutral-fill-layer-rest").withDefault(t => { const e = Hl.getValueFor(t); return Xl.getValueFor(t).evaluate(t, e.evaluate(t).rest).active }), td = (t, e) => ft`
    ${rn("flex")} :host{box-sizing:border-box;${Hh};flex-direction:column;background:${Ml};color:${rc};border:calc(${cr} * 1px) solid ${Oc};border-radius:calc(${lr} * 1px)}.region{display:none;padding:calc(${rr} * 2 * 1px);background:${Ul}}.heading{display:grid;position:relative;grid-template-columns:auto 1fr auto auto;align-items:center}.button{appearance:none;border:none;background:none;grid-column:2;grid-row:1;outline:none;margin:calc(${rr} * 3 * 1px) 0;padding:0 calc(${rr} * 2 * 1px);text-align:left;color:inherit;cursor:pointer;font:inherit}.button::before{content:'';position:absolute;top:calc(${cr} * -1px);left:calc(${cr} * -1px);right:calc(${cr} * -1px);bottom:calc(${cr} * -1px);cursor:pointer}.button:${an}::before{${Kh}
      border-radius:calc(${lr} * 1px)}:host(.expanded) .button:${an}::before{border-bottom-left-radius:0;border-bottom-right-radius:0}:host(.expanded) .region{display:block;border-top:calc(${cr} * 1px) solid ${Oc};border-bottom-left-radius:calc((${lr} - ${cr}) * 1px);border-bottom-right-radius:calc((${lr} - ${cr}) * 1px)}.icon{display:flex;align-items:center;justify-content:center;grid-column:4;pointer-events:none;background:${Qh};border-radius:calc(${ar} * 1px);fill:currentcolor;width:calc(${Yh} * 1px);height:calc(${Yh} * 1px);margin:calc(${rr} * 2 * 1px)}.heading:hover .icon{background:${Zh}}.heading:active .icon{background:${Jh}}slot[name='collapsed-icon']{display:flex}:host(.expanded) slot[name='collapsed-icon']{display:none}slot[name='expanded-icon']{display:none}:host(.expanded) slot[name='expanded-icon']{display:flex}.start{display:flex;align-items:center;padding-inline-start:calc(${rr} * 2 * 1px);justify-content:center;grid-column:1}.end{display:flex;align-items:center;justify-content:center;grid-column:3}.icon,.start,.end{position:relative}`.withBehaviors(sn(ft`
        .button:${an}::before{outline-color:${Ge.Highlight}}.icon{fill:${Ge.ButtonText}}`)), ed = Re.compose({ baseName: "accordion-item", template: (t, e) => _`<template class="${t => t.expanded ? "expanded" : ""}"><div class="heading" part="heading" role="heading" aria-level="${t => t.headinglevel}"><button class="button" part="button" ${Dt("expandbutton")} aria-expanded="${t => t.expanded}" aria-controls="${t => t.id}-panel" id="${t => t.id}" @click="${(t, e) => t.clickHandler(e.event)}"><span class="heading-content" part="heading-content"><slot name="heading"></slot></span></button>${Ut(0, e)} ${jt(0, e)}<span class="icon" part="icon" aria-hidden="true"><slot name="expanded-icon" part="expanded-icon">${e.expandedIcon || ""}</slot><slot name="collapsed-icon" part="collapsed-icon">${e.collapsedIcon || ""}</slot><span></div><div class="region" part="region" id="${t => t.id}-panel" role="region" aria-labelledby="${t => t.id}"><slot></slot></div></template>`, styles: td, collapsedIcon: '\n    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">\n      <path d="M2.15 4.65c.2-.2.5-.2.7 0L6 7.79l3.15-3.14a.5.5 0 11.7.7l-3.5 3.5a.5.5 0 01-.7 0l-3.5-3.5a.5.5 0 010-.7z"/>\n    </svg>\n  ', expandedIcon: '\n    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">\n      <path d="M2.15 7.35c.2.2.5.2.7 0L6 4.21l3.15 3.14a.5.5 0 10.7-.7l-3.5-3.5a.5.5 0 00-.7 0l-3.5 3.5a.5.5 0 000 .7z"/>\n    </svg>\n  ' }), id = td, od = Xe.compose({ baseName: "accordion", template: (t, e) => _`<template><slot ${Ht({ property: "accordionItems", filter: Lt() })}></slot><slot name="item" part="item" ${Ht("accordionItems")}></slot></template>`, styles: Wh }), sd = Wh;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function nd(t, e, i, o) { var s, n = arguments.length, r = n < 3 ? e : null === o ? o = Object.getOwnPropertyDescriptor(e, i) : o; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(t, e, i, o); else for (var a = t.length - 1; a >= 0; a--)(s = t[a]) && (r = (n < 3 ? s(r) : n > 3 ? s(e, i, r) : s(e, i)) || r); return n > 3 && r && Object.defineProperty(e, i, r), r } class rd { constructor(t, e) { this.cache = new WeakMap, this.ltr = t, this.rtl = e } bind(t) { this.attach(t) } unbind(t) { const e = this.cache.get(t); e && er.unsubscribe(e) } attach(t) { const e = this.cache.get(t) || new ad(this.ltr, this.rtl, t), i = er.getValueFor(t); er.subscribe(e), e.attach(i), this.cache.set(t, e) } } class ad { constructor(t, e, i) { this.ltr = t, this.rtl = e, this.source = i, this.attached = null } handleChange({ target: t, token: e }) { this.attach(e.getValueFor(this.source)) } attach(t) { this.attached !== this[t] && (null !== this.attached && this.source.$fastController.removeStyles(this.attached), this.attached = this[t], null !== this.attached && this.source.$fastController.addStyles(this.attached)) } } const ld = "0 0 2px rgba(0, 0, 0, 0.14)", cd = "0 calc(var(--elevation) * 0.5px) calc((var(--elevation) * 1px)) rgba(0, 0, 0, 0.2)", hd = `box-shadow: 0 0 2px rgba(0, 0, 0, 0.14), ${cd};`, dd = fo.create({ name: "elevation-shadow", cssCustomPropertyName: null }).withDefault({ evaluate: (t, e, i) => { let o = .12, s = .14; e > 16 && (o = .2, s = .24); return `${`0 0 2px rgba(0, 0, 0, ${o})`}, ${`0 calc(${e} * 0.5px) calc((${e} * 1px)) rgba(0, 0, 0, ${s})`}` } }), ud = fo.create("elevation-shadow-card-rest-size").withDefault(4), pd = fo.create("elevation-shadow-card-hover-size").withDefault(8), gd = fo.create("elevation-shadow-card-active-size").withDefault(0), fd = fo.create("elevation-shadow-card-focus-size").withDefault(8), md = fo.create("elevation-shadow-card-rest").withDefault(t => dd.getValueFor(t).evaluate(t, ud.getValueFor(t))), vd = fo.create("elevation-shadow-card-hover").withDefault(t => dd.getValueFor(t).evaluate(t, pd.getValueFor(t))), bd = fo.create("elevation-shadow-card-active").withDefault(t => dd.getValueFor(t).evaluate(t, gd.getValueFor(t))), yd = fo.create("elevation-shadow-card-focus").withDefault(t => dd.getValueFor(t).evaluate(t, fd.getValueFor(t))), xd = fo.create("elevation-shadow-tooltip-size").withDefault(16), $d = fo.create("elevation-shadow-tooltip").withDefault(t => dd.getValueFor(t).evaluate(t, xd.getValueFor(t))), wd = fo.create("elevation-shadow-flyout-size").withDefault(32), kd = fo.create("elevation-shadow-flyout").withDefault(t => dd.getValueFor(t).evaluate(t, wd.getValueFor(t))), Cd = fo.create("elevation-shadow-dialog-size").withDefault(128), Id = fo.create("elevation-shadow-dialog").withDefault(t => dd.getValueFor(t).evaluate(t, Cd.getValueFor(t))), Fd = (t, e, i, o = "[disabled]") => ft`
    ${rn("inline-flex")}
    
    :host{position:relative;box-sizing:border-box;${Hh}
      height:calc(${Yh} * 1px);min-width:calc(${Yh} * 1px);color:${rc};border-radius:calc(${ar} * 1px);fill:currentcolor}.control{border:calc(${cr} * 1px) solid transparent;flex-grow:1;box-sizing:border-box;display:inline-flex;justify-content:center;align-items:center;padding:0 calc((10 + (${rr} * 2 * ${nr})) * 1px);white-space:nowrap;outline:none;text-decoration:none;color:inherit;border-radius:inherit;fill:inherit;font-family:inherit}.control,.end,.start{font:inherit}.control.icon-only{padding:0;line-height:0}.control:${an}{${Kh}}.control::-moz-focus-inner{border:0}.content{pointer-events:none}.start,.end{display:flex;pointer-events:none}.start{margin-inline-end:11px}.end{margin-inline-start:11px}`, Dd = (t, e, i, o = "[disabled]") => ft`
    .control{background:padding-box linear-gradient(${Cl},${Cl}),border-box ${bc}}:host(${i}:hover) .control{background:padding-box linear-gradient(${Il},${Il}),border-box ${yc}}:host(${i}:active) .control{background:padding-box linear-gradient(${Fl},${Fl}),border-box ${xc}}:host(${o}) .control{background:padding-box linear-gradient(${Cl},${Cl}),border-box ${pc}}`.withBehaviors(sn(ft`
        .control{background:${Ge.ButtonFace};border-color:${Ge.ButtonText};color:${Ge.ButtonText}}:host(${i}:hover) .control,:host(${i}:active) .control{forced-color-adjust:none;background:${Ge.HighlightText};border-color:${Ge.Highlight};color:${Ge.Highlight}}:host(${o}) .control{background:transparent;border-color:${Ge.GrayText};color:${Ge.GrayText}}.control:${an}{outline-color:${Ge.CanvasText}}:host([href]) .control{background:transparent;border-color:${Ge.LinkText};color:${Ge.LinkText}}:host([href]:hover) .control,:host([href]:active) .control{background:transparent;border-color:${Ge.CanvasText};color:${Ge.CanvasText}}`)), Td = (t, e, i, o = "[disabled]") => ft`
    .control{background:padding-box linear-gradient(${sl},${sl}),border-box ${yl};color:${cl}}:host(${i}:hover) .control{background:padding-box linear-gradient(${nl},${nl}),border-box ${xl};color:${hl}}:host(${i}:active) .control{background:padding-box linear-gradient(${rl},${rl}),border-box ${$l};color:${dl}}:host(${o}) .control{background:${sl}}.control:${an}{box-shadow:0 0 0 calc(${hr} * 1px) ${Nc} inset !important}`.withBehaviors(sn(ft`
        .control{forced-color-adjust:none;background:${Ge.Highlight};color:${Ge.HighlightText}}:host(${i}:hover) .control,:host(${i}:active) .control{background:${Ge.HighlightText};border-color:${Ge.Highlight};color:${Ge.Highlight}}:host(${o}) .control{background:transparent;border-color:${Ge.GrayText};color:${Ge.GrayText}}.control:${an}{outline-color:${Ge.CanvasText};box-shadow:0 0 0 calc(${hr} * 1px) ${Ge.HighlightText} inset !important}:host([href]) .control{background:${Ge.LinkText};color:${Ge.HighlightText}}:host([href]:hover) .control,:host([href]:active) .control{background:${Ge.ButtonFace};border-color:${Ge.LinkText};color:${Ge.LinkText}}`)), Sd = (t, e, i, o = "[disabled]") => ft`
    :host{height:auto;font-family:inherit;font-size:inherit;line-height:inherit;min-width:0}.control{display:inline;padding:0;border:none;box-shadow:none;line-height:1}:host(${i}) .control{color:${gl};text-decoration:underline 1px}:host(${i}:hover) .control{color:${fl};text-decoration:none}:host(${i}:active) .control{color:${ml};text-decoration:none}.control:${an}{${Xh}}`.withBehaviors(sn(ft`
        :host(${i}) .control{color:${Ge.LinkText}}:host(${i}:hover) .control,:host(${i}:active) .control{color:${Ge.CanvasText}}.control:${an}{outline-color:${Ge.CanvasText}}`)), Od = (t, e, i, o = "[disabled]") => ft`
    :host{color:${gl}}.control{background:${Yl}}:host(${i}:hover) .control{background:${Ql};color:${fl}}:host(${i}:active) .control{background:${Zl};color:${ml}}:host(${o}) .control{background:${Yl}}`.withBehaviors(sn(ft`
        :host{color:${Ge.ButtonText}}.control{forced-color-adjust:none;background:transparent}:host(${i}:hover) .control,:host(${i}:active) .control{background:transparent;border-color:${Ge.ButtonText};color:${Ge.ButtonText}}:host(${o}) .control{background:transparent;color:${Ge.GrayText}}.control:${an}{outline-color:${Ge.CanvasText}}:host([href]) .control{color:${Ge.LinkText}}:host([href]:hover) .control,:host([href]:active) .control{border-color:${Ge.LinkText};color:${Ge.LinkText}}`)), Ed = (t, e, i, o = "[disabled]") => ft`
    .control{background:transparent !important;border-color:${pc}}:host(${i}:hover) .control{border-color:${gc}}:host(${i}:active) .control{border-color:${fc}}:host(${o}) .control{background:transparent !important;border-color:${pc}}`.withBehaviors(sn(ft`
        .control{border-color:${Ge.ButtonText};color:${Ge.ButtonText}}:host(${i}:hover) .control,:host(${i}:active) .control{background:${Ge.HighlightText};border-color:${Ge.Highlight};color:${Ge.Highlight}}:host(${o}) .control{border-color:${Ge.GrayText};color:${Ge.GrayText}}.control:${an}{outline-color:${Ge.CanvasText}}:host([href]) .control{border-color:${Ge.LinkText};color:${Ge.LinkText}}:host([href]:hover) .control,:host([href]:active) .control{border-color:${Ge.CanvasText};color:${Ge.CanvasText}}`)), Vd = (t, e, i, o = "[disabled]") => ft`
    .control{background:${Yl}}:host(${i}:hover) .control{background:${Ql}}:host(${i}:active) .control{background:${Zl}}:host(${o}) .control{background:${Yl}}`.withBehaviors(sn(ft`
        .control{forced-color-adjust:none;background:transparent;color:${Ge.ButtonText}}:host(${i}:hover) .control,:host(${i}:active) .control{background:transparent;border-color:${Ge.ButtonText};color:${Ge.ButtonText}}:host(${o}) .control{background:transparent;color:${Ge.GrayText}}.control:${an}{outline-color:${Ge.CanvasText}}:host([href]) .control{color:${Ge.LinkText}}:host([href]:hover) .control,:host([href]:active) .control{background:transparent;border-color:${Ge.LinkText};color:${Ge.LinkText}}`)), Rd = fo.create("input-placeholder-rest").withDefault(t => { const e = Tl.getValueFor(t); return hc.getValueFor(t).evaluate(t, e.evaluate(t).rest) }), Ad = fo.create("input-placeholder-hover").withDefault(t => { const e = Tl.getValueFor(t); return hc.getValueFor(t).evaluate(t, e.evaluate(t).hover) }), Ld = fo.create("input-filled-placeholder-rest").withDefault(t => { const e = ql.getValueFor(t); return hc.getValueFor(t).evaluate(t, e.evaluate(t).rest) }), Pd = fo.create("input-filled-placeholder-hover").withDefault(t => { const e = ql.getValueFor(t); return hc.getValueFor(t).evaluate(t, e.evaluate(t).hover) }), zd = (t, e, i) => ft`
  :host{${Hh}
    color:${rc};fill:currentcolor;user-select:none;position:relative}${i}{box-sizing:border-box;position:relative;color:inherit;border:calc(${cr} * 1px) solid transparent;border-radius:calc(${ar} * 1px);height:calc(${Yh} * 1px);font-family:inherit;font-size:inherit;line-height:inherit}.control{width:100%;outline:none}.label{display:block;color:${rc};cursor:pointer;${Hh}
    margin-bottom:4px}.label__hidden{display:none;visibility:hidden}:host([disabled]) ${i},:host([readonly]) ${i},:host([disabled]) .label,:host([readonly]) .label,:host([disabled]) .control,:host([readonly]) .control{cursor:${"not-allowed"}}:host([disabled]){opacity:${ir}}`, Hd = (t, e, i) => ft`
  @media (forced-colors:none){:host(:not([disabled]):active)::after{left:50%;width:40%;transform:translateX(-50%);border-bottom-left-radius:0;border-bottom-right-radius:0}:host(:not([disabled]):focus-within)::after{left:0;width:100%;transform:none}:host(:not([disabled]):active)::after,:host(:not([disabled]):focus-within:not(:active))::after{content:'';position:absolute;height:calc(${hr} * 1px);bottom:0;border-bottom:calc(${hr} * 1px) solid ${sl};border-bottom-left-radius:calc(${ar} * 1px);border-bottom-right-radius:calc(${ar} * 1px);z-index:2;transition:all 300ms cubic-bezier(0.1,0.9,0.2,1)}}`, Md = (t, e, i, o = ":not([disabled]):not(:focus-within)") => ft`
  ${i}{background:padding-box linear-gradient(${Sl},${Sl}),border-box ${Ic}}:host(${o}:hover) ${i}{background:padding-box linear-gradient(${Ol},${Ol}),border-box ${Fc}}:host(:not([disabled]):focus-within) ${i}{background:padding-box linear-gradient(${Vl},${Vl}),border-box ${Ic}}:host([disabled]) ${i}{background:padding-box linear-gradient(${Sl},${Sl}),border-box ${pc}}.control::placeholder{color:${Rd}}:host(${o}:hover) .control::placeholder{color:${Ad}}`, Bd = (t, e, i, o = ":not([disabled]):not(:focus-within)") => ft`
  ${i}{background:${_l}}:host(${o}:hover) ${i}{background:${Gl}}:host(:not([disabled]):focus-within) ${i}{background:${Kl}}:host([disabled]) ${i}{background:${_l}}.control::placeholder{color:${Ld}}:host(${o}:hover) .control::placeholder{color:${Pd}}`, Nd = (t, e, i, o = ":not([disabled]):not(:focus-within)") => ft`
  :host{color:${Ge.ButtonText}}${i}{background:${Ge.ButtonFace};border-color:${Ge.ButtonText}}:host(${o}:hover) ${i},:host(:not([disabled]):focus-within) ${i}{border-color:${Ge.Highlight}}:host([disabled]) ${i}{opacity:1;background:${Ge.ButtonFace};border-color:${Ge.GrayText}}.control::placeholder,:host(${o}:hover) .control::placeholder{color:${Ge.CanvasText}}:host(:not([disabled]):focus) ${i}{${Kh}
    outline-color:${Ge.Highlight}}:host([disabled]){opacity:1;color:${Ge.GrayText}}:host([disabled]) ::placeholder,:host([disabled]) ::-webkit-input-placeholder{color:${Ge.GrayText}}`; function jd(t, e) { return new nn("appearance", t, e) } const Ud = (t, e) => Fd().withBehaviors(jd("neutral", Dd(0, 0, "[href]")), jd("accent", Td(0, 0, "[href]")), jd("hypertext", Sd(0, 0, "[href]")), jd("lightweight", Od(0, 0, "[href]")), jd("outline", Ed(0, 0, "[href]")), jd("stealth", Vd(0, 0, "[href]"))); class qd extends Ze { appearanceChanged(t, e) { t !== e && (this.classList.add(e), this.classList.remove(t)) } connectedCallback() { super.connectedCallback(), this.appearance || (this.appearance = "neutral") } defaultSlottedContentChanged() { const t = this.defaultSlottedContent.filter(t => t.nodeType === Node.ELEMENT_NODE); 1 === t.length && t[0] instanceof SVGElement ? this.control.classList.add("icon-only") : this.control.classList.remove("icon-only") } } nd([it], qd.prototype, "appearance", void 0); const _d = Ud, Gd = qd.compose({ baseName: "anchor", baseClass: Ze, template: Ye, styles: Ud, shadowOptions: { delegatesFocus: !0 } }), Wd = (t, e) => ft`
  :host{contain:layout;display:block}`, Kd = ei.compose({ baseName: "anchored-region", template: (t, e) => _`<template class="${t => t.initialLayoutComplete ? "loaded" : ""}">${Tt(t => t.initialLayoutComplete, _`<slot></slot>`)}</template>`, styles: Wd }), Xd = Wd, Yd = (t, e) => ft`
    ${rn("inline-block")} :host{box-sizing:border-box;${Mh}}.control{border-radius:calc(${ar} * 1px);padding:calc(((${rr} * 0.5) - ${cr}) * 1px) calc((${rr} - ${cr}) * 1px);border:calc(${cr} * 1px) solid transparent}:host(.lightweight) .control{background:transparent;color:${rc};font-weight:600}:host(.accent) .control{background:${sl};color:${cl}}:host(.neutral) .control{background:${_l};color:${rc}}:host([circular]) .control{border-radius:100px;min-width:calc(${br} - calc(${rr} * 1px));display:flex;align-items:center;justify-content:center}`; class Qd extends ii { constructor() { super(...arguments), this.appearance = "lightweight" } appearanceChanged(t, e) { t !== e && d.queueUpdate(() => { this.classList.add(e), this.classList.remove(t) }) } } nd([it({ mode: "fromView" })], Qd.prototype, "appearance", void 0); const Zd = Qd.compose({ baseName: "badge", baseClass: ii, template: (t, e) => _`<template class="${t => t.circular ? "circular" : ""}"><div class="control" part="control" style="${t => t.generateBadgeStyle()}"><slot></slot></div></template>`, styles: Yd }), Jd = Yd, tu = (t, e) => ft`
  ${rn("inline-block")} :host{box-sizing:border-box;${Hh}}.list{display:flex}`, eu = si.compose({ baseName: "breadcrumb", template: (t, e) => _`<template role="navigation"><div role="list" class="list" part="list"><slot ${Ht({ property: "slottedBreadcrumbItems", filter: Lt() })}></slot></div></template>`, styles: tu }), iu = tu, ou = (t, e) => ft`
    ${rn("inline-flex")} :host{background:transparent;color:${rc};fill:currentcolor;box-sizing:border-box;${Hh};min-width:calc(${Yh} * 1px);border-radius:calc(${ar} * 1px)}.listitem{display:flex;align-items:center;border-radius:inherit}.control{position:relative;align-items:center;box-sizing:border-box;color:inherit;fill:inherit;cursor:pointer;display:flex;outline:none;text-decoration:none;white-space:nowrap;border-radius:inherit}.control:hover{color:${ac}}.control:active{color:${lc}}.control:${an}{${Xh}}:host(:not([href])),:host([aria-current]) .control{color:${rc};fill:currentcolor;cursor:default}.start{display:flex;margin-inline-end:6px}.end{display:flex;margin-inline-start:6px}.separator{display:flex}`.withBehaviors(sn(ft`
        :host(:not([href])),.start,.end,.separator{background:${Ge.ButtonFace};color:${Ge.ButtonText};fill:currentcolor}.separator{fill:${Ge.ButtonText}}:host([href]){forced-color-adjust:none;background:${Ge.ButtonFace};color:${Ge.LinkText}}:host([href]) .control:hover{background:${Ge.LinkText};color:${Ge.HighlightText};fill:currentcolor}.control:${an}{outline-color:${Ge.LinkText}}`)), su = oi.compose({ baseName: "breadcrumb-item", template: (t, e) => _`<div role="listitem" class="listitem" part="listitem">${Tt(t => t.href && t.href.length > 0, _` ${Ye(0, e)} `)} ${Tt(t => !t.href, _` ${Ut(0, e)}<slot></slot>${jt(0, e)} `)} ${Tt(t => t.separator, _`<span class="separator" part="separator" aria-hidden="true"><slot name="separator">${e.separator || ""}</slot></span>`)}</div>`, styles: ou, shadowOptions: { delegatesFocus: !0 }, separator: '\n    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">\n      <path d="M4.65 2.15a.5.5 0 000 .7L7.79 6 4.65 9.15a.5.5 0 10.7.7l3.5-3.5a.5.5 0 000-.7l-3.5-3.5a.5.5 0 00-.7 0z"/>\n    </svg>\n  ' }), nu = ou, ru = (t, e) => ft`
    :host(${":not([disabled])"}) .control{cursor:pointer}:host(${"[disabled]"}) .control{cursor:${"not-allowed"}}@media (forced-colors:none){:host(${"[disabled]"}) .control{opacity:${ir}}}${Fd(0, 0, 0, "[disabled]")}
  `.withBehaviors(jd("neutral", Dd(0, 0, ":not([disabled])", "[disabled]")), jd("accent", Td(0, 0, ":not([disabled])", "[disabled]")), jd("lightweight", Od(0, 0, ":not([disabled])", "[disabled]")), jd("outline", Ed(0, 0, ":not([disabled])", "[disabled]")), jd("stealth", Vd(0, 0, ":not([disabled])", "[disabled]"))); class au extends di { appearanceChanged(t, e) { t !== e && (this.classList.add(e), this.classList.remove(t)) } connectedCallback() { super.connectedCallback(), this.appearance || (this.appearance = "neutral") } defaultSlottedContentChanged() { const t = this.defaultSlottedContent.filter(t => t.nodeType === Node.ELEMENT_NODE); 1 === t.length && t[0] instanceof SVGElement ? this.control.classList.add("icon-only") : this.control.classList.remove("icon-only") } } nd([it], au.prototype, "appearance", void 0); const lu = au.compose({ baseName: "button", baseClass: di, template: (t, e) => _`<button class="control" part="control" ?autofocus="${t => t.autofocus}" ?disabled="${t => t.disabled}" form="${t => t.formId}" formaction="${t => t.formaction}" formenctype="${t => t.formenctype}" formmethod="${t => t.formmethod}" formnovalidate="${t => t.formnovalidate}" formtarget="${t => t.formtarget}" name="${t => t.name}" type="${t => t.type}" value="${t => t.value}" aria-atomic="${t => t.ariaAtomic}" aria-busy="${t => t.ariaBusy}" aria-controls="${t => t.ariaControls}" aria-current="${t => t.ariaCurrent}" aria-describedby="${t => t.ariaDescribedby}" aria-details="${t => t.ariaDetails}" aria-disabled="${t => t.ariaDisabled}" aria-errormessage="${t => t.ariaErrormessage}" aria-expanded="${t => t.ariaExpanded}" aria-flowto="${t => t.ariaFlowto}" aria-haspopup="${t => t.ariaHaspopup}" aria-hidden="${t => t.ariaHidden}" aria-invalid="${t => t.ariaInvalid}" aria-keyshortcuts="${t => t.ariaKeyshortcuts}" aria-label="${t => t.ariaLabel}" aria-labelledby="${t => t.ariaLabelledby}" aria-live="${t => t.ariaLive}" aria-owns="${t => t.ariaOwns}" aria-pressed="${t => t.ariaPressed}" aria-relevant="${t => t.ariaRelevant}" aria-roledescription="${t => t.ariaRoledescription}" ${Dt("control")}>${Ut(0, e)}<span class="content" part="content"><slot ${Ht("defaultSlottedContent")}></slot></span>${jt(0, e)}</button>`, styles: ru, shadowOptions: { delegatesFocus: !0 } }), cu = ru, hu = ft`
.day.disabled::before{transform:translate(-50%,0) rotate(45deg)}`, du = ft`
.day.disabled::before{transform:translate(50%,0) rotate(-45deg)}`; class uu extends gi { constructor() { super(...arguments), this.readonly = !0 } } nd([it({ converter: J })], uu.prototype, "readonly", void 0); const pu = uu.compose({
    baseName: "calendar", template: (t, e) => { var i; const o = new Date, s = `${o.getMonth() + 1}-${o.getDate()}-${o.getFullYear()}`; return _`<template>${_t} ${e.title instanceof Function ? e.title(t, e) : null !== (i = e.title) && void 0 !== i ? i : ""}<slot></slot>${Tt(t => !1 === t.readonly, Ei(t, s))} ${Tt(t => !0 === t.readonly, (t => _`<div class="days" part="days"><div class="week-days" part="week-days">${At(t => t.getWeekdayText(), _`<div class="week-day" part="week-day" abbr="${t => t.abbr}">${t => t.text}</div>`)}</div>${At(t => t.getDays(), _`<div class="week">${At(t => t, _`<div class="${(e, i) => i.parentContext.parent.getDayClassNames(e, t)}" part="day" aria-label="${(t, e) => e.parentContext.parent.dateFormatter.getDate(`${t.month}-${t.day}-${t.year}`, { month: "long", day: "numeric" })}"><div class="date" part="${e => t === `${e.month}-${e.day}-${e.year}` ? "today" : "date"}">${(t, e) => e.parentContext.parent.dateFormatter.getDay(t.day)}</div><slot name="${t => t.month}-${t => t.day}-${t => t.year}"></slot></div>`)}</div>`)}</div>`)(s))} ${qt}</template>` }, styles: (t, e) => ft`
${rn("inline-block")} :host{--calendar-cell-size:calc((${or} + 2 + ${nr}) * ${rr} * 1px);--calendar-gap:2px;${Hh}
  color:${rc}}.title{padding:calc(${rr} * 2px);font-weight:600}.days{text-align:center}.week-days,.week{display:grid;grid-template-columns:repeat(7,1fr);grid-gap:var(--calendar-gap);border:0;padding:0}.day,.week-day{border:0;width:var(--calendar-cell-size);height:var(--calendar-cell-size);line-height:var(--calendar-cell-size);padding:0;box-sizing:initial}.week-day{font-weight:600}.day{border:calc(${cr} * 1px) solid transparent;border-radius:calc(${ar} * 1px)}.interact .day{cursor:pointer}.date{height:100%}.inactive .date,.inactive.disabled::before{color:${dc}}.disabled::before{content:'';display:inline-block;width:calc(var(--calendar-cell-size) * .8);height:calc(${cr} * 1px);background:currentColor;position:absolute;margin-top:calc(var(--calendar-cell-size) / 2);transform-origin:center;z-index:1}.selected{color:${sl};border:1px solid ${sl};background:${el}}.selected + .selected{border-start-start-radius:0;border-end-start-radius:0;border-inline-start-width:0;padding-inline-start:calc(var(--calendar-gap) + (${cr} + ${ar}) * 1px);margin-inline-start:calc((${ar} * -1px) - var(--calendar-gap))}.today.disabled::before{color:${cl}}.today .date{color:${cl};background:${sl};border-radius:50%;position:relative}`.withBehaviors(sn(ft`
          .day.selected{color:${Ge.Highlight}}.today .date{background:${Ge.Highlight};color:${Ge.HighlightText}}`), new rd(hu, du)), title: Si
}), gu = (t, e) => ft`
    ${rn("block")} :host{display:block;contain:content;height:var(--card-height,100%);width:var(--card-width,100%);box-sizing:border-box;background:${el};color:${rc};border:calc(${cr} * 1px) solid ${Oc};border-radius:calc(${lr} * 1px);box-shadow:${md}}:host{content-visibility:auto}`.withBehaviors(sn(ft`
        :host{background:${Ge.Canvas};color:${Ge.CanvasText}}`)); class fu extends Vi { cardFillColorChanged(t, e) { if (e) { const t = Dn(e); null !== t && (this.neutralPaletteSource = e, el.setValueFor(this, Sn.create(t.r, t.g, t.b))) } } neutralPaletteSourceChanged(t, e) { if (e) { const t = Dn(e), i = Sn.create(t.r, t.g, t.b); Ba.setValueFor(this, Ln.create(i)) } } handleChange(t, e) { this.cardFillColor || el.setValueFor(this, e => Hl.getValueFor(e).evaluate(e, el.getValueFor(t)).rest) } connectedCallback() { super.connectedCallback(); const t = Qi(this); if (t) { const e = g.getNotifier(t); e.subscribe(this, "fillColor"), e.subscribe(this, "neutralPalette"), this.handleChange(t, "fillColor") } } } nd([it({ attribute: "card-fill-color", mode: "fromView" })], fu.prototype, "cardFillColor", void 0), nd([it({ attribute: "neutral-palette-source", mode: "fromView" })], fu.prototype, "neutralPaletteSource", void 0); const mu = fu.compose({ baseName: "card", baseClass: Vi, template: (t, e) => _`<slot></slot>`, styles: gu }), vu = gu, bu = (t, e) => ft`
    ${rn("inline-flex")} :host{align-items:center;outline:none;${""} user-select:none}.control{position:relative;width:calc((${Yh} / 2 + ${rr}) * 1px);height:calc((${Yh} / 2 + ${rr}) * 1px);box-sizing:border-box;border-radius:calc(${ar} * 1px);border:calc(${cr} * 1px) solid ${Ac};background:${Al};cursor:pointer}.label__hidden{display:none;visibility:hidden}.label{${Hh}
      color:${rc};${""} padding-inline-start:calc(${rr} * 2px + 2px);margin-inline-end:calc(${rr} * 2px + 2px);cursor:pointer}slot[name='checked-indicator'],slot[name='indeterminate-indicator']{display:flex;align-items:center;justify-content:center;width:100%;height:100%;fill:${rc};opacity:0;pointer-events:none}slot[name='indeterminate-indicator']{position:absolute;top:0}:host(.checked) slot[name='checked-indicator'],:host(.checked) slot[name='indeterminate-indicator']{fill:${cl}}:host(:not(.disabled):hover) .control{background:${Ll};border-color:${Lc}}:host(:not(.disabled):active) .control{background:${Pl};border-color:${Pc}}:host(:${an}) .control{background:${zl};${Xh}}:host(.checked) .control{background:${sl};border-color:transparent}:host(.checked:not(.disabled):hover) .control{background:${nl};border-color:transparent}:host(.checked:not(.disabled):active) .control{background:${rl};border-color:transparent}:host(.disabled) .label,:host(.readonly) .label,:host(.readonly) .control,:host(.disabled) .control{cursor:${"not-allowed"}}:host(.checked:not(.indeterminate)) slot[name='checked-indicator'],:host(.indeterminate) slot[name='indeterminate-indicator']{opacity:1}:host(.disabled){opacity:${ir}}`.withBehaviors(sn(ft`
        .control{border-color:${Ge.FieldText};background:${Ge.Field}}:host(:not(.disabled):hover) .control,:host(:not(.disabled):active) .control{border-color:${Ge.Highlight};background:${Ge.Field}}slot[name='checked-indicator'],slot[name='indeterminate-indicator']{fill:${Ge.FieldText}}:host(:${an}) .control{forced-color-adjust:none;outline-color:${Ge.FieldText};background:${Ge.Field};border-color:${Ge.Highlight}}:host(.checked) .control{background:${Ge.Highlight};border-color:${Ge.Highlight}}:host(.checked:not(.disabled):hover) .control,:host(.checked:not(.disabled):active) .control{background:${Ge.HighlightText};border-color:${Ge.Highlight}}:host(.checked) slot[name='checked-indicator'],:host(.checked) slot[name='indeterminate-indicator']{fill:${Ge.HighlightText}}:host(.checked:hover ) .control slot[name='checked-indicator'],:host(.checked:hover ) .control slot[name='indeterminate-indicator']{fill:${Ge.Highlight}}:host(.disabled){opacity:1}:host(.disabled) .control{border-color:${Ge.GrayText};background:${Ge.Field}}:host(.disabled) slot[name='checked-indicator'],:host(.checked.disabled:hover) .control slot[name='checked-indicator'],:host(.disabled) slot[name='indeterminate-indicator'],:host(.checked.disabled:hover) .control slot[name='indeterminate-indicator']{fill:${Ge.GrayText}}`)), yu = Li.compose({ baseName: "checkbox", template: (t, e) => _`<template role="checkbox" aria-checked="${t => t.checked}" aria-required="${t => t.required}" aria-disabled="${t => t.disabled}" aria-readonly="${t => t.readOnly}" tabindex="${t => t.disabled ? null : 0}" @keypress="${(t, e) => t.keypressHandler(e.event)}" @click="${(t, e) => t.clickHandler(e.event)}" class="${t => t.readOnly ? "readonly" : ""} ${t => t.checked ? "checked" : ""} ${t => t.indeterminate ? "indeterminate" : ""}"><div part="control" class="control"><slot name="checked-indicator">${e.checkedIndicator || ""}</slot><slot name="indeterminate-indicator">${e.indeterminateIndicator || ""}</slot></div><label part="label" class="${t => t.defaultSlottedNodes && t.defaultSlottedNodes.length ? "label" : "label label__hidden"}"><slot ${Ht("defaultSlottedNodes")}></slot></label></template>`, styles: bu, checkedIndicator: '\n    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n      <path d="M13.86 3.66a.5.5 0 01-.02.7l-7.93 7.48a.6.6 0 01-.84-.02L2.4 9.1a.5.5 0 01.72-.7l2.4 2.44 7.65-7.2a.5.5 0 01.7.02z"/>\n    </svg>\n  ', indeterminateIndicator: '\n    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n      <path d="M3 8c0-.28.22-.5.5-.5h9a.5.5 0 010 1h-9A.5.5 0 013 8z"/>\n    </svg>\n  ' }), xu = bu, $u = (t, e) => ft`
    ${rn("inline-flex")}
    
    :host{border-radius:calc(${ar} * 1px);box-sizing:border-box;color:${rc};fill:currentcolor;font-family:${dr};position:relative;user-select:none;min-width:250px;vertical-align:top}.listbox{box-shadow:${kd};background:${el};border-radius:calc(${lr} * 1px);box-sizing:border-box;display:inline-flex;flex-direction:column;left:0;max-height:calc(var(--max-height) - (${Yh} * 1px));padding:calc((${rr} - ${cr} ) * 1px);overflow-y:auto;position:absolute;width:100%;z-index:1;margin:1px 0;border:calc(${cr} * 1px) solid transparent}.listbox[hidden]{display:none}.control{border:calc(${cr} * 1px) solid transparent;border-radius:calc(${ar} * 1px);height:calc(${Yh} * 1px);align-items:center;box-sizing:border-box;cursor:pointer;display:flex;${Hh}
      min-height:100%;padding:0 calc(${rr} * 2.25px);width:100%}:host(:${an}){${Kh}}:host([disabled]) .control{cursor:${"not-allowed"};opacity:${ir};user-select:none}:host([open][position='above']) .listbox{bottom:calc((${Yh} + ${rr} * 2) * 1px)}:host([open][position='below']) .listbox{top:calc((${Yh} + ${rr} * 2) * 1px)}.selected-value{font-family:inherit;flex:1 1 auto;text-align:start}.indicator{flex:0 0 auto;margin-inline-start:1em}slot[name='listbox']{display:none;width:100%}:host([open]) slot[name='listbox']{display:flex;position:absolute}.start{margin-inline-end:11px}.end{margin-inline-start:11px}.start,.end,.indicator,::slotted(svg){display:flex}::slotted([role='option']){flex:0 0 auto}`, wu = (t, e) => $u().withBehaviors(jd("outline", Dd(0, 0, ":not([disabled]):not([open])", "[disabled]")), jd("filled", Bd(0, 0, ".control", ":not([disabled]):not([open])").withBehaviors(sn(Nd(0, 0, ".control", ":not([disabled]):not([open])")))), jd("stealth", Vd(0, 0, ":not([disabled]):not([open])", "[disabled]")), sn(ft`
    :host([open]) .listbox{background:${Ge.ButtonFace};border-color:${Ge.CanvasText}}`)), ku = (t, e) => ft`
    ${$u()}

    ${Hd()}

    :host(:empty) .listbox{display:none}:host([disabled]) *,:host([disabled]){cursor:${"not-allowed"};user-select:none}:host(:active) .selected-value{user-select:none}.selected-value{-webkit-appearance:none;background:transparent;border:none;color:inherit;${Hh}
      height:calc(100% - ${cr} * 1px));margin:auto 0;width:100%;outline:none}`.withBehaviors(jd("outline", Md(0, 0, ".control", ":not([disabled]):not([open])")), jd("filled", Bd(0, 0, ".control", ":not([disabled]):not([open])")), sn(Nd(0, 0, ".control", ":not([disabled]):not([open])"))); class Cu extends Xi { appearanceChanged(t, e) { t !== e && (this.classList.add(e), this.classList.remove(t)) } connectedCallback() { super.connectedCallback(), this.appearance || (this.appearance = "outline"), this.listbox && el.setValueFor(this.listbox, Ga) } } nd([it({ mode: "fromView" })], Cu.prototype, "appearance", void 0); const Iu = Cu.compose({ baseName: "combobox", baseClass: Xi, shadowOptions: { delegatesFocus: !0 }, template: (t, e) => _`<template aria-disabled="${t => t.ariaDisabled}" autocomplete="${t => t.autocomplete}" class="${t => t.open ? "open" : ""} ${t => t.disabled ? "disabled" : ""} ${t => t.position}" ?open="${t => t.open}" tabindex="${t => t.disabled ? null : "0"}" @click="${(t, e) => t.clickHandler(e.event)}" @focusout="${(t, e) => t.focusoutHandler(e.event)}" @keydown="${(t, e) => t.keydownHandler(e.event)}"><div class="control" part="control">${Ut(0, e)}<slot name="control"><input aria-activedescendant="${t => t.open ? t.ariaActiveDescendant : null}" aria-autocomplete="${t => t.ariaAutoComplete}" aria-controls="${t => t.ariaControls}" aria-disabled="${t => t.ariaDisabled}" aria-expanded="${t => t.ariaExpanded}" aria-haspopup="listbox" class="selected-value" part="selected-value" placeholder="${t => t.placeholder}" role="combobox" type="text" ?disabled="${t => t.disabled}" :value="${t => t.value}" @input="${(t, e) => t.inputHandler(e.event)}" @keyup="${(t, e) => t.keyupHandler(e.event)}" ${Dt("control")} /><div class="indicator" part="indicator" aria-hidden="true"><slot name="indicator">${e.indicator || ""}</slot></div></slot>${jt(0, e)}</div><div class="listbox" id="${t => t.listboxId}" part="listbox" role="listbox" ?disabled="${t => t.disabled}" ?hidden="${t => !t.open}" ${Dt("listbox")}><slot ${Ht({ filter: Mi.slottedOptionFilter, flatten: !0, property: "slottedOptions" })}></slot></div></template>`, styles: ku, indicator: '\n    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">\n      <path d="M2.15 4.65c.2-.2.5-.2.7 0L6 7.79l3.15-3.14a.5.5 0 11.7.7l-3.5 3.5a.5.5 0 01-.7 0l-3.5-3.5a.5.5 0 010-.7z"/>\n    </svg>\n  ' }), Fu = ku, Du = (t, e) => ft`
  :host{display:flex;position:relative;flex-direction:column}`, Tu = (t, e) => ft`
    :host{display:grid;padding:1px 0;box-sizing:border-box;width:100%;border-bottom:calc(${cr} * 1px) solid ${kc}}:host(.header){}:host(.sticky-header){background:${el};position:sticky;top:0}`.withBehaviors(sn(ft`
        :host{}`)), Su = (t, e) => ft`
    :host{padding:calc((${rr} + ${hr} - ${cr}) * 1px) calc(((${rr} * 3) + ${hr} - ${cr}) * 1px);color:${rc};box-sizing:border-box;${Hh}
      border:transparent calc(${cr} * 1px) solid;overflow:hidden;white-space:nowrap;border-radius:calc(${ar} * 1px)}:host(.column-header){font-weight:600}:host(:${an}){${Kh}}`.withBehaviors(sn(ft`
        :host{forced-color-adjust:none;background:${Ge.Field};color:${Ge.FieldText}}:host(:${an}){outline-color:${Ge.FieldText}}`)), Ou = Ti.compose({ baseName: "data-grid-cell", template: (t, e) => _`<template tabindex="-1" role="${t => t.cellType && "default" !== t.cellType ? t.cellType : "gridcell"}" class=" ${t => "columnheader" === t.cellType ? "column-header" : "rowheader" === t.cellType ? "row-header" : ""} "><slot></slot></template>`, styles: Su }), Eu = Su, Vu = Ci.compose({ baseName: "data-grid-row", template: (t, e) => _`<template role="row" class="${t => "default" !== t.rowType ? t.rowType : ""}" :defaultCellItemTemplate="${function (t) { const e = t.tagFor(Ti); return _`<${e} cell-type="${t => t.isRowHeader ? "rowheader" : void 0}" grid-column="${(t, e) => e.index + 1}" :rowData="${(t, e) => e.parent.rowData}" :columnDefinition="${t => t}"></${e}>` }(t)}" :defaultHeaderCellItemTemplate="${function (t) { const e = t.tagFor(Ti); return _`<${e} cell-type="columnheader" grid-column="${(t, e) => e.index + 1}" :columnDefinition="${t => t}"></${e}>` }(t)}" ${Bt({ property: "cellElements", filter: Lt('[role="cell"],[role="gridcell"],[role="columnheader"],[role="rowheader"]') })}><slot ${Ht("slottedCellElements")}></slot></template>`, styles: Tu }), Ru = Tu, Au = Ii.compose({ baseName: "data-grid", template: (t, e) => { const i = function (t) { const e = t.tagFor(Ci); return _`<${e} :rowData="${t => t}" :cellItemTemplate="${(t, e) => e.parent.cellItemTemplate}" :headerCellItemTemplate="${(t, e) => e.parent.headerCellItemTemplate}"></${e}>` }(t), o = t.tagFor(Ci); return _`<template role="grid" tabindex="0" :rowElementTag="${() => o}" :defaultRowItemTemplate="${i}" ${Bt({ property: "rowElements", filter: Lt("[role=row]") })}><slot></slot></template>` }, styles: Du }), Lu = Du, Pu = { toView(t) { var e; return null == t ? null : null === (e = t) || void 0 === e ? void 0 : e.toColorString() }, fromView(t) { if (null == t) return null; const e = Dn(t); return e ? Sn.create(e.r, e.g, e.b) : null } }, zu = ft`
  :host{background-color:${el};color:${rc}}`.withBehaviors(sn(ft`
      :host{background-color:${Ge.Canvas};box-shadow:0 0 0 1px ${Ge.CanvasText};color:${Ge.CanvasText}}`)); function Hu(t) { return (e, i) => { e[i + "Changed"] = function (e, i) { null != i ? t.setValueFor(this, i) : t.deleteValueFor(this) } } } class Mu extends Se { constructor() { super(), this.noPaint = !1; const t = { handleChange: this.noPaintChanged.bind(this) }; g.getNotifier(this).subscribe(t, "fillColor"), g.getNotifier(this).subscribe(t, "baseLayerLuminance") } connectedCallback() { super.connectedCallback(), this.noPaintChanged() } noPaintChanged() { this.noPaint || void 0 === this.fillColor && !this.baseLayerLuminance ? this.$fastController.removeStyles(zu) : this.$fastController.addStyles(zu) } } nd([it({ attribute: "no-paint", mode: "boolean" })], Mu.prototype, "noPaint", void 0), nd([it({ attribute: "fill-color", converter: Pu, mode: "fromView" }), Hu(el)], Mu.prototype, "fillColor", void 0), nd([it({ attribute: "accent-base-color", converter: Pu, mode: "fromView" }), Hu(Na)], Mu.prototype, "accentBaseColor", void 0), nd([it({ attribute: "neutral-base-color", converter: Pu, mode: "fromView" }), Hu(Ma)], Mu.prototype, "neutralBaseColor", void 0), nd([it({ converter: tt }), Hu(nr)], Mu.prototype, "density", void 0), nd([it({ attribute: "design-unit", converter: tt }), Hu(rr)], Mu.prototype, "designUnit", void 0), nd([it({ attribute: "direction" }), Hu(er)], Mu.prototype, "direction", void 0), nd([it({ attribute: "base-height-multiplier", converter: tt }), Hu(or)], Mu.prototype, "baseHeightMultiplier", void 0), nd([it({ attribute: "base-horizontal-spacing-multiplier", converter: tt }), Hu(sr)], Mu.prototype, "baseHorizontalSpacingMultiplier", void 0), nd([it({ attribute: "control-corner-radius", converter: tt }), Hu(ar)], Mu.prototype, "controlCornerRadius", void 0), nd([it({ attribute: "layer-corner-radius", converter: tt }), Hu(lr)], Mu.prototype, "layerCornerRadius", void 0), nd([it({ attribute: "stroke-width", converter: tt }), Hu(cr)], Mu.prototype, "strokeWidth", void 0), nd([it({ attribute: "focus-stroke-width", converter: tt }), Hu(hr)], Mu.prototype, "focusStrokeWidth", void 0), nd([it({ attribute: "disabled-opacity", converter: tt }), Hu(ir)], Mu.prototype, "disabledOpacity", void 0), nd([it({ attribute: "type-ramp-minus-2-font-size" }), Hu(xr)], Mu.prototype, "typeRampMinus2FontSize", void 0), nd([it({ attribute: "type-ramp-minus-2-line-height" }), Hu($r)], Mu.prototype, "typeRampMinus2LineHeight", void 0), nd([it({ attribute: "type-ramp-minus-1-font-size" }), Hu(vr)], Mu.prototype, "typeRampMinus1FontSize", void 0), nd([it({ attribute: "type-ramp-minus-1-line-height" }), Hu(br)], Mu.prototype, "typeRampMinus1LineHeight", void 0), nd([it({ attribute: "type-ramp-base-font-size" }), Hu(gr)], Mu.prototype, "typeRampBaseFontSize", void 0), nd([it({ attribute: "type-ramp-base-line-height" }), Hu(fr)], Mu.prototype, "typeRampBaseLineHeight", void 0), nd([it({ attribute: "type-ramp-plus-1-font-size" }), Hu(kr)], Mu.prototype, "typeRampPlus1FontSize", void 0), nd([it({ attribute: "type-ramp-plus-1-line-height" }), Hu(Cr)], Mu.prototype, "typeRampPlus1LineHeight", void 0), nd([it({ attribute: "type-ramp-plus-2-font-size" }), Hu(Fr)], Mu.prototype, "typeRampPlus2FontSize", void 0), nd([it({ attribute: "type-ramp-plus-2-line-height" }), Hu(Dr)], Mu.prototype, "typeRampPlus2LineHeight", void 0), nd([it({ attribute: "type-ramp-plus-3-font-size" }), Hu(Sr)], Mu.prototype, "typeRampPlus3FontSize", void 0), nd([it({ attribute: "type-ramp-plus-3-line-height" }), Hu(Or)], Mu.prototype, "typeRampPlus3LineHeight", void 0), nd([it({ attribute: "type-ramp-plus-4-font-size" }), Hu(Vr)], Mu.prototype, "typeRampPlus4FontSize", void 0), nd([it({ attribute: "type-ramp-plus-4-line-height" }), Hu(Rr)], Mu.prototype, "typeRampPlus4LineHeight", void 0), nd([it({ attribute: "type-ramp-plus-5-font-size" }), Hu(Lr)], Mu.prototype, "typeRampPlus5FontSize", void 0), nd([it({ attribute: "type-ramp-plus-5-line-height" }), Hu(Pr)], Mu.prototype, "typeRampPlus5LineHeight", void 0), nd([it({ attribute: "type-ramp-plus-6-font-size" }), Hu(Hr)], Mu.prototype, "typeRampPlus6FontSize", void 0), nd([it({ attribute: "type-ramp-plus-6-line-height" }), Hu(Mr)], Mu.prototype, "typeRampPlus6LineHeight", void 0), nd([it({ attribute: "accent-fill-rest-delta", converter: tt }), Hu(jr)], Mu.prototype, "accentFillRestDelta", void 0), nd([it({ attribute: "accent-fill-hover-delta", converter: tt }), Hu(Ur)], Mu.prototype, "accentFillHoverDelta", void 0), nd([it({ attribute: "accent-fill-active-delta", converter: tt }), Hu(qr)], Mu.prototype, "accentFillActiveDelta", void 0), nd([it({ attribute: "accent-fill-focus-delta", converter: tt }), Hu(_r)], Mu.prototype, "accentFillFocusDelta", void 0), nd([it({ attribute: "accent-foreground-rest-delta", converter: tt }), Hu(Gr)], Mu.prototype, "accentForegroundRestDelta", void 0), nd([it({ attribute: "accent-foreground-hover-delta", converter: tt }), Hu(Wr)], Mu.prototype, "accentForegroundHoverDelta", void 0), nd([it({ attribute: "accent-foreground-active-delta", converter: tt }), Hu(Kr)], Mu.prototype, "accentForegroundActiveDelta", void 0), nd([it({ attribute: "accent-foreground-focus-delta", converter: tt }), Hu(Xr)], Mu.prototype, "accentForegroundFocusDelta", void 0), nd([it({ attribute: "neutral-fill-rest-delta", converter: tt }), Hu(Yr)], Mu.prototype, "neutralFillRestDelta", void 0), nd([it({ attribute: "neutral-fill-hover-delta", converter: tt }), Hu(Qr)], Mu.prototype, "neutralFillHoverDelta", void 0), nd([it({ attribute: "neutral-fill-active-delta", converter: tt }), Hu(Zr)], Mu.prototype, "neutralFillActiveDelta", void 0), nd([it({ attribute: "neutral-fill-focus-delta", converter: tt }), Hu(Jr)], Mu.prototype, "neutralFillFocusDelta", void 0), nd([it({ attribute: "neutral-fill-input-rest-delta", converter: tt }), Hu(ta)], Mu.prototype, "neutralFillInputRestDelta", void 0), nd([it({ attribute: "neutral-fill-input-hover-delta", converter: tt }), Hu(ea)], Mu.prototype, "neutralFillInputHoverDelta", void 0), nd([it({ attribute: "neutral-fill-input-active-delta", converter: tt }), Hu(ia)], Mu.prototype, "neutralFillInputActiveDelta", void 0), nd([it({ attribute: "neutral-fill-input-focus-delta", converter: tt }), Hu(oa)], Mu.prototype, "neutralFillInputFocusDelta", void 0), nd([it({ attribute: "neutral-fill-layer-rest-delta", converter: tt }), Hu(la)], Mu.prototype, "neutralFillLayerRestDelta", void 0), nd([it({ attribute: "neutral-fill-stealth-rest-delta", converter: tt }), Hu(ma)], Mu.prototype, "neutralFillStealthRestDelta", void 0), nd([it({ attribute: "neutral-fill-stealth-hover-delta", converter: tt }), Hu(va)], Mu.prototype, "neutralFillStealthHoverDelta", void 0), nd([it({ attribute: "neutral-fill-stealth-active-delta", converter: tt }), Hu(ba)], Mu.prototype, "neutralFillStealthActiveDelta", void 0), nd([it({ attribute: "neutral-fill-stealth-focus-delta", converter: tt }), Hu(ya)], Mu.prototype, "neutralFillStealthFocusDelta", void 0), nd([it({ attribute: "neutral-fill-strong-hover-delta", converter: tt }), Hu($a)], Mu.prototype, "neutralFillStrongHoverDelta", void 0), nd([it({ attribute: "neutral-fill-strong-active-delta", converter: tt }), Hu(wa)], Mu.prototype, "neutralFillStrongActiveDelta", void 0), nd([it({ attribute: "neutral-fill-strong-focus-delta", converter: tt }), Hu(ka)], Mu.prototype, "neutralFillStrongFocusDelta", void 0), nd([it({ attribute: "base-layer-luminance", converter: tt }), Hu(Nr)], Mu.prototype, "baseLayerLuminance", void 0), nd([it({ attribute: "neutral-stroke-divider-rest-delta", converter: tt }), Hu(Va)], Mu.prototype, "neutralStrokeDividerRestDelta", void 0), nd([it({ attribute: "neutral-stroke-rest-delta", converter: tt }), Hu(Ca)], Mu.prototype, "neutralStrokeRestDelta", void 0), nd([it({ attribute: "neutral-stroke-hover-delta", converter: tt }), Hu(Ia)], Mu.prototype, "neutralStrokeHoverDelta", void 0), nd([it({ attribute: "neutral-stroke-active-delta", converter: tt }), Hu(Fa)], Mu.prototype, "neutralStrokeActiveDelta", void 0), nd([it({ attribute: "neutral-stroke-focus-delta", converter: tt }), Hu(Da)], Mu.prototype, "neutralStrokeFocusDelta", void 0); const Bu = Mu.compose({
    baseName: "design-system-provider", template: _`<slot></slot>`, styles: ft`
    ${rn("block")}
  `}), Nu = (t, e) => ft`
  :host([hidden]){display:none}:host{--dialog-height:480px;--dialog-width:640px;display:block}.overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.3);touch-action:none}.positioning-region{display:flex;justify-content:center;position:fixed;top:0;bottom:0;left:0;right:0;overflow:auto}.control{box-shadow:${Id};margin-top:auto;margin-bottom:auto;border-radius:calc(${lr} * 1px);width:var(--dialog-width);height:var(--dialog-height);background:${el};z-index:1;border:calc(${cr} * 1px) solid transparent}`, ju = Ao.compose({ baseName: "dialog", template: (t, e) => _`<div class="positioning-region" part="positioning-region">${Tt(t => t.modal, _`<div class="overlay" part="overlay" role="presentation" @click="${t => t.dismiss()}"></div>`)}<div role="dialog" tabindex="-1" class="control" part="control" aria-modal="${t => t.modal}" aria-describedby="${t => t.ariaDescribedby}" aria-labelledby="${t => t.ariaLabelledby}" aria-label="${t => t.ariaLabel}" ${Dt("dialog")}><slot></slot></div></div>`, styles: Nu }), Uu = Nu, qu = (t, e) => ft`
    ${rn("block")} :host{box-sizing:content-box;height:0;border:none;border-top:calc(${cr} * 1px) solid ${kc}}`, _u = Po.compose({ baseName: "divider", template: (t, e) => _`<template role="${t => t.role}" aria-orientation="${t => t.orientation}"></template>`, styles: qu }), Gu = qu, Wu = (t, e) => ft`
    ${rn("inline-flex")} :host{height:calc((${Yh} + ${rr}) * 1px);justify-content:center;align-items:center;fill:currentcolor;color:${ec};background:padding-box linear-gradient(${Cl},${Cl}),border-box ${bc};box-sizing:border-box;border:calc(${cr} * 1px) solid transparent;border-radius:calc(${ar} * 1px);padding:0}:host(.disabled){opacity:${ir};cursor:${"not-allowed"};pointer-events:none}.next,.previous{display:flex}:host(:not(.disabled):hover){cursor:pointer}:host(:not(.disabled):hover){color:${ic}}:host(:not(.disabled):active){color:${oc}}:host(:${an}){${Kh}}:host::-moz-focus-inner{border:0}`.withBehaviors(sn(ft`
        :host{background:${Ge.ButtonFace};border-color:${Ge.ButtonText}}:host .next,:host .previous{color:${Ge.ButtonText};fill:currentcolor}:host(:not(.disabled):hover){background:${Ge.Highlight}}:host(:not(.disabled):hover) .next,:host(:not(.disabled):hover) .previous{color:${Ge.HighlightText};fill:currentcolor}:host(.disabled){opacity:1}:host(.disabled),:host(.disabled) .next,:host(.disabled) .previous{border-color:${Ge.GrayText};color:${Ge.GrayText};fill:currentcolor}:host(:${an}){forced-color-adjust:none;outline-color:${Ge.Highlight}}`)), Ku = Mo.compose({ baseName: "flipper", template: (t, e) => _`<template role="button" aria-disabled="${t => !!t.disabled || void 0}" tabindex="${t => t.hiddenFromAT ? -1 : 0}" class="${t => t.direction} ${t => t.disabled ? "disabled" : ""}" @keyup="${(t, e) => t.keyupHandler(e.event)}">${Tt(t => t.direction === zo, _`<span part="next" class="next"><slot name="next">${e.next || ""}</slot></span>`)} ${Tt(t => t.direction === Ho, _`<span part="previous" class="previous"><slot name="previous">${e.previous || ""}</slot></span>`)}</template>`, styles: Wu, next: '\n    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n      <path d="M7.57 11.84A1 1 0 016 11.02V4.98a1 1 0 011.57-.82l3.79 2.62c.85.59.85 1.85 0 2.44l-3.79 2.62z"/>\n    </svg>\n  ', previous: '\n    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n      <path d="M9.43 11.84a1 1 0 001.57-.82V4.98a1 1 0 00-1.57-.82L5.64 6.78c-.85.59-.85 1.85 0 2.44l3.79 2.62z"/>\n    </svg>\n  ' }), Xu = Wu, Yu = ft`
  .scroll-prev{right:auto;left:0}.scroll.scroll-next::before,.scroll-next .scroll-action{left:auto;right:0}.scroll.scroll-next::before{background:linear-gradient(to right,transparent,var(--scroll-fade-next))}.scroll-next .scroll-action{transform:translate(50%,-50%)}`, Qu = ft`
  .scroll.scroll-next{right:auto;left:0}.scroll.scroll-next::before{background:linear-gradient(to right,var(--scroll-fade-next),transparent);left:auto;right:0}.scroll.scroll-prev::before{background:linear-gradient(to right,transparent,var(--scroll-fade-previous))}.scroll-prev .scroll-action{left:auto;right:0;transform:translate(50%,-50%)}`, Zu = ft`
  .scroll-area{position:relative}div.scroll-view{overflow-x:hidden}.scroll{bottom:0;pointer-events:none;position:absolute;right:0;top:0;user-select:none;width:100px}.scroll.disabled{display:none}.scroll::before,.scroll-action{left:0;position:absolute}.scroll::before{background:linear-gradient(to right,var(--scroll-fade-previous),transparent);content:'';display:block;height:100%;width:100%}.scroll-action{pointer-events:auto;right:auto;top:50%;transform:translate(-50%,-50%)}::slotted(fluent-flipper){opacity:0;transition:opacity 0.2s ease-in-out}.scroll-area:hover ::slotted(fluent-flipper){opacity:1}`.withBehaviors(new rd(Yu, Qu)), Ju = (t, e) => ft`
  ${rn("block")} :host{--scroll-align:center;--scroll-item-spacing:4px;contain:layout;position:relative}.scroll-view{overflow-x:auto;scrollbar-width:none}::-webkit-scrollbar{display:none}.content-container{align-items:var(--scroll-align);display:inline-flex;flex-wrap:nowrap;position:relative}.content-container ::slotted(*){margin-right:var(--scroll-item-spacing)}.content-container ::slotted(*:last-child){margin-right:0}`; class tp extends rs { connectedCallback() { super.connectedCallback(), "mobile" !== this.view && this.$fastController.addStyles(Zu) } } const ep = tp.compose({ baseName: "horizontal-scroll", baseClass: rs, template: (t, e) => { var i, o; return _`<template class="horizontal-scroll" @keyup="${(t, e) => t.keyupHandler(e.event)}">${Ut(0, e)}<div class="scroll-area" part="scroll-area"><div class="scroll-view" part="scroll-view" @scroll="${t => t.scrolled()}" ${Dt("scrollContainer")}><div class="content-container" part="content-container" ${Dt("content")}><slot ${Ht({ property: "scrollItems", filter: Lt() })}></slot></div></div>${Tt(t => "mobile" !== t.view, _`<div class="scroll scroll-prev" part="scroll-prev" ${Dt("previousFlipperContainer")}><div class="scroll-action" part="scroll-action-previous"><slot name="previous-flipper">${e.previousFlipper instanceof Function ? e.previousFlipper(t, e) : null !== (i = e.previousFlipper) && void 0 !== i ? i : ""}</slot></div></div><div class="scroll scroll-next" part="scroll-next" ${Dt("nextFlipperContainer")}><div class="scroll-action" part="scroll-action-next"><slot name="next-flipper">${e.nextFlipper instanceof Function ? e.nextFlipper(t, e) : null !== (o = e.nextFlipper) && void 0 !== o ? o : ""}</slot></div></div>`)}</div>${jt(0, e)}</template>` }, styles: Ju, nextFlipper: _`<fluent-flipper @click="${t => t.scrollToNext()}" aria-hidden="${t => t.flippersHiddenFromAT}"></fluent-flipper>`, previousFlipper: _`<fluent-flipper @click="${t => t.scrollToPrevious()}" direction="previous" aria-hidden="${t => t.flippersHiddenFromAT}"></fluent-flipper>` }), ip = Ju, op = (t, e) => ft`
    ${rn("inline-flex")} :host{border:calc(${cr} * 1px) solid ${pc};border-radius:calc(${ar} * 1px);box-sizing:border-box;flex-direction:column;padding:calc(${rr} * 1px) 0}::slotted(${t.tagFor(zi)}){margin:0 calc(${rr} * 1px)}:host(:focus-within:not([disabled])){${Kh}}`; class sp extends Mi { } const np = sp.compose({ baseName: "listbox", template: (t, e) => _`<template aria-activedescendant="${t => t.ariaActiveDescendant}" aria-multiselectable="${t => t.ariaMultiSelectable}" class="listbox" role="listbox" tabindex="${t => t.disabled ? null : "0"}" @click="${(t, e) => t.clickHandler(e.event)}" @focusin="${(t, e) => t.focusinHandler(e.event)}" @keydown="${(t, e) => t.keydownHandler(e.event)}" @mousedown="${(t, e) => t.mousedownHandler(e.event)}"><slot ${Ht({ filter: Bo.slottedOptionFilter, flatten: !0, property: "slottedOptions" })}></slot></template>`, styles: op }), rp = op, ap = (t, e) => ft`
    ${rn("inline-flex")} :host{position:relative;${Hh}
      background:${Yl};border-radius:calc(${ar} * 1px);border:calc(${cr} * 1px) solid transparent;box-sizing:border-box;color:${rc};cursor:pointer;fill:currentcolor;height:calc(${Yh} * 1px);overflow:hidden;align-items:center;padding:0 calc(((${rr} * 3) - ${cr} - 1) * 1px);user-select:none;white-space:nowrap}:host::before{content:'';display:block;position:absolute;left:calc((${hr} - ${cr}) * 1px);top:calc((${Yh} / 4) - ${hr} * 1px);width:3px;height:calc((${Yh} / 2) * 1px);background:transparent;border-radius:calc(${ar} * 1px)}:host(:not([disabled]):hover){background:${Ql}}:host(:not([disabled]):active){background:${Zl}}:host(:not([disabled]):active)::before{background:${sl};height:calc(((${Yh} / 2) - 6) * 1px)}:host([aria-selected='true'])::before{background:${sl}}:host(:${an}){${Kh}
      background:${Jl}}:host([aria-selected='true']){background:${_l}}:host(:not([disabled])[aria-selected='true']:hover){background:${Gl}}:host(:not([disabled])[aria-selected='true']:active){background:${Wl}}:host(:not([disabled]):not([aria-selected='true']):hover){background:${Ql}}:host(:not([disabled]):not([aria-selected='true']):active){background:${Zl}}:host([disabled]){cursor:${"not-allowed"};opacity:${ir}}.content{grid-column-start:2;justify-self:start;overflow:hidden;text-overflow:ellipsis}.start,.end,::slotted(svg){display:flex}::slotted([slot='end']){margin-inline-start:1ch}::slotted([slot='start']){margin-inline-end:1ch}`.withBehaviors(sn(ft`
        :host{background:${Ge.ButtonFace};border-color:${Ge.ButtonFace};color:${Ge.ButtonText}}:host(:not([disabled]):not([aria-selected="true"]):hover),:host(:not([disabled])[aria-selected="true"]:hover),:host([aria-selected="true"]){forced-color-adjust:none;background:${Ge.Highlight};color:${Ge.HighlightText}}:host(:not([disabled]):active)::before,:host([aria-selected='true'])::before{background:${Ge.HighlightText}}:host([disabled]),:host([disabled]:not([aria-selected='true']):hover){background:${Ge.Canvas};color:${Ge.GrayText};fill:currentcolor;opacity:1}:host(:${an}){outline-color:${Ge.CanvasText}}`)), lp = zi.compose({ baseName: "option", template: (t, e) => _`<template aria-checked="${t => t.ariaChecked}" aria-disabled="${t => t.ariaDisabled}" aria-posinset="${t => t.ariaPosInSet}" aria-selected="${t => t.ariaSelected}" aria-setsize="${t => t.ariaSetSize}" class="${t => [t.checked && "checked", t.selected && "selected", t.disabled && "disabled"].filter(Boolean).join(" ")}" role="option">${Ut(0, e)}<span class="content" part="content"><slot ${Ht("content")}></slot></span>${jt(0, e)}</template>`, styles: ap }), cp = ap, hp = (t, e) => ft`
    ${rn("block")} :host{background:${Ga};border:calc(${cr} * 1px) solid transparent;border-radius:calc(${lr} * 1px);box-shadow:${kd};padding:calc((${rr} - ${cr}) * 1px) 0;max-width:368px;min-width:64px}:host([slot='submenu']){width:max-content;margin:0 calc(${rr} * 2px)}::slotted(${t.tagFor(_o)}){margin:0 calc(${rr} * 1px)}::slotted(${t.tagFor(Po)}){margin:calc(${rr} * 1px) 0}::slotted(hr){box-sizing:content-box;height:0;margin:calc(${rr} * 1px) 0;border:none;border-top:calc(${cr} * 1px) solid ${kc}}`.withBehaviors(sn(ft`
        :host([slot='submenu']){background:${Ge.Canvas};border-color:${Ge.CanvasText}}`)); class dp extends Go { connectedCallback() { super.connectedCallback(), el.setValueFor(this, Ga) } } const up = dp.compose({ baseName: "menu", baseClass: Go, template: (t, e) => _`<template slot="${t => t.slot ? t.slot : t.isNestedMenu() ? "submenu" : void 0}" role="menu" @keydown="${(t, e) => t.handleMenuKeyDown(e.event)}" @focusout="${(t, e) => t.handleFocusOut(e.event)}"><slot ${Ht("items")}></slot></template>`, styles: hp }), pp = hp, gp = (t, e) => ft`
    ${rn("grid")} :host{contain:layout;overflow:visible;${Hh}
      box-sizing:border-box;height:calc(${Yh} * 1px);grid-template-columns:minmax(32px,auto) 1fr minmax(32px,auto);grid-template-rows:auto;justify-items:center;align-items:center;padding:0;white-space:nowrap;color:${rc};fill:currentcolor;cursor:pointer;border-radius:calc(${ar} * 1px);border:calc(${cr} * 1px) solid transparent;position:relative}:host(.indent-0){grid-template-columns:auto 1fr minmax(32px,auto)}:host(.indent-0) .content{grid-column:1;grid-row:1;margin-inline-start:10px}:host(.indent-0) .expand-collapse-glyph-container{grid-column:5;grid-row:1}:host(.indent-2){grid-template-columns:minmax(32px,auto) minmax(32px,auto) 1fr minmax(32px,auto) minmax(32px,auto)}:host(.indent-2) .content{grid-column:3;grid-row:1;margin-inline-start:10px}:host(.indent-2) .expand-collapse-glyph-container{grid-column:5;grid-row:1}:host(.indent-2) .start{grid-column:2}:host(.indent-2) .end{grid-column:4}:host(:${an}){${Kh}}:host(:not([disabled]):hover){background:${Ql}}:host(:not([disabled]):active),:host(.expanded){background:${Zl};color:${rc};z-index:2}:host([disabled]){cursor:${"not-allowed"};opacity:${ir}}.content{grid-column-start:2;justify-self:start;overflow:hidden;text-overflow:ellipsis}.start,.end{display:flex;justify-content:center}:host(.indent-0[aria-haspopup='menu']){display:grid;grid-template-columns:minmax(32px,auto) auto 1fr minmax(32px,auto) minmax(32px,auto);align-items:center;min-height:32px}:host(.indent-1[aria-haspopup='menu']),:host(.indent-1[role='menuitemcheckbox']),:host(.indent-1[role='menuitemradio']){display:grid;grid-template-columns:minmax(32px,auto) auto 1fr minmax(32px,auto) minmax(32px,auto);align-items:center;min-height:32px}:host(.indent-2:not([aria-haspopup='menu'])) .end{grid-column:5}:host .input-container,:host .expand-collapse-glyph-container{display:none}:host([aria-haspopup='menu']) .expand-collapse-glyph-container,:host([role='menuitemcheckbox']) .input-container,:host([role='menuitemradio']) .input-container{display:grid}:host([aria-haspopup='menu']) .content,:host([role='menuitemcheckbox']) .content,:host([role='menuitemradio']) .content{grid-column-start:3}:host([aria-haspopup='menu'].indent-0) .content{grid-column-start:1}:host([aria-haspopup='menu']) .end,:host([role='menuitemcheckbox']) .end,:host([role='menuitemradio']) .end{grid-column-start:4}:host .expand-collapse,:host .checkbox,:host .radio{display:flex;align-items:center;justify-content:center;position:relative;box-sizing:border-box}:host .checkbox-indicator,:host .radio-indicator,slot[name='checkbox-indicator'],slot[name='radio-indicator']{display:none}::slotted([slot='end']:not(svg)){margin-inline-end:10px;color:${dc}}:host([aria-checked='true']) .checkbox-indicator,:host([aria-checked='true']) slot[name='checkbox-indicator'],:host([aria-checked='true']) .radio-indicator,:host([aria-checked='true']) slot[name='radio-indicator']{display:flex}`.withBehaviors(sn(ft`
        :host,::slotted([slot='end']:not(svg)){forced-color-adjust:none;color:${Ge.ButtonText};fill:currentcolor}:host(:not([disabled]):hover){background:${Ge.Highlight};color:${Ge.HighlightText};fill:currentcolor}:host(:hover) .start,:host(:hover) .end,:host(:hover)::slotted(svg),:host(:active) .start,:host(:active) .end,:host(:active)::slotted(svg),:host(:hover) ::slotted([slot='end']:not(svg)),:host(:${an}) ::slotted([slot='end']:not(svg)){color:${Ge.HighlightText};fill:currentcolor}:host(.expanded){background:${Ge.Highlight};color:${Ge.HighlightText}}:host(:${an}){background:${Ge.Highlight};outline-color:${Ge.ButtonText};color:${Ge.HighlightText};fill:currentcolor}:host([disabled]),:host([disabled]:hover),:host([disabled]:hover) .start,:host([disabled]:hover) .end,:host([disabled]:hover)::slotted(svg),:host([disabled]:${an}){background:${Ge.ButtonFace};color:${Ge.GrayText};fill:currentcolor;opacity:1}:host([disabled]:${an}){outline-color:${Ge.GrayText}}:host .expanded-toggle,:host .checkbox,:host .radio{border-color:${Ge.ButtonText};background:${Ge.HighlightText}}:host([checked]) .checkbox,:host([checked]) .radio{background:${Ge.HighlightText};border-color:${Ge.HighlightText}}:host(:hover) .expanded-toggle,:host(:hover) .checkbox,:host(:hover) .radio,:host(:${an}) .expanded-toggle,:host(:${an}) .checkbox,:host(:${an}) .radio,:host([checked]:hover) .checkbox,:host([checked]:hover) .radio,:host([checked]:${an}) .checkbox,:host([checked]:${an}) .radio{border-color:${Ge.HighlightText}}:host([aria-checked='true']){background:${Ge.Highlight};color:${Ge.HighlightText}}:host([aria-checked='true']) .checkbox-indicator,:host([aria-checked='true']) ::slotted([slot='checkbox-indicator']),:host([aria-checked='true']) ::slotted([slot='radio-indicator']){fill:${Ge.Highlight}}:host([aria-checked='true']) .radio-indicator{background:${Ge.Highlight}}`), new rd(ft`
        .expand-collapse-glyph-container{transform:rotate(0deg)}`, ft`
        .expand-collapse-glyph-container{transform:rotate(180deg)}`)), fp = _o.compose({ baseName: "menu-item", template: (t, e) => _`<template role="${t => t.role}" aria-haspopup="${t => t.hasSubmenu ? "menu" : void 0}" aria-checked="${t => t.role !== No ? t.checked : void 0}" aria-disabled="${t => t.disabled}" aria-expanded="${t => t.expanded}" @keydown="${(t, e) => t.handleMenuItemKeyDown(e.event)}" @click="${(t, e) => t.handleMenuItemClick(e.event)}" @mouseover="${(t, e) => t.handleMouseOver(e.event)}" @mouseout="${(t, e) => t.handleMouseOut(e.event)}" class="${t => t.disabled ? "disabled" : ""} ${t => t.expanded ? "expanded" : ""} ${t => "indent-" + t.startColumnCount}">${Tt(t => t.role === jo, _`<div part="input-container" class="input-container"><span part="checkbox" class="checkbox"><slot name="checkbox-indicator">${e.checkboxIndicator || ""}</slot></span></div>`)} ${Tt(t => t.role === Uo, _`<div part="input-container" class="input-container"><span part="radio" class="radio"><slot name="radio-indicator">${e.radioIndicator || ""}</slot></span></div>`)}</div>${Ut(0, e)}<span class="content" part="content"><slot></slot></span>${jt(0, e)} ${Tt(t => t.hasSubmenu, _`<div part="expand-collapse-glyph-container" class="expand-collapse-glyph-container"><span part="expand-collapse" class="expand-collapse"><slot name="expand-collapse-indicator">${e.expandCollapseGlyph || ""}</slot></span></div>`)} ${Tt(t => t.expanded, _`<${t.tagFor(ei)} :anchorElement="${t => t}" vertical-positioning-mode="dynamic" vertical-default-position="bottom" vertical-inset="true" horizontal-positioning-mode="dynamic" horizontal-default-position="end" class="submenu-region" dir="${t => t.currentDirection}" @loaded="${t => t.submenuLoaded()}" ${Dt("submenuRegion")} part="submenu-region"><slot name="submenu"></slot></${t.tagFor(ei)}>`)}</template>`, styles: gp, checkboxIndicator: '\n    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n      <path d="M13.86 3.66a.5.5 0 01-.02.7l-7.93 7.48a.6.6 0 01-.84-.02L2.4 9.1a.5.5 0 01.72-.7l2.4 2.44 7.65-7.2a.5.5 0 01.7.02z"/>\n    </svg>\n  ', expandCollapseGlyph: '\n    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n      <path d="M5.65 3.15a.5.5 0 000 .7L9.79 8l-4.14 4.15a.5.5 0 00.7.7l4.5-4.5a.5.5 0 000-.7l-4.5-4.5a.5.5 0 00-.7 0z"/>\n    </svg>\n  ', radioIndicator: '\n    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n      <circle cx="8" cy="8" r="2"/>\n    </svg>\n  ' }), mp = gp, vp = (t, e) => ft`
    ${rn("inline-block")}

    ${zd(0, 0, ".root")}

    ${Hd()}

    .root{display:flex;flex-direction:row}.control{-webkit-appearance:none;color:inherit;background:transparent;border:0;height:calc(100% - 4px);margin-top:auto;margin-bottom:auto;padding:0 calc(${rr} * 2px + 1px);font-family:inherit;font-size:inherit;line-height:inherit}.start,.end{margin:auto;fill:currentcolor}.start{display:flex;margin-inline-start:11px}.end{display:flex;margin-inline-end:11px}.controls{opacity:0;position:relative;top:-1px;z-index:3}:host(:hover:not([disabled])) .controls,:host(:focus-within:not([disabled])) .controls{opacity:1}.step-up,.step-down{display:flex;padding:0 8px;cursor:pointer}.step-up{padding-top:3px}`.withBehaviors(jd("outline", Md(0, 0, ".root")), jd("filled", Bd(0, 0, ".root")), sn(Nd(0, 0, ".root"))); class bp extends ts { connectedCallback() { super.connectedCallback(), this.appearance || (this.appearance = "outline") } } nd([it], bp.prototype, "appearance", void 0); const yp = vp, xp = bp.compose({ baseName: "number-field", baseClass: ts, styles: vp, template: (t, e) => _`<template class="${t => t.readOnly ? "readonly" : ""}"><label part="label" for="control" class="${t => t.defaultSlottedNodes && t.defaultSlottedNodes.length ? "label" : "label label__hidden"}"><slot ${Ht("defaultSlottedNodes")}></slot></label><div class="root" part="root">${Ut(0, e)}<input class="control" part="control" id="control" @input="${t => t.handleTextInput()}" @change="${t => t.handleChange()}" @keydown="${(t, e) => t.handleKeyDown(e.event)}" @blur="${(t, e) => t.handleBlur()}" ?autofocus="${t => t.autofocus}" ?disabled="${t => t.disabled}" list="${t => t.list}" maxlength="${t => t.maxlength}" minlength="${t => t.minlength}" placeholder="${t => t.placeholder}" ?readonly="${t => t.readOnly}" ?required="${t => t.required}" size="${t => t.size}" type="text" inputmode="numeric" min="${t => t.min}" max="${t => t.max}" step="${t => t.step}" aria-atomic="${t => t.ariaAtomic}" aria-busy="${t => t.ariaBusy}" aria-controls="${t => t.ariaControls}" aria-current="${t => t.ariaCurrent}" aria-describedby="${t => t.ariaDescribedby}" aria-details="${t => t.ariaDetails}" aria-disabled="${t => t.ariaDisabled}" aria-errormessage="${t => t.ariaErrormessage}" aria-flowto="${t => t.ariaFlowto}" aria-haspopup="${t => t.ariaHaspopup}" aria-hidden="${t => t.ariaHidden}" aria-invalid="${t => t.ariaInvalid}" aria-keyshortcuts="${t => t.ariaKeyshortcuts}" aria-label="${t => t.ariaLabel}" aria-labelledby="${t => t.ariaLabelledby}" aria-live="${t => t.ariaLive}" aria-owns="${t => t.ariaOwns}" aria-relevant="${t => t.ariaRelevant}" aria-roledescription="${t => t.ariaRoledescription}" ${Dt("control")} />${Tt(t => !t.hideStep && !t.readOnly && !t.disabled, _`<div class="controls" part="controls"><div class="step-up" part="step-up" @click="${t => t.stepUp()}"><slot name="step-up-glyph">${e.stepUpGlyph || ""}</slot></div><div class="step-down" part="step-down" @click="${t => t.stepDown()}"><slot name="step-down-glyph">${e.stepDownGlyph || ""}</slot></div></div>`)} ${jt(0, e)}</div></template>`, shadowOptions: { delegatesFocus: !0 }, stepDownGlyph: '\n    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">\n      <path d="M2.15 4.65c.2-.2.5-.2.7 0L6 7.79l3.15-3.14a.5.5 0 11.7.7l-3.5 3.5a.5.5 0 01-.7 0l-3.5-3.5a.5.5 0 010-.7z"/>\n    </svg>\n  ', stepUpGlyph: '\n    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">\n      <path d="M2.15 7.35c.2.2.5.2.7 0L6 4.21l3.15 3.14a.5.5 0 10.7-.7l-3.5-3.5a.5.5 0 00-.7 0l-3.5 3.5a.5.5 0 000 .7z"/>\n    </svg>\n' }), $p = (t, e) => ft`
    ${rn("flex")} :host{align-items:center;height:calc((${cr} * 3) * 1px)}.progress{background-color:${Ac};border-radius:calc(${rr} * 1px);width:100%;height:calc(${cr} * 1px);display:flex;align-items:center;position:relative}.determinate{background-color:${sl};border-radius:calc(${rr} * 1px);height:calc((${cr} * 3) * 1px);transition:all 0.2s ease-in-out;display:flex}.indeterminate{height:calc((${cr} * 3) * 1px);border-radius:calc(${rr} * 1px);display:flex;width:100%;position:relative;overflow:hidden}.indeterminate-indicator-1{position:absolute;opacity:0;height:100%;background-color:${sl};border-radius:calc(${rr} * 1px);animation-timing-function:cubic-bezier(0.4,0,0.6,1);width:40%;animation:indeterminate-1 2s infinite}.indeterminate-indicator-2{position:absolute;opacity:0;height:100%;background-color:${sl};border-radius:calc(${rr} * 1px);animation-timing-function:cubic-bezier(0.4,0,0.6,1);width:60%;animation:indeterminate-2 2s infinite}:host(.paused) .indeterminate-indicator-1,:host(.paused) .indeterminate-indicator-2{animation:none;background-color:${dc};width:100%;opacity:1}:host(.paused) .determinate{background-color:${dc}}@keyframes indeterminate-1{0%{opacity:1;transform:translateX(-100%)}70%{opacity:1;transform:translateX(300%)}70.01%{opacity:0}100%{opacity:0;transform:translateX(300%)}}@keyframes indeterminate-2{0%{opacity:0;transform:translateX(-150%)}29.99%{opacity:0}30%{opacity:1;transform:translateX(-150%)}100%{transform:translateX(166.66%);opacity:1}}`.withBehaviors(sn(ft`
        .indeterminate-indicator-1,.indeterminate-indicator-2,.determinate,.progress{background-color:${Ge.ButtonText}}:host(.paused) .indeterminate-indicator-1,:host(.paused) .indeterminate-indicator-2,:host(.paused) .determinate{background-color:${Ge.GrayText}}`)); class wp extends es { } const kp = wp.compose({ baseName: "progress", template: (t, e) => _`<template role="progressbar" aria-valuenow="${t => t.value}" aria-valuemin="${t => t.min}" aria-valuemax="${t => t.max}" class="${t => t.paused ? "paused" : ""}">${Tt(t => "number" == typeof t.value, _`<div class="progress" part="progress" slot="determinate"><div class="determinate" part="determinate" style="width: ${t => t.percentComplete}%"></div></div>`)} ${Tt(t => "number" != typeof t.value, _`<div class="progress" part="progress" slot="indeterminate"><slot class="indeterminate" name="indeterminate">${e.indeterminateIndicator1 || ""} ${e.indeterminateIndicator2 || ""}</slot></div>`)}</template>`, styles: $p, indeterminateIndicator1: '\n    <span class="indeterminate-indicator-1" part="indeterminate-indicator-1"></span>\n  ', indeterminateIndicator2: '\n    <span class="indeterminate-indicator-2" part="indeterminate-indicator-2"></span>\n  ' }), Cp = $p, Ip = (t, e) => ft`
    ${rn("flex")} :host{align-items:center;height:calc(${Yh} * 1px);width:calc(${Yh} * 1px)}.progress{height:100%;width:100%}.background{fill:none;stroke-width:2px}.determinate{stroke:${sl};fill:none;stroke-width:2px;stroke-linecap:round;transform-origin:50% 50%;transform:rotate(-90deg);transition:all 0.2s ease-in-out}.indeterminate-indicator-1{stroke:${sl};fill:none;stroke-width:2px;stroke-linecap:round;transform-origin:50% 50%;transform:rotate(-90deg);transition:all 0.2s ease-in-out;animation:spin-infinite 2s linear infinite}:host(.paused) .indeterminate-indicator-1{animation:none;stroke:${dc}}:host(.paused) .determinate{stroke:${dc}}@keyframes spin-infinite{0%{stroke-dasharray:0.01px 43.97px;transform:rotate(0deg)}50%{stroke-dasharray:21.99px 21.99px;transform:rotate(450deg)}100%{stroke-dasharray:0.01px 43.97px;transform:rotate(1080deg)}}`.withBehaviors(sn(ft`
        .background{stroke:${Ge.Field}}.determinate,.indeterminate-indicator-1{stroke:${Ge.ButtonText}}:host(.paused) .determinate,:host(.paused) .indeterminate-indicator-1{stroke:${Ge.GrayText}}`)); class Fp extends es { } const Dp = Fp.compose({ baseName: "progress-ring", template: (t, e) => _`<template role="progressbar" aria-valuenow="${t => t.value}" aria-valuemin="${t => t.min}" aria-valuemax="${t => t.max}" class="${t => t.paused ? "paused" : ""}">${Tt(t => "number" == typeof t.value, _`<svg class="progress" part="progress" viewBox="0 0 16 16" slot="determinate"><circle class="background" part="background" cx="8px" cy="8px" r="7px"></circle><circle class="determinate" part="determinate" style="stroke-dasharray: ${t => 44 * t.percentComplete / 100}px ${44}px" cx="8px" cy="8px" r="7px"></circle></svg>`)} ${Tt(t => "number" != typeof t.value, _`<slot name="indeterminate" slot="indeterminate">${e.indeterminateIndicator || ""}</slot>`)}</template>`, styles: Ip, indeterminateIndicator: '\n    <svg class="progress" part="progress" viewBox="0 0 16 16">\n        <circle\n            class="background"\n            part="background"\n            cx="8px"\n            cy="8px"\n            r="7px"\n        ></circle>\n        <circle\n            class="indeterminate-indicator-1"\n            part="indeterminate-indicator-1"\n            cx="8px"\n            cy="8px"\n            r="7px"\n        ></circle>\n    </svg>\n  ' }), Tp = Ip, Sp = (t, e) => ft`
    ${rn("inline-flex")} :host{--input-size:calc((${Yh} / 2) + ${rr});align-items:center;outline:none;${""} user-select:none;position:relative;flex-direction:row;transition:all 0.2s ease-in-out}.control{position:relative;width:calc(var(--input-size) * 1px);height:calc(var(--input-size) * 1px);box-sizing:border-box;border-radius:50%;border:calc(${cr} * 1px) solid ${Ac};background:${Al};cursor:pointer}.label__hidden{display:none;visibility:hidden}.label{${Hh}
      color:${rc};${""} padding-inline-start:calc(${rr} * 2px + 2px);margin-inline-end:calc(${rr} * 2px + 2px);cursor:pointer}.control,slot[name='checked-indicator']{flex-shrink:0}slot[name='checked-indicator']{display:flex;align-items:center;justify-content:center;width:100%;height:100%;fill:${cl};opacity:0;pointer-events:none}:host(:not(.disabled):hover) .control{background:${Ll};border-color:${Lc}}:host(:not(.disabled):active) .control{background:${Pl};border-color:${Pc}}:host(:not(.disabled):active) slot[name='checked-indicator']{opacity:1}:host(:${an}) .control{${Xh}
      background:${zl}}:host(.checked) .control{background:${sl};border-color:transparent}:host(.checked:not(.disabled):hover) .control{background:${nl};border-color:transparent}:host(.checked:not(.disabled):active) .control{background:${rl};border-color:transparent}:host(.disabled) .label,:host(.readonly) .label,:host(.readonly) .control,:host(.disabled) .control{cursor:${"not-allowed"}}:host(.checked) slot[name='checked-indicator']{opacity:1}:host(.disabled){opacity:${ir}}`.withBehaviors(sn(ft`
        .control{background:${Ge.Field};border-color:${Ge.FieldText}}:host(:not(.disabled):hover) .control,:host(:not(.disabled):active) .control{border-color:${Ge.Highlight}}:host(:${an}) .control{forced-color-adjust:none;background:${Ge.Field};outline-color:${Ge.FieldText}}:host(.checked:not(.disabled):hover) .control,:host(.checked:not(.disabled):active) .control{border-color:${Ge.Highlight};background:${Ge.Highlight}}:host(.checked) slot[name='checked-indicator']{fill:${Ge.Highlight}}:host(.checked:hover) .control slot[name='checked-indicator']{fill:${Ge.HighlightText}}:host(.disabled){opacity:1}:host(.disabled) .label{color:${Ge.GrayText}}:host(.disabled) .control,:host(.checked.disabled) .control{background:${Ge.Field};border-color:${Ge.GrayText}}:host(.disabled) slot[name='checked-indicator'],:host(.checked.disabled) slot[name='checked-indicator']{fill:${Ge.GrayText}}`)), Op = ns.compose({ baseName: "radio", template: (t, e) => _`<template role="radio" class="${t => t.checked ? "checked" : ""} ${t => t.readOnly ? "readonly" : ""}" aria-checked="${t => t.checked}" aria-required="${t => t.required}" aria-disabled="${t => t.disabled}" aria-readonly="${t => t.readOnly}" @keypress="${(t, e) => t.keypressHandler(e.event)}" @click="${(t, e) => t.clickHandler(e.event)}"><div part="control" class="control"><slot name="checked-indicator">${e.checkedIndicator || ""}</slot></div><label part="label" class="${t => t.defaultSlottedNodes && t.defaultSlottedNodes.length ? "label" : "label label__hidden"}"><slot ${Ht("defaultSlottedNodes")}></slot></label></template>`, styles: Sp, checkedIndicator: '\n    <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg">\n      <circle cx="8" cy="8" r="4"/>\n    </svg>\n  ' }), Ep = Sp, Vp = (t, e) => ft`
  ${rn("flex")} :host{align-items:flex-start;flex-direction:column}.positioning-region{display:flex;flex-wrap:wrap}:host([orientation='vertical']) .positioning-region{flex-direction:column}:host([orientation='horizontal']) .positioning-region{flex-direction:row}`, Rp = is.compose({ baseName: "radio-group", template: (t, e) => _`<template role="radiogroup" aria-disabled="${t => t.disabled}" aria-readonly="${t => t.readOnly}" @click="${(t, e) => t.clickHandler(e.event)}" @keydown="${(t, e) => t.keydownHandler(e.event)}" @focusout="${(t, e) => t.focusOutHandler(e.event)}"><slot name="label"></slot><div class="positioning-region ${t => t.orientation === Ae ? "horizontal" : "vertical"}" part="positioning-region"><slot ${Ht({ property: "slottedRadioButtons", filter: Lt("[role=radio]") })}></slot></div></template>`, styles: Vp }), Ap = Vp, Lp = (t, e) => _`<template class=" ${t => t.readOnly ? "readonly" : ""} "><label part="label" for="control" class="${t => t.defaultSlottedNodes && t.defaultSlottedNodes.length ? "label" : "label label__hidden"}"><slot ${Ht({ property: "defaultSlottedNodes", filter: as })}></slot></label><div class="root" part="root" ${Dt("root")}>${Ut(0, e)}<div class="input-wrapper" part="input-wrapper"><input class="control" part="control" id="control" @input="${t => t.handleTextInput()}" @change="${t => t.handleChange()}" ?autofocus="${t => t.autofocus}" ?disabled="${t => t.disabled}" list="${t => t.list}" maxlength="${t => t.maxlength}" minlength="${t => t.minlength}" pattern="${t => t.pattern}" placeholder="${t => t.placeholder}" ?readonly="${t => t.readOnly}" ?required="${t => t.required}" size="${t => t.size}" ?spellcheck="${t => t.spellcheck}" :value="${t => t.value}" type="search" aria-atomic="${t => t.ariaAtomic}" aria-busy="${t => t.ariaBusy}" aria-controls="${t => t.ariaControls}" aria-current="${t => t.ariaCurrent}" aria-describedby="${t => t.ariaDescribedby}" aria-details="${t => t.ariaDetails}" aria-disabled="${t => t.ariaDisabled}" aria-errormessage="${t => t.ariaErrormessage}" aria-flowto="${t => t.ariaFlowto}" aria-haspopup="${t => t.ariaHaspopup}" aria-hidden="${t => t.ariaHidden}" aria-invalid="${t => t.ariaInvalid}" aria-keyshortcuts="${t => t.ariaKeyshortcuts}" aria-label="${t => t.ariaLabel}" aria-labelledby="${t => t.ariaLabelledby}" aria-live="${t => t.ariaLive}" aria-owns="${t => t.ariaOwns}" aria-relevant="${t => t.ariaRelevant}" aria-roledescription="${t => t.ariaRoledescription}" ${Dt("control")} /><slot name="clear-button"><button class="clear-button ${t => t.value ? "" : "clear-button__hidden"}" part="clear-button" tabindex="-1" @click=${t => t.handleClearInput()}><slot name="clear-glyph"><svg width="12" height="12" viewBox="0 0 12 12" xmlns="http://www.w3.org/2000/svg"><path d="m2.09 2.22.06-.07a.5.5 0 0 1 .63-.06l.07.06L6 5.29l3.15-3.14a.5.5 0 1 1 .7.7L6.71 6l3.14 3.15c.18.17.2.44.06.63l-.06.07a.5.5 0 0 1-.63.06l-.07-.06L6 6.71 2.85 9.85a.5.5 0 0 1-.7-.7L5.29 6 2.15 2.85a.5.5 0 0 1-.06-.63l.06-.07-.06.07Z" /></svg></slot></button></slot></div>${jt(0, e)}</div></template>`, Pp = fo.create("clear-button-hover").withDefault(t => { const e = Xl.getValueFor(t), i = Tl.getValueFor(t); return e.evaluate(t, i.evaluate(t).focus).hover }), zp = fo.create("clear-button-active").withDefault(t => { const e = Xl.getValueFor(t), i = Tl.getValueFor(t); return e.evaluate(t, i.evaluate(t).focus).active }), Hp = (t, e) => ft`
    ${rn("inline-block")}

    ${zd(0, 0, ".root")}

    ${Hd()}

    .root{display:flex;flex-direction:row}.control{-webkit-appearance:none;color:inherit;background:transparent;border:0;height:calc(100% - 4px);margin-top:auto;margin-bottom:auto;padding:0 calc(${rr} * 2px + 1px);font-family:inherit;font-size:inherit;line-height:inherit}.clear-button{display:inline-flex;align-items:center;margin:1px;height:calc(100% - 2px);opacity:0;background:transparent;color:${rc};fill:currentcolor;border:none;border-radius:calc(${ar} * 1px);min-width:calc(${Yh} * 1px);${Hh}
      outline:none;padding:0 calc((10 + (${rr} * 2 * ${nr})) * 1px)}.clear-button:hover{background:${Pp}}.clear-button:active{background:${zp}}:host(:hover:not([disabled],[readOnly])) .clear-button,:host(:active:not([disabled],[readOnly])) .clear-button,:host(:focus-within:not([disabled],[readOnly])) .clear-button{opacity:1}:host(:hover:not([disabled],[readOnly])) .clear-button__hidden,:host(:active:not([disabled],[readOnly])) .clear-button__hidden,:host(:focus-within:not([disabled],[readOnly])) .clear-button__hidden{opacity:0}.control::-webkit-search-cancel-button{-webkit-appearance:none}.input-wrapper{display:flex;position:relative;width:100%}.start,.end{display:flex;margin:1px;align-items:center}.start{display:flex;margin-inline-start:11px}::slotted([slot="end"]){height:100%}.clear-button__hidden{opacity:0}.end{margin-inline-end:11px}::slotted(${t.tagFor(di)}){margin-inline-end:1px}`.withBehaviors(jd("outline", Md(0, 0, ".root")), jd("filled", Bd(0, 0, ".root")), sn(Nd(0, 0, ".root"))); class Mp extends hs { constructor() { super(...arguments), this.appearance = "outline" } } nd([it], Mp.prototype, "appearance", void 0); const Bp = Mp.compose({ baseName: "search", baseClass: hs, template: Lp, styles: Hp, start: '<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg%22%3E"><path d="M8.5 3a5.5 5.5 0 0 1 4.23 9.02l4.12 4.13a.5.5 0 0 1-.63.76l-.07-.06-4.13-4.12A5.5 5.5 0 1 1 8.5 3Zm0 1a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9Z"/></svg>', shadowOptions: { delegatesFocus: !0 } }), Np = Hp; class jp extends gs { appearanceChanged(t, e) { t !== e && (this.classList.add(e), this.classList.remove(t)) } connectedCallback() { super.connectedCallback(), this.appearance || (this.appearance = "outline"), this.listbox && el.setValueFor(this.listbox, Ga) } } nd([it({ mode: "fromView" })], jp.prototype, "appearance", void 0); const Up = jp.compose({ baseName: "select", baseClass: gs, template: (t, e) => _`<template class="${t => [t.collapsible && "collapsible", t.collapsible && t.open && "open", t.disabled && "disabled", t.collapsible && t.position].filter(Boolean).join(" ")}" aria-activedescendant="${t => t.ariaActiveDescendant}" aria-controls="${t => t.ariaControls}" aria-disabled="${t => t.ariaDisabled}" aria-expanded="${t => t.ariaExpanded}" aria-haspopup="${t => t.collapsible ? "listbox" : null}" aria-multiselectable="${t => t.ariaMultiSelectable}" ?open="${t => t.open}" role="combobox" tabindex="${t => t.disabled ? null : "0"}" @click="${(t, e) => t.clickHandler(e.event)}" @focusin="${(t, e) => t.focusinHandler(e.event)}" @focusout="${(t, e) => t.focusoutHandler(e.event)}" @keydown="${(t, e) => t.keydownHandler(e.event)}" @mousedown="${(t, e) => t.mousedownHandler(e.event)}">${Tt(t => t.collapsible, _`<div class="control" part="control" ?disabled="${t => t.disabled}" ${Dt("control")}>${Ut(0, e)}<slot name="button-container"><div class="selected-value" part="selected-value"><slot name="selected-value">${t => t.displayValue}</slot></div><div aria-hidden="true" class="indicator" part="indicator"><slot name="indicator">${e.indicator || ""}</slot></div></slot>${jt(0, e)}</div>`)}<div class="listbox" id="${t => t.listboxId}" part="listbox" role="listbox" ?disabled="${t => t.disabled}" ?hidden="${t => !!t.collapsible && !t.open}" ${Dt("listbox")}><slot ${Ht({ filter: Mi.slottedOptionFilter, flatten: !0, property: "slottedOptions" })}></slot></div></template>`, styles: wu, indicator: '\n    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">\n      <path d="M2.15 4.65c.2-.2.5-.2.7 0L6 7.79l3.15-3.14a.5.5 0 11.7.7l-3.5 3.5a.5.5 0 01-.7 0l-3.5-3.5a.5.5 0 010-.7z"/>\n    </svg>\n  ' }), qp = wu, _p = (t, e) => ft`
    ${rn("block")} :host{--skeleton-fill-default:${_l};overflow:hidden;width:100%;position:relative;background-color:var(--skeleton-fill,var(--skeleton-fill-default));--skeleton-animation-gradient-default:linear-gradient(
        270deg,var(--skeleton-fill,var(--skeleton-fill-default)) 0%,${Gl} 51%,var(--skeleton-fill,var(--skeleton-fill-default)) 100%
      );--skeleton-animation-timing-default:ease-in-out}:host(.rect){border-radius:calc(${ar} * 1px)}:host(.circle){border-radius:100%;overflow:hidden}object{position:absolute;width:100%;height:auto;z-index:2}object img{width:100%;height:auto}${rn("block")} span.shimmer{position:absolute;width:100%;height:100%;background-image:var(--skeleton-animation-gradient,var(--skeleton-animation-gradient-default));background-size:0px 0px / 90% 100%;background-repeat:no-repeat;background-color:var(--skeleton-animation-fill,${_l});animation:shimmer 2s infinite;animation-timing-function:var(--skeleton-animation-timing,var(--skeleton-timing-default));animation-direction:normal;z-index:1}::slotted(svg){z-index:2}::slotted(.pattern){width:100%;height:100%}@keyframes shimmer{0%{transform:translateX(-100%)}100%{transform:translateX(100%)}}`.withBehaviors(sn(ft`
        :host{background-color:${Ge.CanvasText}}`)), Gp = ms.compose({ baseName: "skeleton", template: (t, e) => _`<template class="${t => "circle" === t.shape ? "circle" : "rect"}" pattern="${t => t.pattern}" ?shimmer="${t => t.shimmer}">${Tt(t => !0 === t.shimmer, _`<span class="shimmer"></span>`)}<object type="image/svg+xml" data="${t => t.pattern}" role="presentation"><img class="pattern" src="${t => t.pattern}" /></object><slot></slot></template>`, styles: _p }), Wp = _p, Kp = (t, e) => ft`
    ${rn("inline-grid")} :host{--thumb-size:calc((${Yh} / 2) + ${rr} + (${cr} * 2));--thumb-translate:calc(var(--thumb-size) * -0.5 + var(--track-width) / 2);--track-overhang:calc((${rr} / 2) * -1);--track-width:${rr};align-items:center;width:100%;user-select:none;box-sizing:border-box;border-radius:calc(${ar} * 1px);outline:none;cursor:pointer}:host(.horizontal) .positioning-region{position:relative;margin:0 8px;display:grid;grid-template-rows:calc(var(--thumb-size) * 1px) 1fr}:host(.vertical) .positioning-region{position:relative;margin:0 8px;display:grid;height:100%;grid-template-columns:calc(var(--thumb-size) * 1px) 1fr}:host(:${an}) .thumb-cursor{box-shadow:0 0 0 2px ${el},0 0 0 4px ${Mc}}.thumb-container{position:absolute;height:calc(var(--thumb-size) * 1px);width:calc(var(--thumb-size) * 1px);transition:all 0.2s ease}.thumb-cursor{display:flex;position:relative;border:none;width:calc(var(--thumb-size) * 1px);height:calc(var(--thumb-size) * 1px);background:padding-box linear-gradient(${Cl},${Cl}),border-box ${bc};border:calc(${cr} * 1px) solid transparent;border-radius:50%;box-sizing:border-box}.thumb-cursor::after{content:'';display:block;border-radius:50%;width:100%;margin:4px;background:${sl}}:host(:not(.disabled)) .thumb-cursor:hover::after{background:${nl};margin:3px}:host(:not(.disabled)) .thumb-cursor:active::after{background:${rl};margin:5px}:host(:not(.disabled)) .thumb-cursor:hover{background:padding-box linear-gradient(${Cl},${Cl}),border-box ${yc}}:host(:not(.disabled)) .thumb-cursor:active{background:padding-box linear-gradient(${Cl},${Cl}),border-box ${xc}}.track-start{background:${sl};position:absolute;height:100%;left:0;border-radius:calc(${ar} * 1px)}:host(.horizontal) .thumb-container{transform:translateX(calc(var(--thumb-size) * 0.5px)) translateY(calc(var(--thumb-translate) * 1px))}:host(.vertical) .thumb-container{transform:translateX(calc(var(--thumb-translate) * 1px)) translateY(calc(var(--thumb-size) * 0.5px))}:host(.horizontal){min-width:calc(var(--thumb-size) * 1px)}:host(.horizontal) .track{right:calc(var(--track-overhang) * 1px);left:calc(var(--track-overhang) * 1px);align-self:start;height:calc(var(--track-width) * 1px)}:host(.vertical) .track{top:calc(var(--track-overhang) * 1px);bottom:calc(var(--track-overhang) * 1px);width:calc(var(--track-width) * 1px);height:100%}.track{background:${ec};border:1px solid ${Ac};border-radius:2px;box-sizing:border-box;position:absolute}:host(.vertical){height:100%;min-height:calc(${rr} * 60px);min-width:calc(${rr} * 20px)}:host(.vertical) .track-start{height:auto;width:100%;top:0}:host(.disabled),:host(.readonly){cursor:${"not-allowed"}}:host(.disabled){opacity:${ir}}`.withBehaviors(sn(ft`
        .thumb-cursor{forced-color-adjust:none;border-color:${Ge.FieldText};background:${Ge.FieldText}}:host(:not(.disabled)) .thumb-cursor:hover,:host(:not(.disabled)) .thumb-cursor:active{background:${Ge.Highlight}}.track{forced-color-adjust:none;background:${Ge.FieldText}}.thumb-cursor::after,:host(:not(.disabled)) .thumb-cursor:hover::after,:host(:not(.disabled)) .thumb-cursor:active::after{background:${Ge.Field}}:host(:${an}) .thumb-cursor{background:${Ge.Highlight};border-color:${Ge.Highlight};box-shadow:0 0 0 1px ${Ge.Field},0 0 0 3px ${Ge.FieldText}}:host(.disabled){opacity:1}:host(.disabled) .track,:host(.disabled) .thumb-cursor{forced-color-adjust:none;background:${Ge.GrayText}}`)), Xp = ks.compose({ baseName: "slider", template: (t, e) => _`<template role="slider" class="${t => t.readOnly ? "readonly" : ""} ${t => t.orientation || Ae}" tabindex="${t => t.disabled ? null : 0}" aria-valuetext="${t => t.valueTextFormatter(t.value)}" aria-valuenow="${t => t.value}" aria-valuemin="${t => t.min}" aria-valuemax="${t => t.max}" aria-disabled="${t => !!t.disabled || void 0}" aria-readonly="${t => !!t.readOnly || void 0}" aria-orientation="${t => t.orientation}" class="${t => t.orientation}"><div part="positioning-region" class="positioning-region"><div ${Dt("track")} part="track-container" class="track"><slot name="track"></slot><div part="track-start" class="track-start" style="${t => t.position}"><slot name="track-start"></slot></div></div><slot></slot><div ${Dt("thumb")} part="thumb-container" class="thumb-container" style="${t => t.position}"><slot name="thumb">${e.thumb || ""}</slot></div></div></template>`, styles: Kp, thumb: '\n    <div class="thumb-cursor"></div>\n  ' }), Yp = Kp, Qp = (t, e) => ft`
    ${rn("block")} :host{${Mh}}.root{position:absolute;display:grid}:host(.horizontal){align-self:start;grid-row:2;margin-top:-4px}:host(.vertical){justify-self:start;grid-column:2;margin-left:2px}.container{display:grid;justify-self:center}:host(.horizontal) .container{grid-template-rows:auto auto;grid-template-columns:0}:host(.vertical) .container{grid-template-columns:auto auto;grid-template-rows:0;min-width:calc(var(--thumb-size) * 1px);height:calc(var(--thumb-size) * 1px)}.label{justify-self:center;align-self:center;white-space:nowrap;max-width:30px;margin:2px 0}.mark{width:calc(${cr} * 1px);height:calc(${rr} * 1px);background:${Ac};justify-self:center}:host(.vertical) .mark{transform:rotate(90deg);align-self:center}:host(.vertical) .label{margin-left:calc((${rr} / 2) * 2px);align-self:center}:host(.disabled){opacity:${ir}}`.withBehaviors(sn(ft`
        .mark{forced-color-adjust:none;background:${Ge.FieldText}}:host(.disabled){forced-color-adjust:none;opacity:1}:host(.disabled) .label{color:${Ge.GrayText}}:host(.disabled) .mark{background:${Ge.GrayText}}`)), Zp = ys.compose({ baseName: "slider-label", template: (t, e) => _`<template aria-disabled="${t => t.disabled}" class="${t => t.sliderOrientation || Ae} ${t => t.disabled ? "disabled" : ""}"><div ${Dt("root")} part="root" class="root" style="${t => t.positionStyle}"><div class="container">${Tt(t => !t.hideMark, _`<div class="mark"></div>`)}<div class="label"><slot></slot></div></div></div></template>`, styles: Qp }), Jp = Qp, tg = (t, e) => ft`
    :host([hidden]){display:none}${rn("inline-flex")} :host{align-items:center;outline:none;font-family:${dr};${""} user-select:none}:host(.disabled){opacity:${ir}}:host(.disabled) .label,:host(.readonly) .label,:host(.disabled) .switch,:host(.readonly) .switch,:host(.disabled) .status-message,:host(.readonly) .status-message{cursor:${"not-allowed"}}.switch{position:relative;box-sizing:border-box;width:calc(((${Yh} / 2) + ${rr}) * 2px);height:calc(((${Yh} / 2) + ${rr}) * 1px);background:${Al};border-radius:calc(${Yh} * 1px);border:calc(${cr} * 1px) solid ${Ac};cursor:pointer}:host(:not(.disabled):hover) .switch{background:${Ll};border-color:${Lc}}:host(:not(.disabled):active) .switch{background:${Pl};border-color:${Pc}}:host(:${an}) .switch{${Xh}
      background:${zl}}:host(.checked) .switch{background:${sl};border-color:transparent}:host(.checked:not(.disabled):hover) .switch{background:${nl};border-color:transparent}:host(.checked:not(.disabled):active) .switch{background:${rl};border-color:transparent}slot[name='switch']{position:absolute;display:flex;border:1px solid transparent;fill:${rc};transition:all 0.2s ease-in-out}.status-message{color:${rc};cursor:pointer;${Hh}}.label__hidden{display:none;visibility:hidden}.label{color:${rc};${Hh}
      margin-inline-end:calc(${rr} * 2px + 2px);cursor:pointer}::slotted([slot="checked-message"]),::slotted([slot="unchecked-message"]){margin-inline-start:calc(${rr} * 2px + 2px)}:host(.checked) .switch{background:${sl}}:host(.checked) .switch slot[name='switch']{fill:${cl};filter:drop-shadow(0px 1px 1px rgba(0,0,0,0.15))}:host(.checked:not(.disabled)) .switch:hover{background:${nl}}:host(.checked:not(.disabled)) .switch:hover slot[name='switch']{fill:${hl}}:host(.checked:not(.disabled)) .switch:active{background:${rl}}:host(.checked:not(.disabled)) .switch:active slot[name='switch']{fill:${dl}}.unchecked-message{display:block}.checked-message{display:none}:host(.checked) .unchecked-message{display:none}:host(.checked) .checked-message{display:block}`.withBehaviors(new rd(ft`
        slot[name='switch']{left:0}:host(.checked) slot[name='switch']{left:100%;transform:translateX(-100%)}`, ft`
        slot[name='switch']{right:0}:host(.checked) slot[name='switch']{right:100%;transform:translateX(100%)}`), sn(ft`
        :host(:not(.disabled)) .switch slot[name='switch']{forced-color-adjust:none;fill:${Ge.FieldText}}.switch{background:${Ge.Field};border-color:${Ge.FieldText}}:host(.checked) .switch{background:${Ge.Highlight};border-color:${Ge.Highlight}}:host(:not(.disabled):hover) .switch,:host(:not(.disabled):active) .switch,:host(.checked:not(.disabled):hover) .switch{background:${Ge.HighlightText};border-color:${Ge.Highlight}}:host(.checked:not(.disabled)) .switch slot[name="switch"]{fill:${Ge.HighlightText}}:host(.checked:not(.disabled):hover) .switch slot[name='switch']{fill:${Ge.Highlight}}:host(:${an}) .switch{forced-color-adjust:none;background:${Ge.Field};border-color:${Ge.Highlight};outline-color:${Ge.FieldText}}:host(.disabled){opacity:1}:host(.disabled) slot[name='switch']{forced-color-adjust:none;fill:${Ge.GrayText}}:host(.disabled) .switch{background:${Ge.Field};border-color:${Ge.GrayText}}.status-message,.label{color:${Ge.FieldText}}`)), eg = Fs.compose({ baseName: "switch", template: (t, e) => _`<template role="switch" aria-checked="${t => t.checked}" aria-disabled="${t => t.disabled}" aria-readonly="${t => t.readOnly}" tabindex="${t => t.disabled ? null : 0}" @keypress="${(t, e) => t.keypressHandler(e.event)}" @click="${(t, e) => t.clickHandler(e.event)}" class="${t => t.checked ? "checked" : ""}"><label part="label" class="${t => t.defaultSlottedNodes && t.defaultSlottedNodes.length ? "label" : "label label__hidden"}"><slot ${Ht("defaultSlottedNodes")}></slot></label><div part="switch" class="switch"><slot name="switch">${e.switch || ""}</slot></div><span class="status-message" part="status-message"><span class="checked-message" part="checked-message"><slot name="checked-message"></slot></span><span class="unchecked-message" part="unchecked-message"><slot name="unchecked-message"></slot></span></span></template>`, styles: tg, switch: '\n    <svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">\n      <rect x="2" y="2" width="12" height="12" rx="6"/>\n    </svg>\n  ' }), ig = tg, og = (t, e) => ft`
      ${rn("grid")} :host{box-sizing:border-box;${Hh}
        color:${rc};grid-template-columns:auto 1fr auto;grid-template-rows:auto 1fr}.tablist{display:grid;grid-template-rows:calc(${Yh} * 1px);auto;grid-template-columns:auto;position:relative;width:max-content;align-self:end}.start,.end{align-self:center}.activeIndicator{grid-row:2;grid-column:1;width:20px;height:3px;border-radius:calc(${ar} * 1px);justify-self:center;background:${sl}}.activeIndicatorTransition{transition:transform 0.2s ease-in-out}.tabpanel{grid-row:2;grid-column-start:1;grid-column-end:4;position:relative}:host(.vertical){grid-template-rows:auto 1fr auto;grid-template-columns:auto 1fr}:host(.vertical) .tablist{grid-row-start:2;grid-row-end:2;display:grid;grid-template-rows:auto;grid-template-columns:auto 1fr;position:relative;width:max-content;justify-self:end;align-self:flex-start;width:100%}:host(.vertical) .tabpanel{grid-column:2;grid-row-start:1;grid-row-end:4}:host(.vertical) .end{grid-row:3}:host(.vertical) .activeIndicator{grid-column:1;grid-row:1;width:3px;height:20px;margin-inline-start:calc(${hr} * 1px);border-radius:calc(${ar} * 1px);align-self:center;background:${sl}}:host(.vertical) .activeIndicatorTransition{transition:transform 0.2s linear}`.withBehaviors(sn(ft`
        .activeIndicator,:host(.vertical) .activeIndicator{background:${Ge.Highlight}}`)), sg = (t, e) => ft`
      ${rn("inline-flex")} :host{box-sizing:border-box;${Hh}
        height:calc((${Yh} + (${rr} * 2)) * 1px);padding:0 calc((6 + (${rr} * 2 * ${nr})) * 1px);color:${rc};border-radius:calc(${ar} * 1px);border:calc(${cr} * 1px) solid transparent;align-items:center;justify-content:center;grid-row:1 / 3;cursor:pointer}:host([aria-selected='true']){z-index:2}:host(:hover),:host(:active){color:${rc}}:host(:${an}){${Kh}}:host(.vertical){justify-content:start;grid-column:1 / 3}:host(.vertical[aria-selected='true']){z-index:2}:host(.vertical:hover),:host(.vertical:active){color:${rc}}:host(.vertical:hover[aria-selected='true']){}`.withBehaviors(sn(ft`
          :host{forced-color-adjust:none;border-color:transparent;color:${Ge.ButtonText};fill:currentcolor}:host(:hover),:host(.vertical:hover),:host([aria-selected='true']:hover){background:transparent;color:${Ge.Highlight};fill:currentcolor}:host([aria-selected='true']){background:transparent;color:${Ge.Highlight};fill:currentcolor}:host(:${an}){background:transparent;outline-color:${Ge.ButtonText}}`)), ng = Ts.compose({ baseName: "tab", template: (t, e) => _`<template slot="tab" role="tab" aria-disabled="${t => t.disabled}"><slot></slot></template>`, styles: sg }), rg = sg, ag = (t, e) => ft`
  ${rn("block")} :host{box-sizing:border-box;${Hh}
    padding:0 calc((6 + (${rr} * 2 * ${nr})) * 1px)}`, lg = Ds.compose({ baseName: "tab-panel", template: (t, e) => _`<template slot="tabpanel" role="tabpanel"><slot></slot></template>`, styles: ag }), cg = ag, hg = Os.compose({ baseName: "tabs", template: (t, e) => _`<template class="${t => t.orientation}">${Ut(0, e)}<div class="tablist" part="tablist" role="tablist"><slot class="tab" name="tab" part="tab" ${Ht("tabs")}></slot>${Tt(t => t.showActiveIndicator, _`<div ${Dt("activeIndicatorRef")} class="activeIndicator" part="activeIndicator"></div>`)}</div>${jt(0, e)}<div class="tabpanel"><slot name="tabpanel" part="tabpanel" ${Ht("tabpanels")}></slot></div></template>`, styles: og }), dg = og, ug = (t, e) => ft`
    ${rn("inline-flex")}

    ${zd(0, 0, ".control")}

    ${Hd()}

    :host{flex-direction:column;vertical-align:bottom}.control{height:calc((${Yh} * 2) * 1px);padding:calc(${rr} * 1.5px) calc(${rr} * 2px + 1px)}:host .control{resize:none}:host(.resize-both) .control{resize:both}:host(.resize-horizontal) .control{resize:horizontal}:host(.resize-vertical) .control{resize:vertical}`.withBehaviors(jd("outline", Md(0, 0, ".control")), jd("filled", Bd(0, 0, ".control")), sn(Nd(0, 0, ".control"))); class pg extends As { appearanceChanged(t, e) { t !== e && (this.classList.add(e), this.classList.remove(t)) } connectedCallback() { super.connectedCallback(), this.appearance || (this.appearance = "outline") } } nd([it], pg.prototype, "appearance", void 0); const gg = pg.compose({ baseName: "text-area", baseClass: As, template: (t, e) => _`<template class=" ${t => t.readOnly ? "readonly" : ""} ${t => t.resize !== Rs ? "resize-" + t.resize : ""}"><label part="label" for="control" class="${t => t.defaultSlottedNodes && t.defaultSlottedNodes.length ? "label" : "label label__hidden"}"><slot ${Ht("defaultSlottedNodes")}></slot></label><textarea part="control" class="control" id="control" ?autofocus="${t => t.autofocus}" cols="${t => t.cols}" ?disabled="${t => t.disabled}" form="${t => t.form}" list="${t => t.list}" maxlength="${t => t.maxlength}" minlength="${t => t.minlength}" name="${t => t.name}" placeholder="${t => t.placeholder}" ?readonly="${t => t.readOnly}" ?required="${t => t.required}" rows="${t => t.rows}" ?spellcheck="${t => t.spellcheck}" :value="${t => t.value}" aria-atomic="${t => t.ariaAtomic}" aria-busy="${t => t.ariaBusy}" aria-controls="${t => t.ariaControls}" aria-current="${t => t.ariaCurrent}" aria-describedby="${t => t.ariaDescribedby}" aria-details="${t => t.ariaDetails}" aria-disabled="${t => t.ariaDisabled}" aria-errormessage="${t => t.ariaErrormessage}" aria-flowto="${t => t.ariaFlowto}" aria-haspopup="${t => t.ariaHaspopup}" aria-hidden="${t => t.ariaHidden}" aria-invalid="${t => t.ariaInvalid}" aria-keyshortcuts="${t => t.ariaKeyshortcuts}" aria-label="${t => t.ariaLabel}" aria-labelledby="${t => t.ariaLabelledby}" aria-live="${t => t.ariaLive}" aria-owns="${t => t.ariaOwns}" aria-relevant="${t => t.ariaRelevant}" aria-roledescription="${t => t.ariaRoledescription}" @input="${(t, e) => t.handleTextInput()}" @change="${t => t.handleChange()}" ${Dt("control")}></textarea></template>`, styles: ug, shadowOptions: { delegatesFocus: !0 } }), fg = ug, mg = (t, e) => ft`
    ${rn("inline-block")}

    ${zd(0, 0, ".root")}

    ${Hd()}

    .root{display:flex;flex-direction:row}.control{-webkit-appearance:none;color:inherit;background:transparent;border:0;height:calc(100% - 4px);margin-top:auto;margin-bottom:auto;padding:0 calc(${rr} * 2px + 1px);font-family:inherit;font-size:inherit;line-height:inherit}.start,.end{display:flex;margin:auto}.start{display:flex;margin-inline-start:11px}.end{display:flex;margin-inline-end:11px}`.withBehaviors(jd("outline", Md(0, 0, ".root")), jd("filled", Bd(0, 0, ".root")), sn(Nd(0, 0, ".root"))); class vg extends Yo { appearanceChanged(t, e) { t !== e && (this.classList.add(e), this.classList.remove(t)) } connectedCallback() { super.connectedCallback(), this.appearance || (this.appearance = "outline") } } nd([it], vg.prototype, "appearance", void 0); const bg = vg.compose({ baseName: "text-field", baseClass: Yo, template: (t, e) => _`<template class=" ${t => t.readOnly ? "readonly" : ""} "><label part="label" for="control" class="${t => t.defaultSlottedNodes && t.defaultSlottedNodes.length ? "label" : "label label__hidden"}"><slot ${Ht({ property: "defaultSlottedNodes", filter: as })}></slot></label><div class="root" part="root">${Ut(0, e)}<input class="control" part="control" id="control" @input="${t => t.handleTextInput()}" @change="${t => t.handleChange()}" ?autofocus="${t => t.autofocus}" ?disabled="${t => t.disabled}" list="${t => t.list}" maxlength="${t => t.maxlength}" minlength="${t => t.minlength}" pattern="${t => t.pattern}" placeholder="${t => t.placeholder}" ?readonly="${t => t.readOnly}" ?required="${t => t.required}" size="${t => t.size}" ?spellcheck="${t => t.spellcheck}" :value="${t => t.value}" type="${t => t.type}" aria-atomic="${t => t.ariaAtomic}" aria-busy="${t => t.ariaBusy}" aria-controls="${t => t.ariaControls}" aria-current="${t => t.ariaCurrent}" aria-describedby="${t => t.ariaDescribedby}" aria-details="${t => t.ariaDetails}" aria-disabled="${t => t.ariaDisabled}" aria-errormessage="${t => t.ariaErrormessage}" aria-flowto="${t => t.ariaFlowto}" aria-haspopup="${t => t.ariaHaspopup}" aria-hidden="${t => t.ariaHidden}" aria-invalid="${t => t.ariaInvalid}" aria-keyshortcuts="${t => t.ariaKeyshortcuts}" aria-label="${t => t.ariaLabel}" aria-labelledby="${t => t.ariaLabelledby}" aria-live="${t => t.ariaLive}" aria-owns="${t => t.ariaOwns}" aria-relevant="${t => t.ariaRelevant}" aria-roledescription="${t => t.ariaRoledescription}" ${Dt("control")} />${jt(0, e)}</div></template>`, styles: mg, shadowOptions: { delegatesFocus: !0 } }), yg = mg; class xg extends Ps { } const $g = xg.compose({
        baseName: "toolbar", baseClass: Ps, template: (t, e) => _`<template aria-label="${t => t.ariaLabel}" aria-labelledby="${t => t.ariaLabelledby}" aria-orientation="${t => t.orientation}" orientation="${t => t.orientation}" role="toolbar" @click="${(t, e) => t.clickHandler(e.event)}" @focusin="${(t, e) => t.focusinHandler(e.event)}" @keydown="${(t, e) => t.keydownHandler(e.event)}" ${Bt({ property: "childItems", attributeFilter: ["disabled", "hidden"], filter: Lt(), subtree: !0 })}><slot name="label"></slot><div class="positioning-region" part="positioning-region">${Ut(0, e)}<slot ${Ht({ filter: Lt(), property: "slottedItems" })}></slot>${jt(0, e)}</div></template>`, styles: (t, e) => ft`
    ${rn("inline-flex")} :host{--toolbar-item-gap:calc(${rr} * 1px);background:${el};fill:currentcolor;padding:var(--toolbar-item-gap);box-sizing:border-box;align-items:center}:host(${an}){${Kh}}.positioning-region{align-items:center;display:inline-flex;flex-flow:row wrap;justify-content:flex-start;flex-grow:1}:host([orientation='vertical']) .positioning-region{flex-direction:column;align-items:start}::slotted(:not([slot])){flex:0 0 auto;margin:0 var(--toolbar-item-gap)}:host([orientation='vertical']) ::slotted(:not([slot])){margin:var(--toolbar-item-gap) 0}:host([orientation='vertical']){display:inline-flex;flex-direction:column}.start,.end{display:flex;align-items:center}.end{margin-inline-start:auto}.start__hidden,.end__hidden{display:none}::slotted(svg){${""}
      width:16px;height:16px}`.withBehaviors(sn(ft`
        :host(:${an}){outline-color:${Ge.Highlight};color:${Ge.ButtonText};forced-color-adjust:none}`))
    }); class wg extends Zs { connectedCallback() { super.connectedCallback(), el.setValueFor(this, Ga) } } const kg = wg.compose({
        baseName: "tooltip", baseClass: Zs, template: (t, e) => _` ${Tt(t => t.tooltipVisible, _`<${t.tagFor(ei)} fixed-placement="true" auto-update-mode="${t => t.autoUpdateMode}" vertical-positioning-mode="${t => t.verticalPositioningMode}" vertical-default-position="${t => t.verticalDefaultPosition}" vertical-inset="${t => t.verticalInset}" vertical-scaling="${t => t.verticalScaling}" horizontal-positioning-mode="${t => t.horizontalPositioningMode}" horizontal-default-position="${t => t.horizontalDefaultPosition}" horizontal-scaling="${t => t.horizontalScaling}" horizontal-inset="${t => t.horizontalInset}" vertical-viewport-lock="${t => t.horizontalViewportLock}" horizontal-viewport-lock="${t => t.verticalViewportLock}" dir="${t => t.currentDirection}" ${Dt("region")}><div class="tooltip" part="tooltip" role="tooltip"><slot></slot></div></${t.tagFor(ei)}>`)} `, styles: (t, e) => ft`
    :host{position:relative;contain:layout;overflow:visible;height:0;width:0;z-index:10000}.tooltip{box-sizing:border-box;border-radius:calc(${ar} * 1px);border:calc(${cr} * 1px) solid ${Oc};background:${el};color:${rc};padding:4px 12px;height:fit-content;width:fit-content;${Hh}
      white-space:nowrap;box-shadow:${$d}}${t.tagFor(ei)}{display:flex;justify-content:center;align-items:center;overflow:visible;flex-direction:row}${t.tagFor(ei)}.right,${t.tagFor(ei)}.left{flex-direction:column}${t.tagFor(ei)}.top .tooltip::after,${t.tagFor(ei)}.bottom .tooltip::after,${t.tagFor(ei)}.left .tooltip::after,${t.tagFor(ei)}.right .tooltip::after{content:'';width:12px;height:12px;background:${el};border-top:calc(${cr} * 1px) solid ${Oc};border-left:calc(${cr} * 1px) solid ${Oc};position:absolute}${t.tagFor(ei)}.top .tooltip::after{transform:translateX(-50%) rotate(225deg);bottom:5px;left:50%}${t.tagFor(ei)}.top .tooltip{margin-bottom:12px}${t.tagFor(ei)}.bottom .tooltip::after{transform:translateX(-50%) rotate(45deg);top:5px;left:50%}${t.tagFor(ei)}.bottom .tooltip{margin-top:12px}${t.tagFor(ei)}.left .tooltip::after{transform:translateY(-50%) rotate(135deg);top:50%;right:5px}${t.tagFor(ei)}.left .tooltip{margin-right:12px}${t.tagFor(ei)}.right .tooltip::after{transform:translateY(-50%) rotate(-45deg);top:50%;left:5px}${t.tagFor(ei)}.right .tooltip{margin-left:12px}`.withBehaviors(sn(ft`
        :host([disabled]){opacity:1}${t.tagFor(ei)}.top .tooltip::after,${t.tagFor(ei)}.bottom .tooltip::after,${t.tagFor(ei)}.left .tooltip::after,${t.tagFor(ei)}.right .tooltip::after{content:'';width:unset;height:unset}`))
    }), Cg = (t, e) => ft`
  :host([hidden]){display:none}${rn("flex")} :host{flex-direction:column;align-items:stretch;min-width:fit-content;font-size:0}`, Ig = en.compose({ baseName: "tree-view", template: (t, e) => _`<template role="tree" ${Dt("treeView")} @keydown="${(t, e) => t.handleKeyDown(e.event)}" @focusin="${(t, e) => t.handleFocus(e.event)}" @focusout="${(t, e) => t.handleBlur(e.event)}" @click="${(t, e) => t.handleClick(e.event)}" @selected-change="${(t, e) => t.handleSelectedChange(e.event)}"><slot ${Ht("slottedTreeItems")}></slot></template>`, styles: Cg }), Fg = Cg, Dg = ft`
  .expand-collapse-button svg{transform:rotate(0deg)}:host(.nested) .expand-collapse-button{left:var(--expand-collapse-button-nested-width,calc(${Yh} * -1px))}:host([selected])::after{left:calc(${hr} * 1px)}:host([expanded]) > .positioning-region .expand-collapse-button svg{transform:rotate(90deg)}`, Tg = ft`
  .expand-collapse-button svg{transform:rotate(180deg)}:host(.nested) .expand-collapse-button{right:var(--expand-collapse-button-nested-width,calc(${Yh} * -1px))}:host([selected])::after{right:calc(${hr} * 1px)}:host([expanded]) > .positioning-region .expand-collapse-button svg{transform:rotate(90deg)}`, Sg = vt`((${or} / 2) * ${rr}) + ((${rr} * ${nr}) / 2)`, Og = fo.create("tree-item-expand-collapse-hover").withDefault(t => { const e = Xl.getValueFor(t); return e.evaluate(t, e.evaluate(t).hover).hover }), Eg = fo.create("tree-item-expand-collapse-selected-hover").withDefault(t => { const e = ql.getValueFor(t); return Xl.getValueFor(t).evaluate(t, e.evaluate(t).rest).hover }), Vg = (t, e) => ft`
    ${rn("block")} :host{contain:content;position:relative;outline:none;color:${rc};fill:currentcolor;cursor:pointer;font-family:${dr};--expand-collapse-button-size:calc(${Yh} * 1px);--tree-item-nested-width:0}.positioning-region{display:flex;position:relative;box-sizing:border-box;background:${Yl};border:calc(${cr} * 1px) solid transparent;border-radius:calc(${ar} * 1px);height:calc((${Yh} + 1) * 1px)}:host(:${an}) .positioning-region{${Kh}}.positioning-region::before{content:'';display:block;width:var(--tree-item-nested-width);flex-shrink:0}:host(:not([disabled])) .positioning-region:hover{background:${Ql}}:host(:not([disabled])) .positioning-region:active{background:${Zl}}.content-region{display:inline-flex;align-items:center;white-space:nowrap;width:100%;height:calc(${Yh} * 1px);margin-inline-start:calc(${rr} * 2px + 8px);${Hh}}.items{display:none;${""} font-size:calc(1em + (${rr} + 16) * 1px)}.expand-collapse-button{background:none;border:none;border-radius:calc(${ar} * 1px);${""} width:calc((${Sg} + (${rr} * 2)) * 1px);height:calc((${Sg} + (${rr} * 2)) * 1px);padding:0;display:flex;justify-content:center;align-items:center;cursor:pointer;margin:0 6px}.expand-collapse-button svg{transition:transform 0.1s linear;pointer-events:none}.start,.end{display:flex}.start{${""} margin-inline-end:calc(${rr} * 2px + 2px)}.end{${""} margin-inline-start:calc(${rr} * 2px + 2px)}:host(.expanded) > .items{display:block}:host([disabled]){opacity:${ir};cursor:${"not-allowed"}}:host(.nested) .content-region{position:relative;margin-inline-start:var(--expand-collapse-button-size)}:host(.nested) .expand-collapse-button{position:absolute}:host(.nested) .expand-collapse-button:hover{background:${Og}}:host(:not([disabled])[selected]) .positioning-region{background:${_l}}:host(:not([disabled])[selected]) .expand-collapse-button:hover{background:${Eg}}:host([selected])::after{content:'';display:block;position:absolute;top:calc((${Yh} / 4) * 1px);width:3px;height:calc((${Yh} / 2) * 1px);${""} background:${sl};border-radius:calc(${ar} * 1px)}::slotted(fluent-tree-item){--tree-item-nested-width:1em;--expand-collapse-button-nested-width:calc(${Yh} * -1px)}`.withBehaviors(new rd(Dg, Tg), sn(ft`
        :host{color:${Ge.ButtonText}}.positioning-region{border-color:${Ge.ButtonFace};background:${Ge.ButtonFace}}:host(:not([disabled])) .positioning-region:hover,:host(:not([disabled])) .positioning-region:active,:host(:not([disabled])[selected]) .positioning-region{background:${Ge.Highlight}}:host .positioning-region:hover .content-region,:host([selected]) .positioning-region .content-region{forced-color-adjust:none;color:${Ge.HighlightText}}:host([disabled][selected]) .positioning-region .content-region{color:${Ge.GrayText}}:host([selected])::after{background:${Ge.HighlightText}}:host(:${an}) .positioning-region{forced-color-adjust:none;outline-color:${Ge.ButtonFace}}:host([disabled]),:host([disabled]) .content-region,:host([disabled]) .positioning-region:hover .content-region{opacity:1;color:${Ge.GrayText}}:host(.nested) .expand-collapse-button:hover,:host(:not([disabled])[selected]) .expand-collapse-button:hover{background:${Ge.ButtonFace};fill:${Ge.ButtonText}}`)), Rg = tn.compose({ baseName: "tree-item", template: (t, e) => _`<template role="treeitem" slot="${t => t.isNestedItem() ? "item" : void 0}" tabindex="-1" class="${t => t.expanded ? "expanded" : ""} ${t => t.selected ? "selected" : ""} ${t => t.nested ? "nested" : ""} ${t => t.disabled ? "disabled" : ""}" aria-expanded="${t => t.childItems && t.childItemLength() > 0 ? t.expanded : void 0}" aria-selected="${t => t.selected}" aria-disabled="${t => t.disabled}" @focusin="${(t, e) => t.handleFocus(e.event)}" @focusout="${(t, e) => t.handleBlur(e.event)}" ${Bt({ property: "childItems", filter: Lt() })}><div class="positioning-region" part="positioning-region"><div class="content-region" part="content-region">${Tt(t => t.childItems && t.childItemLength() > 0, _`<div aria-hidden="true" class="expand-collapse-button" part="expand-collapse-button" @click="${(t, e) => t.handleExpandCollapseButtonClick(e.event)}" ${Dt("expandCollapseButton")}><slot name="expand-collapse-glyph">${e.expandCollapseGlyph || ""}</slot></div>`)} ${Ut(0, e)}<slot></slot>${jt(0, e)}</div></div>${Tt(t => t.childItems && t.childItemLength() > 0 && (t.expanded || t.renderCollapsedChildren), _`<div role="group" class="items" part="items"><slot name="item" ${Ht("items")}></slot></div>`)}</template>`, styles: Vg, expandCollapseGlyph: '\n    <svg width="12" height="12" xmlns="http://www.w3.org/2000/svg">\n      <path d="M4.65 2.15a.5.5 0 000 .7L7.79 6 4.65 9.15a.5.5 0 10.7.7l3.5-3.5a.5.5 0 000-.7l-3.5-3.5a.5.5 0 00-.7 0z"/>\n    </svg>\n  ' }), Ag = Vg, Lg = { fluentAccordion: od, fluentAccordionItem: ed, fluentAnchor: Gd, fluentAnchoredRegion: Kd, fluentBadge: Zd, fluentBreadcrumb: eu, fluentBreadcrumbItem: su, fluentButton: lu, fluentCalendar: pu, fluentCard: mu, fluentCheckbox: yu, fluentCombobox: Iu, fluentDataGrid: Au, fluentDataGridCell: Ou, fluentDataGridRow: Vu, fluentDesignSystemProvider: Bu, fluentDialog: ju, fluentDivider: _u, fluentFlipper: Ku, fluentHorizontalScroll: ep, fluentListbox: np, fluentOption: lp, fluentMenu: up, fluentMenuItem: fp, fluentNumberField: xp, fluentProgress: kp, fluentProgressRing: Dp, fluentRadio: Op, fluentRadioGroup: Rp, fluentSearch: Bp, fluentSelect: Up, fluentSkeleton: Gp, fluentSlider: Xp, fluentSliderLabel: Zp, fluentSwitch: eg, fluentTabs: hg, fluentTab: ng, fluentTabPanel: lg, fluentTextArea: gg, fluentTextField: bg, fluentToolbar: $g, fluentTooltip: kg, fluentTreeView: Ig, fluentTreeItem: Rg, register(t, ...e) { if (t) for (const i in this) "register" !== i && this[i]().register(t, ...e) } }; function Pg(t) { return $o.getOrCreate(t).withPrefix("fluent") } const zg = Pg().register(Lg); export { Td as AccentButtonStyles, Xe as Accordion, Re as AccordionItem, qd as Anchor, ei as AnchoredRegion, Qd as Badge, si as Breadcrumb, oi as BreadcrumbItem, au as Button, fu as Card, Cu as Combobox, Ii as DataGrid, Ti as DataGridCell, Ci as DataGridRow, Mu as DesignSystemProvider, Ao as Dialog, rd as DirectionalStyleSheetBehavior, Po as Divider, Mo as Flipper, zg as FluentDesignSystem, tp as HorizontalScroll, Sd as HypertextStyles, Od as LightweightButtonStyles, sp as Listbox, dp as Menu, _o as MenuItem, Dd as NeutralButtonStyles, bp as NumberField, cp as OptionStyles, Ed as OutlineButtonStyles, Ln as PaletteRGB, wp as Progress, Fp as ProgressRing, ns as Radio, is as RadioGroup, Ep as RadioStyles, Mp as Search, jp as Select, ms as Skeleton, ks as Slider, ys as SliderLabel, Yn as StandardLuminance, Vd as StealthButtonStyles, Sn as SwatchRGB, Fs as Switch, Ts as Tab, Ds as TabPanel, Os as Tabs, pg as TextArea, vg as TextField, xg as Toolbar, wg as Tooltip, tn as TreeItem, en as TreeView, Na as accentBaseColor, rl as accentFillActive, qr as accentFillActiveDelta, al as accentFillFocus, _r as accentFillFocusDelta, nl as accentFillHover, Ur as accentFillHoverDelta, ol as accentFillRecipe, sl as accentFillRest, jr as accentFillRestDelta, ml as accentForegroundActive, Kr as accentForegroundActiveDelta, xh as accentForegroundCut, $h as accentForegroundCutLarge, vl as accentForegroundFocus, Xr as accentForegroundFocusDelta, fl as accentForegroundHover, Wr as accentForegroundHoverDelta, pl as accentForegroundRecipe, gl as accentForegroundRest, Gr as accentForegroundRestDelta, ja as accentPalette, $l as accentStrokeControlActive, wl as accentStrokeControlFocus, xl as accentStrokeControlHover, bl as accentStrokeControlRecipe, yl as accentStrokeControlRest, id as accordionItemStyles, sd as accordionStyles, Lg as allComponents, ld as ambientShadow, _d as anchorStyles, Xd as anchoredRegionStyles, Jd as badgeStyles, Fd as baseButtonStyles, or as baseHeightMultiplier, sr as baseHorizontalSpacingMultiplier, zd as baseInputStyles, Nr as baseLayerLuminance, dr as bodyFont, nu as breadcrumbItemStyles, iu as breadcrumbStyles, cu as buttonStyles, vu as cardStyles, xu as checkboxStyles, Fu as comboboxStyles, ar as controlCornerRadius, ih as cornerRadius, Eu as dataGridCellStyles, Ru as dataGridRowStyles, Lu as dataGridStyles, nr as density, rr as designUnit, Uu as dialogStyles, er as direction, cd as directionalShadow, ir as disabledOpacity, Gu as dividerStyles, oh as elevatedCornerRadius, hd as elevation, bd as elevationShadowCardActive, gd as elevationShadowCardActiveSize, yd as elevationShadowCardFocus, fd as elevationShadowCardFocusSize, vd as elevationShadowCardHover, pd as elevationShadowCardHoverSize, md as elevationShadowCardRest, ud as elevationShadowCardRestSize, Id as elevationShadowDialog, Cd as elevationShadowDialogSize, kd as elevationShadowFlyout, wd as elevationShadowFlyoutSize, dd as elevationShadowRecipe, $d as elevationShadowTooltip, xd as elevationShadowTooltipSize, el as fillColor, Xu as flipperStyles, od as fluentAccordion, ed as fluentAccordionItem, Gd as fluentAnchor, Kd as fluentAnchoredRegion, Zd as fluentBadge, eu as fluentBreadcrumb, su as fluentBreadcrumbItem, lu as fluentButton, pu as fluentCalendar, mu as fluentCard, yu as fluentCheckbox, Iu as fluentCombobox, Au as fluentDataGrid, Ou as fluentDataGridCell, Vu as fluentDataGridRow, Bu as fluentDesignSystemProvider, ju as fluentDialog, _u as fluentDivider, Ku as fluentFlipper, ep as fluentHorizontalScroll, np as fluentListbox, up as fluentMenu, fp as fluentMenuItem, xp as fluentNumberField, lp as fluentOption, kp as fluentProgress, Dp as fluentProgressRing, Op as fluentRadio, Rp as fluentRadioGroup, Bp as fluentSearch, Up as fluentSelect, Gp as fluentSkeleton, Xp as fluentSlider, Zp as fluentSliderLabel, eg as fluentSwitch, ng as fluentTab, lg as fluentTabPanel, hg as fluentTabs, gg as fluentTextArea, bg as fluentTextField, $g as fluentToolbar, kg as fluentTooltip, Rg as fluentTreeItem, Ig as fluentTreeView, nh as focusOutlineWidth, Nc as focusStrokeInner, Bc as focusStrokeInnerRecipe, Mc as focusStrokeOuter, Hc as focusStrokeOuterRecipe, hr as focusStrokeWidth, Kh as focusTreatmentBase, Xh as focusTreatmentTight, ur as fontWeight, dl as foregroundOnAccentActive, _c as foregroundOnAccentActiveLarge, ul as foregroundOnAccentFocus, Gc as foregroundOnAccentFocusLarge, hl as foregroundOnAccentHover, qc as foregroundOnAccentHoverLarge, jc as foregroundOnAccentLargeRecipe, ll as foregroundOnAccentRecipe, cl as foregroundOnAccentRest, Uc as foregroundOnAccentRestLarge, Yh as heightNumber, ip as horizontalScrollStyles, Bd as inputFilledStyles, Nd as inputForcedColorStyles, Md as inputOutlineStyles, Hd as inputStateStyles, Vn as isDark, lr as layerCornerRadius, rp as listboxStyles, mp as menuItemStyles, pp as menuStyles, Ma as neutralBaseColor, Fh as neutralContrastFillActive, lh as neutralContrastFillActiveDelta, Dh as neutralContrastFillFocus, ch as neutralContrastFillFocusDelta, Ih as neutralContrastFillHover, ah as neutralContrastFillHoverDelta, Ch as neutralContrastFillRest, rh as neutralContrastFillRestDelta, wh as neutralDivider, fh as neutralDividerRestDelta, Fl as neutralFillActive, Zr as neutralFillActiveDelta, kh as neutralFillCard, hh as neutralFillCardDelta, Dl as neutralFillFocus, Jr as neutralFillFocusDelta, Il as neutralFillHover, Qr as neutralFillHoverDelta, El as neutralFillInputActive, ia as neutralFillInputActiveDelta, Pl as neutralFillInputAltActive, ra as neutralFillInputAltActiveDelta, zl as neutralFillInputAltFocus, aa as neutralFillInputAltFocusDelta, Ll as neutralFillInputAltHover, na as neutralFillInputAltHoverDelta, Rl as neutralFillInputAltRecipe, Al as neutralFillInputAltRest, sa as neutralFillInputAltRestDelta, Vl as neutralFillInputFocus, oa as neutralFillInputFocusDelta, Ol as neutralFillInputHover, ea as neutralFillInputHoverDelta, Tl as neutralFillInputRecipe, Sl as neutralFillInputRest, ta as neutralFillInputRestDelta, th as neutralFillInverseActive, Xc as neutralFillInverseActiveDelta, eh as neutralFillInverseFocus, Yc as neutralFillInverseFocusDelta, Jc as neutralFillInverseHover, Kc as neutralFillInverseHoverDelta, Qc as neutralFillInverseRecipe, Zc as neutralFillInverseRest, Wc as neutralFillInverseRestDelta, Nl as neutralFillLayerActive, ha as neutralFillLayerActiveDelta, jl as neutralFillLayerAltRecipe, Ul as neutralFillLayerAltRest, da as neutralFillLayerAltRestDelta, Bl as neutralFillLayerHover, ca as neutralFillLayerHoverDelta, Hl as neutralFillLayerRecipe, Ml as neutralFillLayerRest, la as neutralFillLayerRestDelta, kl as neutralFillRecipe, Cl as neutralFillRest, Yr as neutralFillRestDelta, Wl as neutralFillSecondaryActive, ga as neutralFillSecondaryActiveDelta, Kl as neutralFillSecondaryFocus, fa as neutralFillSecondaryFocusDelta, Gl as neutralFillSecondaryHover, pa as neutralFillSecondaryHoverDelta, ql as neutralFillSecondaryRecipe, _l as neutralFillSecondaryRest, ua as neutralFillSecondaryRestDelta, Zl as neutralFillStealthActive, ba as neutralFillStealthActiveDelta, Jl as neutralFillStealthFocus, ya as neutralFillStealthFocusDelta, Ql as neutralFillStealthHover, va as neutralFillStealthHoverDelta, Xl as neutralFillStealthRecipe, Yl as neutralFillStealthRest, ma as neutralFillStealthRestDelta, oc as neutralFillStrongActive, wa as neutralFillStrongActiveDelta, sc as neutralFillStrongFocus, ka as neutralFillStrongFocusDelta, ic as neutralFillStrongHover, $a as neutralFillStrongHoverDelta, tc as neutralFillStrongRecipe, ec as neutralFillStrongRest, xa as neutralFillStrongRestDelta, Oh as neutralFillToggleActive, ph as neutralFillToggleActiveDelta, Eh as neutralFillToggleFocus, gh as neutralFillToggleFocusDelta, Sh as neutralFillToggleHover, uh as neutralFillToggleHoverDelta, Th as neutralFillToggleRest, dh as neutralFillToggleRestDelta, Vh as neutralFocus, Rh as neutralFocusInnerAccent, lc as neutralForegroundActive, cc as neutralForegroundFocus, dc as neutralForegroundHint, hc as neutralForegroundHintRecipe, ac as neutralForegroundHover, nc as neutralForegroundRecipe, rc as neutralForegroundRest, Ka as neutralLayer1, Wa as neutralLayer1Recipe, Ya as neutralLayer2, Xa as neutralLayer2Recipe, Za as neutralLayer3, Qa as neutralLayer3Recipe, tl as neutralLayer4, Ja as neutralLayer4Recipe, qa as neutralLayerCardContainer, Ua as neutralLayerCardContainerRecipe, Ga as neutralLayerFloating, _a as neutralLayerFloatingRecipe, mh as neutralLayerL1, vh as neutralLayerL2, bh as neutralLayerL3, yh as neutralLayerL4, Ph as neutralOutlineActive, zh as neutralOutlineFocus, Lh as neutralOutlineHover, Ah as neutralOutlineRest, Ba as neutralPalette, fc as neutralStrokeActive, Fa as neutralStrokeActiveDelta, xc as neutralStrokeControlActive, Oa as neutralStrokeControlActiveDelta, $c as neutralStrokeControlFocus, Ea as neutralStrokeControlFocusDelta, yc as neutralStrokeControlHover, Sa as neutralStrokeControlHoverDelta, vc as neutralStrokeControlRecipe, bc as neutralStrokeControlRest, Ta as neutralStrokeControlRestDelta, wc as neutralStrokeDividerRecipe, kc as neutralStrokeDividerRest, Va as neutralStrokeDividerRestDelta, mc as neutralStrokeFocus, Da as neutralStrokeFocusDelta, gc as neutralStrokeHover, Ia as neutralStrokeHoverDelta, Dc as neutralStrokeInputActive, Tc as neutralStrokeInputFocus, Fc as neutralStrokeInputHover, Cc as neutralStrokeInputRecipe, Ic as neutralStrokeInputRest, Vc as neutralStrokeLayerActive, La as neutralStrokeLayerActiveDelta, Ec as neutralStrokeLayerHover, Aa as neutralStrokeLayerHoverDelta, Sc as neutralStrokeLayerRecipe, Oc as neutralStrokeLayerRest, Ra as neutralStrokeLayerRestDelta, uc as neutralStrokeRecipe, pc as neutralStrokeRest, Ca as neutralStrokeRestDelta, Pc as neutralStrokeStrongActive, za as neutralStrokeStrongActiveDelta, zc as neutralStrokeStrongFocus, Ha as neutralStrokeStrongFocusDelta, Lc as neutralStrokeStrongHover, Pa as neutralStrokeStrongHoverDelta, Rc as neutralStrokeStrongRecipe, Ac as neutralStrokeStrongRest, yp as numberFieldStyles, sh as outlineWidth, Tp as progressRingStyles, Cp as progressStyles, Pg as provideFluentDesignSystem, Ap as radioGroupStyles, Np as searchStyles, Lp as searchTemplate, qp as selectStyles, Wp as skeletonStyles, Jp as sliderLabelStyles, Yp as sliderStyles, cr as strokeWidth, ig as switchStyles, cg as tabPanelStyles, rg as tabStyles, dg as tabsStyles, fg as textAreaStyles, yg as textFieldStyles, Ag as treeItemStyles, Fg as treeViewStyles, Hh as typeRampBase, gr as typeRampBaseFontSize, mr as typeRampBaseFontVariations, fr as typeRampBaseLineHeight, Mh as typeRampMinus1, vr as typeRampMinus1FontSize, yr as typeRampMinus1FontVariations, br as typeRampMinus1LineHeight, Bh as typeRampMinus2, xr as typeRampMinus2FontSize, wr as typeRampMinus2FontVariations, $r as typeRampMinus2LineHeight, Nh as typeRampPlus1, kr as typeRampPlus1FontSize, Ir as typeRampPlus1FontVariations, Cr as typeRampPlus1LineHeight, jh as typeRampPlus2, Fr as typeRampPlus2FontSize, Tr as typeRampPlus2FontVariations, Dr as typeRampPlus2LineHeight, Uh as typeRampPlus3, Sr as typeRampPlus3FontSize, Er as typeRampPlus3FontVariations, Or as typeRampPlus3LineHeight, qh as typeRampPlus4, Vr as typeRampPlus4FontSize, Ar as typeRampPlus4FontVariations, Rr as typeRampPlus4LineHeight, _h as typeRampPlus5, Lr as typeRampPlus5FontSize, zr as typeRampPlus5FontVariations, Pr as typeRampPlus5LineHeight, Gh as typeRampPlus6, Hr as typeRampPlus6FontSize, Br as typeRampPlus6FontVariations, Mr as typeRampPlus6LineHeight };