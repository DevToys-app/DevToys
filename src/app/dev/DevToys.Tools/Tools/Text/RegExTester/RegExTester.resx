<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Regular Expression Tester tool</value>
  </data>
  <data name="AllMatches" xml:space="preserve">
    <value>All matches</value>
  </data>
  <data name="AllMatchesDescription" xml:space="preserve">
    <value>Find all the matches in the text or stop after the first match.</value>
  </data>
  <data name="CheatSheetAlternation" xml:space="preserve">
    <value>Alternation</value>
  </data>
  <data name="CheatSheetAlternationDetails" xml:space="preserve">
    <value>Acts like a boolean OR. Matches the expression before or after the |.
It can operate within a group, or on a whole expression. The patterns will be tested in order.</value>
  </data>
  <data name="CheatSheetAnyCharacter" xml:space="preserve">
    <value>Any character except newline</value>
  </data>
  <data name="CheatSheetAnyCharacterDetails" xml:space="preserve">
    <value>Matches any character other than newline. Equivalent to [^\n\r].</value>
  </data>
  <data name="CheatSheetAtomicGroup" xml:space="preserve">
    <value>Atomic group</value>
  </data>
  <data name="CheatSheetAtomicGroupDetails" xml:space="preserve">
    <value>Non-capturing group that discards backtracking positions once matched.
For example, /(?&gt;ab|a)b/ will match abb but not ab because once the ab option has matched, the atomic group prevents backtracking to retry with the a option.</value>
  </data>
  <data name="CheatSheetBeginning" xml:space="preserve">
    <value>Beginning</value>
  </data>
  <data name="CheatSheetBeginningDetails" xml:space="preserve">
    <value>Matches the beginning of the string, or the beginning of a line if the multiline flag (m) is enabled. This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetBeginningOfString" xml:space="preserve">
    <value>Beginning of string</value>
  </data>
  <data name="CheatSheetBeginningOfStringDetails" xml:space="preserve">
    <value>Matches the beginning of the string. Unlike ^, this is unaffected by the multiline flag (m). This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetBell" xml:space="preserve">
    <value>Bell</value>
  </data>
  <data name="CheatSheetBellDetails" xml:space="preserve">
    <value>Matches a BELL character (char code 7).</value>
  </data>
  <data name="CheatSheetBranchResetGroup" xml:space="preserve">
    <value>Branch reset group</value>
  </data>
  <data name="CheatSheetBranchResetGroupDetails" xml:space="preserve">
    <value>Define alternative groups that share the same group numbers.
For example, in (?|(a)|(b)) both groups (a and b) would be counted as group #1.</value>
  </data>
  <data name="CheatSheetCaptureGroup" xml:space="preserve">
    <value>Capture group</value>
  </data>
  <data name="CheatSheetCaptureGroupDetails" xml:space="preserve">
    <value>Inserts the results of the specified capture group. For example, $3 would insert the third capture group.
There are multiple syntaxes for this feature:

$1 \1 \{1}</value>
  </data>
  <data name="CheatSheetCapturingGroup" xml:space="preserve">
    <value>Capturing group</value>
  </data>
  <data name="CheatSheetCapturingGroupDetails" xml:space="preserve">
    <value>Groups multiple tokens together and creates a capture group for extracting a substring or using a backreference.</value>
  </data>
  <data name="CheatSheetCarriageReturn" xml:space="preserve">
    <value>Carriage return</value>
  </data>
  <data name="CheatSheetCarriageReturnDetails" xml:space="preserve">
    <value>Matches a CARRIAGE RETURN character (char code 13).</value>
  </data>
  <data name="CheatSheetCategoryAnchors" xml:space="preserve">
    <value>Anchors</value>
  </data>
  <data name="CheatSheetCategoryCharacterClasses" xml:space="preserve">
    <value>Character classes</value>
  </data>
  <data name="CheatSheetCategoryEscapedCharacters" xml:space="preserve">
    <value>Escaped characters</value>
  </data>
  <data name="CheatSheetCategoryGroupsReferences" xml:space="preserve">
    <value>Groups and References</value>
  </data>
  <data name="CheatSheetCategoryLookaround" xml:space="preserve">
    <value>Lookaround</value>
  </data>
  <data name="CheatSheetCategoryQuantifiersAlternation" xml:space="preserve">
    <value>Quantifiers and Alternation</value>
  </data>
  <data name="CheatSheetCategorySpecial" xml:space="preserve">
    <value>Special</value>
  </data>
  <data name="CheatSheetCategorySubstitution" xml:space="preserve">
    <value>Substitution</value>
  </data>
  <data name="CheatSheetCharacterRange" xml:space="preserve">
    <value>Character range</value>
  </data>
  <data name="CheatSheetCharacterRangeDetails" xml:space="preserve">
    <value>Matches a character having a character code between the two specified characters inclusive.</value>
  </data>
  <data name="CheatSheetCharacterSet" xml:space="preserve">
    <value>A single character of A, b or c</value>
  </data>
  <data name="CheatSheetCharacterSetDetails" xml:space="preserve">
    <value>Matches either an A, b or c character</value>
  </data>
  <data name="CheatSheetComment" xml:space="preserve">
    <value>Comment</value>
  </data>
  <data name="CheatSheetCommentDetails" xml:space="preserve">
    <value>Allows you to insert a comment into your expression that is ignored when finding a match.</value>
  </data>
  <data name="CheatSheetConditional" xml:space="preserve">
    <value>Conditional</value>
  </data>
  <data name="CheatSheetConditionalDetails" xml:space="preserve">
    <value>Conditionally matches one of two options based on whether a lookaround is matched.
For example, /(?(?=a)ab|..)/ will match ab and zx but not ax, because if the first character matches the condition a then it evaluates the pattern ab.

Any lookaround can be used as the condition. A lookahead will start the subsequent match at the start of the condition, a lookbehind will start it after.</value>
  </data>
  <data name="CheatSheetControlCharacterEscape" xml:space="preserve">
    <value>Control character escape</value>
  </data>
  <data name="CheatSheetControlCharacterEscapeDetails" xml:space="preserve">
    <value>Escaped control character in the form \cZ. This can range from \cA (SOH, char code 1) to \cZ (SUB, char code 26).</value>
  </data>
  <data name="CheatSheetDefine" xml:space="preserve">
    <value>Define</value>
  </data>
  <data name="CheatSheetDefineDetails" xml:space="preserve">
    <value>Used to define named groups for use as subroutines without including them in the match.
For example, /A(?(DEFINE)(?'foo'Z))B\g'foo'/ will match ABZ, because the define group is ignored in the match except to define the foo subroutine that is referenced later with \g'foo'.</value>
  </data>
  <data name="CheatSheetDescription" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="CheatSheetDigit" xml:space="preserve">
    <value>Digit</value>
  </data>
  <data name="CheatSheetDigitDetails" xml:space="preserve">
    <value>Matches any digit character (0-9). Equivalent to [0-9].</value>
  </data>
  <data name="CheatSheetEnd" xml:space="preserve">
    <value>End</value>
  </data>
  <data name="CheatSheetEndDetails" xml:space="preserve">
    <value>Matches the end of the string, or the end of a line if the multiline flag (m) is enabled. This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetEndOfString" xml:space="preserve">
    <value>End of string</value>
  </data>
  <data name="CheatSheetEndOfStringDetails" xml:space="preserve">
    <value>Matches the end of the string. Unlike $, this is unaffected by the multiline flag (m). This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetEsc" xml:space="preserve">
    <value>Esc</value>
  </data>
  <data name="CheatSheetEscapedCharacters" xml:space="preserve">
    <value>Escaped characters</value>
  </data>
  <data name="CheatSheetEscapedCharactersDetails" xml:space="preserve">
    <value>For convenience, these escaped characters are supported in the Replace string in RegExr: \n, \r, \t, \\, and unicode escapes \uFFFF. This may vary in your deploy environment.</value>
  </data>
  <data name="CheatSheetEscapeSequence" xml:space="preserve">
    <value>Escape sequence</value>
  </data>
  <data name="CheatSheetEscapeSequenceDetails" xml:space="preserve">
    <value>All characters between the \Q and the \E are interpreted as a literal string. If \E is omitted, it continues to the end of the expression. For example, the expression /\Q(?.)\E/ will match the string (?.).</value>
  </data>
  <data name="CheatSheetEscDetails" xml:space="preserve">
    <value>Matches a ESC character (char code 27).</value>
  </data>
  <data name="CheatSheetFormFeed" xml:space="preserve">
    <value>Form feed</value>
  </data>
  <data name="CheatSheetFormFeedDetails" xml:space="preserve">
    <value>Matches a FORM FEED character (char code 12).</value>
  </data>
  <data name="CheatSheetGroupConditional" xml:space="preserve">
    <value>Group conditional</value>
  </data>
  <data name="CheatSheetGroupConditionalDetails" xml:space="preserve">
    <value>Conditionally matches one of two options based on whether group 'undefined' matched.
For example, /(z)?(?(1)a|b)/ will match za because the first capture group matches z successfully, which causes the conditional to match the first option a.

The same pattern will also match b on its own, because group 1 doesn't match, so it instead tries to match the second option b.

You can reference a group by name, number, or relative position (ex. -1).</value>
  </data>
  <data name="CheatSheetHexadecimalEscape" xml:space="preserve">
    <value>Hexadecimal escape</value>
  </data>
  <data name="CheatSheetHexadecimalEscapeDetails" xml:space="preserve">
    <value>Hexadecimal escaped character in the form \xFF.</value>
  </data>
  <data name="CheatSheetHorizontalWhitespace" xml:space="preserve">
    <value>Horizontal whitespace</value>
  </data>
  <data name="CheatSheetHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Matches any horizontal whitespace character (spaces, tabs).</value>
  </data>
  <data name="CheatSheetKeepOut" xml:space="preserve">
    <value>Keep out</value>
  </data>
  <data name="CheatSheetKeepOutDetails" xml:space="preserve">
    <value>Keep text matched so far out of the returned match, essentially discarding the match up to this point.For example /o\Kbar/ will match bar within the string foobar</value>
  </data>
  <data name="CheatSheetLazy" xml:space="preserve">
    <value>Lazy</value>
  </data>
  <data name="CheatSheetLazyDetails" xml:space="preserve">
    <value>Makes the preceding quantifier lazy, causing it to match as few characters as possible. By default, quantifiers are greedy, and will match as many characters as possible.
This behaviour is reversed by the ungreedy (U) flag/modifier.</value>
  </data>
  <data name="CheatSheetLineBreak" xml:space="preserve">
    <value>Line break</value>
  </data>
  <data name="CheatSheetLineBreakDetails" xml:space="preserve">
    <value>Matches any line break character, including the CRLF pair, and CR / LF individually.</value>
  </data>
  <data name="CheatSheetLineFeed" xml:space="preserve">
    <value>Line feed</value>
  </data>
  <data name="CheatSheetLineFeedDetails" xml:space="preserve">
    <value>Matches a LINE FEED character (char code 10).</value>
  </data>
  <data name="CheatSheetMatch" xml:space="preserve">
    <value>Match</value>
  </data>
  <data name="CheatSheetMatchAny" xml:space="preserve">
    <value>Match any</value>
  </data>
  <data name="CheatSheetMatchAnyDetails" xml:space="preserve">
    <value>A character set that can be used to match any character, including line breaks, without the dotall flag (s).</value>
  </data>
  <data name="CheatSheetMatchDetails" xml:space="preserve">
    <value>Inserts the matched text.
There are multiple syntaxes for this feature:

$0 \0 \{0}</value>
  </data>
  <data name="CheatSheetModeModifier" xml:space="preserve">
    <value>Mode modifier</value>
  </data>
  <data name="CheatSheetModeModifierDetails" xml:space="preserve">
    <value>Enables or disables modes for the remainder of the expression.Matching modes generally map to expression flags. For example (?i) would enable case insensitivity for the remainder of the expression.
Multiple modifiers can be specified, and any modifiers that follow - are disabled. For example (?im-s) would enable case insensitivity &amp; multiline modes, and disable dotall.

Supported modifiers are: i - case insensitive, s - dotall, m - multiline, x - free spacing, J - allow duplicate names, U - ungreedy.</value>
  </data>
  <data name="CheatSheetNamedCapturingGroup" xml:space="preserve">
    <value>Named capturing group</value>
  </data>
  <data name="CheatSheetNamedCapturingGroupDetails" xml:space="preserve">
    <value>Creates a capturing group that can be referenced via the specified name.
There are multiple syntaxes for this feature:

(?'name'ABC) (?P&lt;name&gt;ABC) (?&lt;name&gt;ABC)</value>
  </data>
  <data name="CheatSheetNamedReference" xml:space="preserve">
    <value>Named reference</value>
  </data>
  <data name="CheatSheetNamedReferenceDetails" xml:space="preserve">
    <value>Matches the results of a named capture group.
There are multiple syntaxes for this feature:

\k'name' \k&lt;name&gt; \k{name} \g{name} (?P=name)</value>
  </data>
  <data name="CheatSheetNamedSubroutine" xml:space="preserve">
    <value>Named subroutine</value>
  </data>
  <data name="CheatSheetNamedSubroutineDetails" xml:space="preserve">
    <value>Matches the expression in a capture group. Compare this to a reference, that matches the result.
There are multiple syntaxes for this feature: \g&lt;name&gt; \g'name' (?&amp;name) (?P&gt;name).</value>
  </data>
  <data name="CheatSheetNegatedCharacterSet" xml:space="preserve">
    <value>A character except A, b or c</value>
  </data>
  <data name="CheatSheetNegatedCharacterSetDetails" xml:space="preserve">
    <value>Match any character that is not A, b or c.</value>
  </data>
  <data name="CheatSheetNegativeLookahead" xml:space="preserve">
    <value>Negative lookahead</value>
  </data>
  <data name="CheatSheetNegativeLookaheadDetails" xml:space="preserve">
    <value>Specifies a group that can not match after the main expression (if it matches, the result is discarded).</value>
  </data>
  <data name="CheatSheetNegativeLookbehind" xml:space="preserve">
    <value>Negative lookbehind</value>
  </data>
  <data name="CheatSheetNegativeLookbehindDetails" xml:space="preserve">
    <value>Specifies a group that can not match before the main expression (if it matches, the result is discarded).</value>
  </data>
  <data name="CheatSheetNonCapturingGroup" xml:space="preserve">
    <value>Non-capturing group</value>
  </data>
  <data name="CheatSheetNonCapturingGroupDetails" xml:space="preserve">
    <value>Groups multiple tokens together without creating a capture group.</value>
  </data>
  <data name="CheatSheetNotDigit" xml:space="preserve">
    <value>Not digit</value>
  </data>
  <data name="CheatSheetNotDigitDetails" xml:space="preserve">
    <value>Matches any character that is not a digit character (0-9). Equivalent to [^0-9].</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespace" xml:space="preserve">
    <value>Not horizontal whitespace</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Matches any character that is not a horizontal whitespace character (spaces, tabs).</value>
  </data>
  <data name="CheatSheetNotLineBreak" xml:space="preserve">
    <value>Not line break</value>
  </data>
  <data name="CheatSheetNotLineBreakDetails" xml:space="preserve">
    <value>Matches any character that is not a line break. Similar to dot (.) but is unaffected by the dotall flag (s).</value>
  </data>
  <data name="CheatSheetNotUnicodeCategory" xml:space="preserve">
    <value>Not unicode category</value>
  </data>
  <data name="CheatSheetNotUnicodeCategoryDetails" xml:space="preserve">
    <value>Matches any character that is not in the specified unicode category.</value>
  </data>
  <data name="CheatSheetNotUnicodeScript" xml:space="preserve">
    <value>Not unicode script</value>
  </data>
  <data name="CheatSheetNotUnicodeScriptDetails" xml:space="preserve">
    <value>Matches any character that is not in the specified unicode script.</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespace" xml:space="preserve">
    <value>Not vertical whitespace</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespaceDetails" xml:space="preserve">
    <value>Matches any character that is not a vertical whitespace character (line breaks).</value>
  </data>
  <data name="CheatSheetNotWhitespace" xml:space="preserve">
    <value>Not whitespace</value>
  </data>
  <data name="CheatSheetNotWhitespaceDetails" xml:space="preserve">
    <value>Matches any character that is not a whitespace character (spaces, tabs, line breaks).</value>
  </data>
  <data name="CheatSheetNotWord" xml:space="preserve">
    <value>Not word</value>
  </data>
  <data name="CheatSheetNotWordBoundary" xml:space="preserve">
    <value>Not word boundary</value>
  </data>
  <data name="CheatSheetNotWordBoundaryDetails" xml:space="preserve">
    <value>Matches any position that is not a word boundary. This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetNotWordDetails" xml:space="preserve">
    <value>Matches any character that is not a word character (alphanumeric &amp; underscore). Equivalent to [^A-Za-z0-9_]</value>
  </data>
  <data name="CheatSheetNull" xml:space="preserve">
    <value>Null</value>
  </data>
  <data name="CheatSheetNullDetails" xml:space="preserve">
    <value>Matches a NULL character (char code 0).</value>
  </data>
  <data name="CheatSheetNumericReference" xml:space="preserve">
    <value>Numeric reference</value>
  </data>
  <data name="CheatSheetNumericReferenceDetails" xml:space="preserve">
    <value>Matches the results of a capture group. For example \1 matches the results of the first capture group &amp; \3 matches the third.
There are multiple syntaxes for this feature: \1 \g1 \g{1}.

The latter syntaxes support relative values preceded by + or -. For example \g-1 would match the group preceding the reference.</value>
  </data>
  <data name="CheatSheetNumericSubroutine" xml:space="preserve">
    <value>Numeric subroutine</value>
  </data>
  <data name="CheatSheetNumericSubroutineDetails" xml:space="preserve">
    <value>Matches the expression in a capture group. Compare this to a reference, that matches the result. For example /(a|b)\g'1'/ can match ab, because the expression a|b is evaluated again.
There are multiple syntaxes for this feature: \g&lt;1&gt; \g'1' (?1).

Relative values preceded by + or - are also supported. For example \g&lt;-1&gt; would match the group preceding the reference.</value>
  </data>
  <data name="CheatSheetOctalEscape" xml:space="preserve">
    <value>Octal escape</value>
  </data>
  <data name="CheatSheetOctalEscapeDetails" xml:space="preserve">
    <value>Octal escaped character in the form \000. Value must be less than 255 (\377).
The syntax \o{FFF} is also supported.</value>
  </data>
  <data name="CheatSheetOptional" xml:space="preserve">
    <value>Optional</value>
  </data>
  <data name="CheatSheetOptionalDetails" xml:space="preserve">
    <value>Matches 0 or 1 of the preceding token, effectively making it optional.</value>
  </data>
  <data name="CheatSheetPlus" xml:space="preserve">
    <value>Plus</value>
  </data>
  <data name="CheatSheetPlusDetails" xml:space="preserve">
    <value>Matches 1 or more of the preceding token.</value>
  </data>
  <data name="CheatSheetPositiveLookahead" xml:space="preserve">
    <value>Positive lookahead</value>
  </data>
  <data name="CheatSheetPositiveLookaheadDetails" xml:space="preserve">
    <value>Matches a group after the main expression without including it in the result.</value>
  </data>
  <data name="CheatSheetPositiveLookbehind" xml:space="preserve">
    <value>Positive lookbehind</value>
  </data>
  <data name="CheatSheetPositiveLookbehindDetails" xml:space="preserve">
    <value>Matches a group before the main expression without including it in the result.</value>
  </data>
  <data name="CheatSheetPossessive" xml:space="preserve">
    <value>Possessive</value>
  </data>
  <data name="CheatSheetPossessiveDetails" xml:space="preserve">
    <value>Makes the preceding quantifier possessive. It will match as many characters as possible, and will not release them to match subsequent tokens.
For example /.*a/ would match aaa, but /.*+a/ would not, because the repeating dot would match and not release the last character to match a.</value>
  </data>
  <data name="CheatSheetPreviousMatchEnd" xml:space="preserve">
    <value>Previous match end</value>
  </data>
  <data name="CheatSheetPreviousMatchEndDetails" xml:space="preserve">
    <value>Matches the end position of the previous match. This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetQuantifier" xml:space="preserve">
    <value>Quantifier</value>
  </data>
  <data name="CheatSheetQuantifierDetails" xml:space="preserve">
    <value>Matches the specified quantity of the previous token. {1,3} will match 1 to 3. {3} will match exactly 3. {3,} will match 3 or more.</value>
  </data>
  <data name="CheatSheetRecursion" xml:space="preserve">
    <value>Recursion</value>
  </data>
  <data name="CheatSheetRecursionDetails" xml:space="preserve">
    <value>Attempts to match the full expression again at the current position.
For example, /a(?R)?b/ will match any number of a followed by the same number of z: the full text of az or aaaazzzz, but not azzz.

There are multiple syntaxes for this feature:

(?R) (?0) \g&lt;0&gt; \g'0'</value>
  </data>
  <data name="CheatSheetReservedCharacters" xml:space="preserve">
    <value>Reserved characters</value>
  </data>
  <data name="CheatSheetReservedCharactersDetails" xml:space="preserve">
    <value>The following character have special meaning, and should be preceded by a \ (backslash) to represent a literal character:
+*?^$\.[]{}()|/

Within a character set, only \, -, and ] need to be escaped.</value>
  </data>
  <data name="CheatSheetStar" xml:space="preserve">
    <value>Star</value>
  </data>
  <data name="CheatSheetStarDetails" xml:space="preserve">
    <value>Matches 0 or more of the preceding token.</value>
  </data>
  <data name="CheatSheetStrictEndOfString" xml:space="preserve">
    <value>Strict end of string</value>
  </data>
  <data name="CheatSheetStrictEndOfStringDetails" xml:space="preserve">
    <value>Matches the end of the string. Unlike $ or \Z, it does not allow for a trailing newline. This is unaffected by the multiline flag (m). This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetSyntax" xml:space="preserve">
    <value>Syntax</value>
  </data>
  <data name="CheatSheetTab" xml:space="preserve">
    <value>Tab</value>
  </data>
  <data name="CheatSheetTabDetails" xml:space="preserve">
    <value>Matches a TAB character (char code 9).</value>
  </data>
  <data name="CheatSheetTitle" xml:space="preserve">
    <value>Cheat sheet</value>
  </data>
  <data name="CheatSheetUnicodeCategory" xml:space="preserve">
    <value>Unicode category</value>
  </data>
  <data name="CheatSheetUnicodeCategoryDetails" xml:space="preserve">
    <value>Matches a character in the specified unicode category. For example, \p{Ll} will match any lowercase letter.</value>
  </data>
  <data name="CheatSheetUnicodeEscape" xml:space="preserve">
    <value>Unicode escape</value>
  </data>
  <data name="CheatSheetUnicodeEscapeDetails" xml:space="preserve">
    <value>Unicode escaped character in the form \x{FF}.</value>
  </data>
  <data name="CheatSheetUnicodeGrapheme" xml:space="preserve">
    <value>Unicode grapheme</value>
  </data>
  <data name="CheatSheetUnicodeGraphemeDetails" xml:space="preserve">
    <value>Matches any single unicode grapheme (ie. character). This includes line breaks (regardless of the dotall mode) and graphemes encoded as multiple code points.</value>
  </data>
  <data name="CheatSheetUnicodeScript" xml:space="preserve">
    <value>Unicode script</value>
  </data>
  <data name="CheatSheetUnicodeScriptDetails" xml:space="preserve">
    <value>Matches any character in the specified unicode script. For example, \p{Arabic} will match characters in the Arabic script.</value>
  </data>
  <data name="CheatSheetVerticalWhitespace" xml:space="preserve">
    <value>Vertical whitespace</value>
  </data>
  <data name="CheatSheetVerticalWhitespaceDetails" xml:space="preserve">
    <value>Matches any vertical whitespace character (line breaks).</value>
  </data>
  <data name="CheatSheetWhitespace" xml:space="preserve">
    <value>Whitespace</value>
  </data>
  <data name="CheatSheetWhitespaceDetails" xml:space="preserve">
    <value>Matches any whitespace character (spaces, tabs, line breaks).</value>
  </data>
  <data name="CheatSheetWord" xml:space="preserve">
    <value>Word</value>
  </data>
  <data name="CheatSheetWordBoundary" xml:space="preserve">
    <value>Word boundary</value>
  </data>
  <data name="CheatSheetWordBoundaryDetails" xml:space="preserve">
    <value>Matches a word boundary position between a word character and non-word character or position (start / end of string). See the word character class (w) for more info.</value>
  </data>
  <data name="CheatSheetWordDetails" xml:space="preserve">
    <value>Matches any word character (alphanumeric &amp; underscore). Only matches low-ascii characters (no accented or non-roman characters). Equivalent to [A-Za-z0-9_]</value>
  </data>
  <data name="Configuration" xml:space="preserve">
    <value>Configuration</value>
  </data>
  <data name="CultureInvariant" xml:space="preserve">
    <value>Culture Invariant</value>
  </data>
  <data name="CultureInvariantDescription" xml:space="preserve">
    <value>Specifies that cultural differences in language is ignored.</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Validate and test regular expressions</value>
  </data>
  <data name="EcmaScript" xml:space="preserve">
    <value>ECMA Script</value>
  </data>
  <data name="EcmaScriptDescription" xml:space="preserve">
    <value>Enables ECMAScript-compliant behavior for the expression. This value can be used only in conjunction with the Culture Invariant, Ignore Case and Multiline options.</value>
  </data>
  <data name="IgnoreCase" xml:space="preserve">
    <value>Ignore Case</value>
  </data>
  <data name="IgnoreCaseDescription" xml:space="preserve">
    <value>Specifies case-insensitive matching.</value>
  </data>
  <data name="IgnoreWhitespace" xml:space="preserve">
    <value>Ignore Whitespace</value>
  </data>
  <data name="IgnoreWhitespaceDescription" xml:space="preserve">
    <value>Eliminates unescaped white space from the pattern and enables comments marked with #. However, this value does not affect or eliminate white space in character classes, numeric quantifiers, or tokens that mark the beginning of individual regular expression language elements.</value>
  </data>
  <data name="LongDisplayTitle" xml:space="preserve">
    <value>Regular Expression Tester</value>
  </data>
  <data name="MatchGroupPrefix" xml:space="preserve">
    <value>Group</value>
  </data>
  <data name="MatchInformation" xml:space="preserve">
    <value>Match information</value>
  </data>
  <data name="MatchLocation" xml:space="preserve">
    <value>Location</value>
  </data>
  <data name="MatchName" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="MatchNamePrefix" xml:space="preserve">
    <value>Match</value>
  </data>
  <data name="MatchValue" xml:space="preserve">
    <value>Value</value>
  </data>
  <data name="Multiline" xml:space="preserve">
    <value>Multiline</value>
  </data>
  <data name="MultilineDescription" xml:space="preserve">
    <value>Changes the meaning of ^ and $ so they match at the beginning and end, respectively, of any line, and not just the beginning and end of the entire string.</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>Options</value>
  </data>
  <data name="RegularExpression" xml:space="preserve">
    <value>Regular expression</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>Right To Left</value>
  </data>
  <data name="RightToLeftDescription" xml:space="preserve">
    <value>Specifies that the search will be from right to left instead of from left to right.</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value>regular expression</value>
  </data>
  <data name="ShortDisplayTitle" xml:space="preserve">
    <value>RegEx Tester</value>
  </data>
  <data name="Singleline" xml:space="preserve">
    <value>Singleline</value>
  </data>
  <data name="SinglelineDescription" xml:space="preserve">
    <value>Changes the meaning of the dot (.) so it matches every character (instead of every character except \n).</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>Text</value>
  </data>
</root>