<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AppDescription" xml:space="preserve">
    <value>DevToys는 개발자를 위한 무료 오픈소스 도구 모음으로 가득한 도구 상자입니다. 개발 속도를 늦추는 성가신 일상 작업을 처리하기 위해 맞춤 제작된 스위스 군용 칼이라고 생각하세요.
알아야 할 사항은 다음과 같습니다:</value>
  </data>
  <data name="CheckForUpdate" xml:space="preserve">
    <value>DevToy 시작 시 업데이트 확인</value>
  </data>
  <data name="Continue" xml:space="preserve">
    <value>계속</value>
  </data>
  <data name="OfflineFirstDescription" xml:space="preserve">
    <value>DevToys는 오프라인 우선의 사고방식으로 운영됩니다. 저희는 문제 해결을 위해 최소한의 익명화된 데이터를 현지에서 수집합니다. 저희는 로그를 인터넷에 업로드하지 않습니다. 버그가 발생하여 보고하기로 선택한 경우 로그를 공유하도록 요청할 수 있습니다. 귀하의 동의 하에 인터넷에 연결하여 업데이트를 확인하고 최신 기능과 보안 향상에 액세스할 수 있도록 보장합니다.</value>
  </data>
  <data name="OfflineFirstTitle" xml:space="preserve">
    <value>오프라인 우선 원칙</value>
  </data>
  <data name="TrustButVerifyDescription" xml:space="preserve">
    <value>DevToys의 힘은 확장 프로그램과 함께 성장하여 도구 상자에 더 많은 기능을 추가합니다. 핵심 앱의 무결성은 보장하지만, 타사 확장 프로그램이 사용자의 컴퓨터와 데이터에 대해 수행하는 작업을 제어할 수 없다는 점을 알아두는 것이 중요합니다. 따라서 확장 프로그램을 설치할 때 주의를 기울이시기 바랍니다. DevToys 또는 확장 프로그램의 네트워크 활동을 모니터링하기 위해 Wireshark, Little Snitch 또는 Fiddler와 같은 도구를 사용하여 수신 및 발신 연결을 추적할 수 있습니다.</value>
  </data>
  <data name="TrustButVerifyTitle" xml:space="preserve">
    <value>신뢰하지만 검증</value>
  </data>
  <data name="UnderstandAndAgree" xml:space="preserve">
    <value>이를 이해하고 동의합니다.</value>
  </data>
  <data name="Welcome" xml:space="preserve">
    <value>DevToys에 오신 것을 환영합니다!</value>
  </data>
</root>