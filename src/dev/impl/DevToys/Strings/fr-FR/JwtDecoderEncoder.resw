<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Encodeur et Décodeur de JWT</value>
  </data>
  <data name="MenuDisplayName" xml:space="preserve">
    <value>JWT</value>
  </data>
  <data name="JwtHeaderLabel" xml:space="preserve">
    <value>En-tête</value>
  </data>
  <data name="JwtTokenLabel" xml:space="preserve">
    <value>Jeton</value>
  </data>
  <data name="JwtPayloadLabel" xml:space="preserve">
    <value>Charge utile</value>
  </data>
  <data name="Type" xml:space="preserve">
    <value>Type de texte</value>
  </data>
  <data name="Value" xml:space="preserve">
    <value>Valeur</value>
  </data>
  <data name="DescriptionHeader" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Décoder un en-tête, une charge utile et une signature JWT</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value/>
  </data>
  <data name="Algorithm" xml:space="preserve">
    <value>Algorithme</value>
  </data>
  <data name="DecodeSwitchModeLabel" xml:space="preserve">
    <value>Décoder</value>
  </data>
  <data name="DecodeValidateTokenLabel" xml:space="preserve">
    <value>Valider le jeton</value>
  </data>
  <data name="DecodeValidateTokenNoLabel" xml:space="preserve">
    <value>Non</value>
  </data>
  <data name="DecodeValidateTokenYesLabel" xml:space="preserve">
    <value>Oui</value>
  </data>
  <data name="EncodeExpirationTitle" xml:space="preserve">
    <value>Le jeton a une date d'expiration</value>
  </data>
  <data name="EncodeExpirationMonthLabel" xml:space="preserve">
    <value>Expire en mois(s)</value>
  </data>
  <data name="EncodeExpirationYearLabel" xml:space="preserve">
    <value>Expire en année(s)</value>
  </data>
  <data name="EncodeHashingTitle" xml:space="preserve">
    <value>Algorithme de hachage du jeton</value>
  </data>
  <data name="EncodeSettingsTitle" xml:space="preserve">
    <value>Paramètres</value>
  </data>
  <data name="EncodeSwitchModeLabel" xml:space="preserve">
    <value>Encoder</value>
  </data>
  <data name="SettingsSwitchModeLabel" xml:space="preserve">
    <value>Encoder / Décoder</value>
  </data>
  <data name="SettingsTitle" xml:space="preserve">
    <value>Configuration</value>
  </data>
  <data name="EncodeDefaultTimeTitle" xml:space="preserve">
    <value>Le jeton a une heure par défaut</value>
  </data>
  <data name="EncodeExpirationDaysLabel" xml:space="preserve">
    <value>Expire dans le(s) jour(s)</value>
  </data>
  <data name="EncodeExpirationHoursLabel" xml:space="preserve">
    <value>Expire en heure(s)</value>
  </data>
  <data name="EncodeExpirationMinutesLabel" xml:space="preserve">
    <value>Expire en minute(s)</value>
  </data>
  <data name="PrivateKeyLabel" xml:space="preserve">
    <value>Clé privée</value>
  </data>
  <data name="SignatureLabel" xml:space="preserve">
    <value>Signature</value>
  </data>
  <data name="JwtNotValidated" xml:space="preserve">
    <value>Jeton non validé (aucun paramètre sélectionné)</value>
  </data>
  <data name="JwtIsValidMessage" xml:space="preserve">
    <value>Jeton validé</value>
  </data>
  <data name="InvalidPublicKeyError" xml:space="preserve">
    <value>Clé publique invalide</value>
  </data>
  <data name="JwtInValidMessage" xml:space="preserve">
    <value>Signature invalide</value>
  </data>
  <data name="DecodeValidateActorLabel" xml:space="preserve">
    <value>Valider l'acteur</value>
  </data>
  <data name="DecodeValidateAudienceLabel" xml:space="preserve">
    <value>Valider l'audience</value>
  </data>
  <data name="DecodeValidateIssuerSigningKey" xml:space="preserve">
    <value>Valider la clé de signature de l'émetteur</value>
  </data>
  <data name="DecodeValidateIssuerLabel" xml:space="preserve">
    <value>Valider l'émetteur</value>
  </data>
  <data name="DecodeValidateLifetimeLabel" xml:space="preserve">
    <value>Valider la durée de vie</value>
  </data>
  <data name="ValidAudiencesLabel" xml:space="preserve">
    <value>Audiences valides</value>
  </data>
  <data name="ValidIssuersLabel" xml:space="preserve">
    <value>Emetteurs valides</value>
  </data>
  <data name="DecodeValidationSettingsDescription" xml:space="preserve">
    <value>Sélectionnez les paramètres de jeton à valider</value>
  </data>
  <data name="DecodeValidationSettingsTitle" xml:space="preserve">
    <value>Paramètres de validation du jeton</value>
  </data>
  <data name="ValidAudiencesError" xml:space="preserve">
    <value>Les audiences valides sont vides</value>
  </data>
  <data name="ValidIssuersError" xml:space="preserve">
    <value>Les émetteurs valides sont vides</value>
  </data>
  <data name="PublicKeyIsPrivateKeyError" xml:space="preserve">
    <value>La clé publique fournie est une clé privée</value>
  </data>
  <data name="EncodeAudienceLabel" xml:space="preserve">
    <value>Le jeton a une audience</value>
  </data>
  <data name="EncodeIssuerLabel" xml:space="preserve">
    <value>Le jeton a un émetteur</value>
  </data>
  <data name="EncodeSettingsDescription" xml:space="preserve">
    <value>Sélectionnez les paramètres de jeton</value>
  </data>
  <data name="InvalidPrivateKeyError" xml:space="preserve">
    <value>Clé privée invalide</value>
  </data>
  <data name="PublicKeyLabel" xml:space="preserve">
    <value>Clé publique</value>
  </data>
  <data name="SearchDisplayName" xml:space="preserve">
    <value>Encodeur / Décodeur de JWT</value>
  </data>
  <data name="InvalidSignatureError" xml:space="preserve">
    <value>Signature invalide</value>
  </data>
  <data name="NoDescription" xml:space="preserve">
    <value>Aucune description</value>
  </data>
  <data name="iss" xml:space="preserve">
    <value>La réclamation « iss» (émetteur) identifie le principal qui a émis la JWT. La valeur "iss" est une chaîne sensible à la casse contenant une valeur StringOrURI. L'utilisation de cette requête est OPTIONAL.</value>
  </data>
  <data name="sub" xml:space="preserve">
    <value>L'allégation « sous-» (sujet) identifie le principal qui fait l'objet de la JWT. La valeur du sujet DOIT être portée pour être unique localement dans le contexte de l'émetteur ou être unique au niveau mondial. Le traitement de cette demande est généralement spécifique à l'application. La valeur "sub" est une chaîne sensible à la casse contenant une valeur StringOrURI. L'utilisation de cette requête est OPTIONNEL.</value>
  </data>
  <data name="aud" xml:space="preserve">
    <value>La demande d'« audit » (audience) identifie les récipiendaires auxquels la JWT est destinée. Chaque directeur qui a l'intention de traiter la JWT DOIT s'identifier à une valeur dans la revendication du public. Si le traitement principal de la réclamation ne s'identifie pas à une valeur dans la réclamation "aud" lorsque cette revendication est présente, alors le JWT DOIT être rejeté. Dans le cas général, la valeur « aud» est un tableau de chaînes sensibles à la casse, chacune contenant une valeur StringOrURI. Dans le cas spécial où le JWT a un auditoire, la valeur "aud" peut être une seule chaîne sensible à la casse contenant une valeur StringOrURI. L'interprétation des valeurs du public est généralement spécifique à l'application; l'utilisation de cette revendication est OPTIONNEL.</value>
  </data>
  <data name="exp" xml:space="preserve">
    <value>La réclamation "exp" (date d'expiration) identifie le délai d'expiration à partir duquel la JWT NE DOIT PAS être acceptée pour le traitement. Le traitement de la demande d'« exp» exige que la date/heure actuelle DOIT être avant la date d'expiration/heure énumérée dans la demande « exp». Les implémentateurs PEUVENT prévoir une petite marge de manoeuvre, généralement pas plus de quelques minutes, pour tenir compte de la décalage horloger. Sa valeur DOIT être un nombre contenant une valeur numérique Date. L'utilisation de cette réclamation est OPTIONNEL.</value>
  </data>
  <data name="nbf" xml:space="preserve">
    <value>La réclamation "exp" (date d'expiration) identifie le délai d'expiration à partir duquel la JWT NE DOIT PAS être acceptée pour le traitement. Le traitement de la demande d'« exp» exige que la date/heure actuelle DOIT être avant la date d'expiration/heure énumérée dans la demande « exp». Les implémentateurs PEUVENT prévoir une petite marge de manoeuvre, généralement pas plus de quelques minutes, pour tenir compte de la décalage horloger. Sa valeur DOIT être un nombre contenant une valeur numérique Date. L'utilisation de cette réclamation est OPTIONNEL.</value>
  </data>
  <data name="iat" xml:space="preserve">
    <value>La déclaration « iat » (émise à) indique le moment où la JW a été émise. Cette déclaration peut être utilisée pour déterminer l'âge de la JWT. Sa valeur DOIT être un nombre contenant une valeur numérique Date. L'utilisation de cette réclamation est OPTIONNEL.</value>
  </data>
  <data name="jti" xml:space="preserve">
    <value>La réclamation « jti » (ID JWT) fournit un identifiant unique pour la JWT. La valeur de l'identifiant DOIT être assignée d'une manière qui garantit qu'il y a une probabilité négligeable que la même valeur soit accidentellement affectée à un objet de données différent ; si l'application utilise plusieurs émetteurs, les collisions DOIVENT être évitées parmi les valeurs produites par différents émetteurs également. La revendication « jti » peut être utilisée pour empêcher la JWT d'être rejouée. La valeur "jti" est une chaîne sensible à la casse. L'utilisation de cette revendication est OPTIONNEL.</value>
  </data>
  <data name="name" xml:space="preserve">
    <value>Le nom complet de l'utilisateur final sous forme affichable incluant toutes les parties de noms, y compris les titres et les suffixes, classés selon la locale et les préférences de l'utilisateur final.</value>
  </data>
  <data name="given_name" xml:space="preserve">
    <value>Prénom(s) ou prénom(s) de l'Utilisateur final. Notez que dans certaines cultures, les personnes peuvent avoir plusieurs prénoms ; tous peuvent être présents, les noms étant séparés par des espaces.</value>
  </data>
  <data name="family_name" xml:space="preserve">
    <value>Nom(s) ou nom(s) de famille de l'utilisateur final. Notez que dans certaines cultures, les gens peuvent avoir plusieurs noms de famille ou aucun nom de famille ; tous peuvent être présents, les noms étant séparés par des espaces.</value>
  </data>
  <data name="middle_name" xml:space="preserve">
    <value>Deuxième(s) prénom(s) de l'utilisateur final. Notez que dans certaines cultures, les personnes peuvent avoir plusieurs deuxièmes prénoms ; tous peuvent être présents, les noms étant séparés par des espaces. Notez également que dans certaines cultures, les prénoms ne sont pas utilisés.</value>
  </data>
  <data name="nickname" xml:space="preserve">
    <value>Nom occasionnel de l'utilisateur final qui peut ou non être le même que le nom_donné. Par exemple, une valeur de surnom de Mike peut être renvoyée avec une valeur given_name de Michael.</value>
  </data>
  <data name="preferred_username" xml:space="preserve">
    <value>Nom abrégé par lequel l'utilisateur final souhaite être référencé au RP, tel que janedoe ou j.doe. Cette valeur PEUT être n'importe quelle chaîne JSON valide comprenant des caractères spéciaux tels que @, / ou des espaces. Le RP NE DOIT PAS se fier au fait que cette valeur est unique.</value>
  </data>
  <data name="profile" xml:space="preserve">
    <value>URL de la page de profil de l'utilisateur final. Le contenu de cette page Web DOIT concerner l'utilisateur final.</value>
  </data>
  <data name="picture" xml:space="preserve">
    <value>URL de la photo de profil de l'utilisateur final. Cette URL DOIT faire référence à un fichier image (par exemple, un fichier image PNG, JPEG ou GIF), plutôt qu'à une page Web contenant une image. Notez que cette URL DEVRAIT spécifiquement faire référence à une photo de profil de l'utilisateur final pouvant être affichée lors de la description de l'utilisateur final, plutôt qu'à une photo arbitraire prise par l'utilisateur final.</value>
  </data>
  <data name="website" xml:space="preserve">
    <value>URL de la page Web ou du blog de l'utilisateur final. Cette page Web DEVRAIT contenir des informations publiées par l'utilisateur final ou une organisation à laquelle l'utilisateur final est affilié.</value>
  </data>
  <data name="email" xml:space="preserve">
    <value>Adresse e-mail préférée de l'utilisateur final. Sa valeur DOIT être conforme à la syntaxe RFC 5322 addr-spec. Le RP NE DOIT PAS se fier au fait que cette valeur est unique.</value>
  </data>
  <data name="email_verified" xml:space="preserve">
    <value>Vrai si l'adresse e-mail de l'utilisateur final a été vérifiée ; sinon faux. Lorsque cette valeur de réclamation est vraie, cela signifie que l'OP a pris des mesures positives pour s'assurer que cette adresse e-mail était contrôlée par l'utilisateur final au moment où la vérification a été effectuée. Les moyens par lesquels une adresse e-mail est vérifiée sont spécifiques au contexte et dépendent du cadre de confiance ou des accords contractuels dans lesquels les parties opèrent.</value>
  </data>
  <data name="gender" xml:space="preserve">
    <value>Sexe de l'utilisateur final. Les valeurs définies par cette spécification sont féminines et masculines. D'autres valeurs PEUVENT être utilisées lorsqu'aucune des valeurs définies n'est applicable.</value>
  </data>
  <data name="birthdate" xml:space="preserve">
    <value>Anniversaire de l'utilisateur final, représenté au format ISO 8601:2004 AAAA-MM-JJ. L'année PEUT être 0000, indiquant qu'elle est omise. Pour représenter uniquement l'année, le format AAAA est autorisé. Notez qu'en fonction de la fonction liée à la date de la plate-forme sous-jacente, fournir uniquement l'année peut entraîner des variations de mois et de jour, de sorte que les implémenteurs doivent prendre en compte ce facteur pour traiter correctement les dates.</value>
  </data>
  <data name="zoneinfo" xml:space="preserve">
    <value>Chaîne de la base de données de fuseaux horaires zoneinfo représentant le fuseau horaire de l'utilisateur final. Par exemple, Europe/Paris ou Amérique/Los_Angeles.</value>
  </data>
  <data name="locale" xml:space="preserve">
    <value>Paramètres régionaux de l'utilisateur final, représentés par une balise de langue BCP47 [RFC5646]. Il s'agit généralement d'un code de langue ISO 639-1 Alpha-2 en minuscules et d'un code de pays ISO 3166-1 Alpha-2 en majuscules, séparés par un tiret. Par exemple, en-US ou fr-CA. Comme note de compatibilité, certaines implémentations ont utilisé un trait de soulignement comme séparateur plutôt qu'un tiret, par exemple, en_US ; Les parties utilisatrices PEUVENT également accepter cette syntaxe locale.</value>
  </data>
  <data name="phone_number" xml:space="preserve">
    <value>Numéro de téléphone préféré de l'utilisateur final. E.164 est RECOMMANDÉ comme format de cette demande, par exemple, +1 (425) 555-1212 ou +56 (2) 687 2400. Si le numéro de téléphone contient une extension, il est RECOMMANDÉ que l'extension soit représentée en utilisant le Syntaxe d'extension RFC 3966, par exemple, +1 (604) 555-1234;ext=5678.</value>
  </data>
  <data name="phone_number_verified" xml:space="preserve">
    <value>Vrai si le numéro de téléphone de l'utilisateur final a été vérifié ; sinon faux. Lorsque cette valeur de réclamation est vraie, cela signifie que l'OP a pris des mesures positives pour s'assurer que ce numéro de téléphone était contrôlé par l'utilisateur final au moment où la vérification a été effectuée. Le moyen par lequel un numéro de téléphone est vérifié est spécifique au contexte et dépend du cadre de confiance ou des accords contractuels dans lesquels les parties opèrent. Lorsqu'elle est vraie, la demande de numéro de téléphone DOIT être au format E.164 et toutes les extensions DOIVENT être représentées au format RFC 3966.</value>
  </data>
  <data name="address" xml:space="preserve">
    <value>Adresse postale préférée de l'utilisateur final. La valeur du membre d'adresse est une structure JSON [RFC4627].</value>
  </data>
  <data name="updated_at" xml:space="preserve">
    <value>Heure à laquelle les informations de l'utilisateur final ont été mises à jour pour la dernière fois. Sa valeur est un nombre JSON représentant le nombre de secondes entre 1970-01-01T0:0:0Z tel que mesuré en UTC jusqu'à la date/heure.</value>
  </data>
  <data name="azp" xml:space="preserve">
    <value>Partie autorisée - la partie à laquelle le jeton d'identification a été émis. S'il est présent, il DOIT contenir l'ID client OAuth 2.0 de cette partie. Cette réclamation n'est nécessaire que lorsque le jeton d'identification a une seule valeur d'audience et que cette audience est différente de la partie autorisée. Il PEUT être inclus même lorsque la partie autorisée est la même que le public unique. La valeur azp est une chaîne sensible à la casse contenant une valeur StringOrURI.</value>
  </data>
  <data name="nonce" xml:space="preserve">
    <value>Valeur de chaîne utilisée pour associer une session client à un jeton d'identification et pour atténuer les attaques par relecture. La valeur est transmise sans modification de la demande d'authentification au jeton d'identification. S'il est présent dans le jeton d'identification, les clients DOIVENT vérifier que la valeur de réclamation nonce est égale à la valeur du paramètre nonce envoyé dans la demande d'authentification. S'ils sont présents dans la demande d'authentification, les serveurs d'autorisation DOIVENT inclure une revendication nonce dans le jeton d'identification, la valeur de la revendication étant la valeur nonce envoyée dans la demande d'authentification. Les serveurs d'autorisation NE DEVRAIENT effectuer aucun autre traitement sur les valeurs nonce utilisées. La valeur nonce est une chaîne sensible à la casse.</value>
  </data>
  <data name="auth_time" xml:space="preserve">
    <value>Heure à laquelle l'authentification de l'utilisateur final s'est produite. Sa valeur est un nombre JSON représentant le nombre de secondes entre 1970-01-01T0:0:0Z tel que mesuré en UTC jusqu'à la date/heure. Lorsqu'une demande max_age est effectuée ou lorsqu'auth_time est demandé en tant que Revendication Essentielle, alors cette Revendication est OBLIGATOIRE ; sinon, son inclusion est OPTIONNELLE. (La revendication auth_time correspond sémantiquement au paramètre de réponse OpenID 2.0 PAPE auth_time.)</value>
  </data>
  <data name="at_hash" xml:space="preserve">
    <value>Valeur de hachage du jeton d'accès. Sa valeur est le codage base64url de la moitié la plus à gauche du hachage des octets de la représentation ASCII de la valeur access_token, où l'algorithme de hachage utilisé est l'algorithme de hachage utilisé dans le paramètre d'en-tête alg de l'en-tête JOSE du jeton d'identification. Par exemple, si l'alg est RS256, hachez la valeur access_token avec SHA-256, puis prenez les 128 bits les plus à gauche et codez-les en base64url. La valeur at_hash est une chaîne sensible à la casse.</value>
  </data>
  <data name="c_hash" xml:space="preserve">
    <value>Valeur de hachage du code. Sa valeur est le codage base64url de la moitié la plus à gauche du hachage des octets de la représentation ASCII de la valeur de code, où l'algorithme de hachage utilisé est l'algorithme de hachage utilisé dans le paramètre d'en-tête alg de l'en-tête JOSE du jeton d'identification. Par exemple, si l'alg est HS512, hachez la valeur du code avec SHA-512, puis prenez les 256 bits les plus à gauche et codez-les en base64url. La valeur c_hash est une chaîne sensible à la casse. Si le jeton d'identification est émis à partir du point de terminaison d'autorisation avec un code, ce qui est le cas pour les valeurs response_type code id_token et code id_token token, ceci est OBLIGATOIRE ; sinon, son inclusion est OPTIONNELLE.</value>
  </data>
  <data name="acr" xml:space="preserve">
    <value>Référence de classe de contexte d'authentification. Chaîne spécifiant une valeur de référence de classe de contexte d'authentification qui identifie la classe de contexte d'authentification satisfaite par l'authentification effectuée. La valeur "0" indique que l'authentification de l'utilisateur final n'a pas satisfait aux exigences de la norme ISO/IEC 29115 niveau 1. L'authentification à l'aide d'un cookie de navigateur à longue durée de vie, par exemple, est un exemple où l'utilisation du "niveau 0" est appropriée. Les authentifications de niveau 0 NE DEVRAIENT PAS être utilisées pour autoriser l'accès à une ressource de quelque valeur monétaire que ce soit. (Ceci correspond au PAPE OpenID 2.0 nist_auth_level 0.) Un URI absolu ou un nom enregistré RFC 6711 DEVRAIT être utilisé comme valeur acr ; les noms enregistrés NE DOIVENT PAS être utilisés avec une signification différente de celle qui est enregistrée. Les parties utilisant cette allégation devront s'entendre sur la signification des valeurs utilisées, qui peuvent être spécifiques au contexte. La valeur acr est une chaîne sensible à la casse.</value>
  </data>
  <data name="amr" xml:space="preserve">
    <value>Références des méthodes d'authentification. Tableau JSON de chaînes qui sont des identifiants pour les méthodes d'authentification utilisées dans l'authentification. Par exemple, les valeurs peuvent indiquer que les méthodes d'authentification par mot de passe et OTP ont été utilisées. Les parties utilisant cette allégation devront s'entendre sur la signification des valeurs utilisées, qui peuvent être spécifiques au contexte. La valeur amr est un tableau de chaînes sensibles à la casse.</value>
  </data>
  <data name="sub_jwk" xml:space="preserve">
    <value>Clé publique utilisée pour vérifier la signature d'un jeton d'identification émis par un fournisseur OpenID auto-émis. La clé est une clé nue au format JWK (pas une valeur de certificat X.509). La valeur sub_jwk est un objet JSON. L'utilisation de la revendication sub_jwk n'est PAS RECOMMANDÉE lorsque l'OP n'est pas auto-émis.</value>
  </data>
</root>
