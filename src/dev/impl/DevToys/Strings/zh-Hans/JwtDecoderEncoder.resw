<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>JWT 编码器 / 解码器</value>
  </data>
  <data name="MenuDisplayName" xml:space="preserve">
    <value>JWT</value>
  </data>
  <data name="JwtHeaderLabel" xml:space="preserve">
    <value>头部</value>
  </data>
  <data name="JwtTokenLabel" xml:space="preserve">
    <value>令牌</value>
  </data>
  <data name="JwtPayloadLabel" xml:space="preserve">
    <value>有效载荷</value>
  </data>
  <data name="Type" xml:space="preserve">
    <value>类型</value>
  </data>
  <data name="Value" xml:space="preserve">
    <value>值</value>
  </data>
  <data name="DescriptionHeader" xml:space="preserve">
    <value>描述</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>解码 JWT 头部、有效载荷和签名</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value/>
  </data>
  <data name="Algorithm" xml:space="preserve">
    <value>算法</value>
  </data>
  <data name="DecodeSwitchModeLabel" xml:space="preserve">
    <value>解码</value>
  </data>
  <data name="DecodeValidateTokenLabel" xml:space="preserve">
    <value>验证令牌</value>
  </data>
  <data name="DecodeValidateTokenNoLabel" xml:space="preserve">
    <value>否</value>
  </data>
  <data name="DecodeValidateTokenYesLabel" xml:space="preserve">
    <value>是</value>
  </data>
  <data name="EncodeExpirationTitle" xml:space="preserve">
    <value>访问令牌有到期日期</value>
  </data>
  <data name="EncodeExpirationMonthLabel" xml:space="preserve">
    <value>过期时间(月)</value>
  </data>
  <data name="EncodeExpirationYearLabel" xml:space="preserve">
    <value>过期时间(年)</value>
  </data>
  <data name="EncodeHashingTitle" xml:space="preserve">
    <value>令牌散列算法</value>
  </data>
  <data name="EncodeSettingsTitle" xml:space="preserve">
    <value>设置</value>
  </data>
  <data name="EncodeSwitchModeLabel" xml:space="preserve">
    <value>编码</value>
  </data>
  <data name="SettingsSwitchModeLabel" xml:space="preserve">
    <value>编码 / 解码</value>
  </data>
  <data name="SettingsTitle" xml:space="preserve">
    <value>配置</value>
  </data>
  <data name="EncodeDefaultTimeTitle" xml:space="preserve">
    <value>令牌具有默认时间</value>
  </data>
  <data name="EncodeExpirationDaysLabel" xml:space="preserve">
    <value>过期时间(日)</value>
  </data>
  <data name="EncodeExpirationHoursLabel" xml:space="preserve">
    <value>过期时间(时)</value>
  </data>
  <data name="EncodeExpirationMinutesLabel" xml:space="preserve">
    <value>过期时间(分)</value>
  </data>
  <data name="PrivateKeyLabel" xml:space="preserve">
    <value>私钥</value>
  </data>
  <data name="SignatureLabel" xml:space="preserve">
    <value>签名</value>
  </data>
  <data name="JwtNotValidated" xml:space="preserve">
    <value>令牌未验证（未选择参数）</value>
  </data>
  <data name="JwtIsValidMessage" xml:space="preserve">
    <value>令牌已验证</value>
  </data>
  <data name="InvalidPublicKeyError" xml:space="preserve">
    <value>公钥无效</value>
  </data>
  <data name="JwtInValidMessage" xml:space="preserve">
    <value>签名无效</value>
  </data>
  <data name="DecodeValidateActorLabel" xml:space="preserve">
    <value>验证执行者</value>
  </data>
  <data name="DecodeValidateAudienceLabel" xml:space="preserve">
    <value>验证接收者</value>
  </data>
  <data name="DecodeValidateIssuerSigningKey" xml:space="preserve">
    <value>验证签发者签名密钥</value>
  </data>
  <data name="DecodeValidateIssuerLabel" xml:space="preserve">
    <value>验证签发者</value>
  </data>
  <data name="DecodeValidateLifetimeLabel" xml:space="preserve">
    <value>验证生存时间</value>
  </data>
  <data name="ValidAudiencesLabel" xml:space="preserve">
    <value>有效的接收者</value>
  </data>
  <data name="ValidIssuersLabel" xml:space="preserve">
    <value>有效的签发者</value>
  </data>
  <data name="DecodeValidationSettingsDescription" xml:space="preserve">
    <value>选择要验证的令牌参数</value>
  </data>
  <data name="DecodeValidationSettingsTitle" xml:space="preserve">
    <value>令牌验证设置</value>
  </data>
  <data name="ValidAudiencesError" xml:space="preserve">
    <value>有效的接收者为空</value>
  </data>
  <data name="ValidIssuersError" xml:space="preserve">
    <value>有效的签发者为空</value>
  </data>
  <data name="PublicKeyIsPrivateKeyError" xml:space="preserve">
    <value>所提供的公钥是私钥</value>
  </data>
  <data name="EncodeAudienceLabel" xml:space="preserve">
    <value>令牌具有接收者</value>
  </data>
  <data name="EncodeIssuerLabel" xml:space="preserve">
    <value>令牌具有签发者</value>
  </data>
  <data name="EncodeSettingsDescription" xml:space="preserve">
    <value>选择令牌参数</value>
  </data>
  <data name="InvalidPrivateKeyError" xml:space="preserve">
    <value>私钥无效</value>
  </data>
  <data name="PublicKeyLabel" xml:space="preserve">
    <value>公钥</value>
  </data>
  <data name="SearchDisplayName" xml:space="preserve">
    <value>JWT 编码器 / 解码器</value>
  </data>
  <data name="InvalidSignatureError" xml:space="preserve">
    <value>无效签名</value>
  </data>
  <data name="NoDescription" xml:space="preserve">
    <value>没有描述</value>
  </data>
  <data name="iss" xml:space="preserve">
    <value>“iss”（issuer，签发者）声明指出签发 JWT 的一方。对此声明的处理一般因应用而异。“iss”值是一个包含 StringOrURI 值的字符串，区分大小写。此声明的使用不是必须的。</value>
  </data>
  <data name="sub" xml:space="preserve">
    <value>“sub”（subject，主题）声明指出 JWT 的主题。JWT 中的声明通常是与主题相关的说明。主题的值必须在签发者上下文局部或全局唯一。对此声明的处理一般因应用而异。“sub”值是一个包含 StringOrURI 值的字符串，区分大小写。此声明的使用不是必须的。</value>
  </data>
  <data name="aud" xml:space="preserve">
    <value>“aud”（audience，接收者）声明指出 JWT 预定的接收对象。希望处理 JWT 的各方必须在接收者声明中为自己指定一个值。如果处理该声明的一方在“aud”声明提交时没有在其中为自己指定一个值，JWT 就会被拒绝。通常情况下，“aud”值是一个数组，包含 StringOrURI 值的字符串，区分大小写。在 JWT 只有一个接收者的特殊情况下，“aud”值可能是包含 StringOrURI 值的单一字符串，区分大小写。对接收者值的解释一般因应用而异。此声明的使用不是必须的。</value>
  </data>
  <data name="exp" xml:space="preserve">
    <value>“exp”（expiration time，到期时间）声明指出不接受处理 JWT 的到期时间。对“exp”声明的处理要求当前日期/时间必须在“exp”声明所列出的到期日期/时间之前。考虑到时钟偏移，实现器可能会提供通常不多于几分钟的弹性时间。声明的值必须是一个包含 NumericDate 值的数值。此声明的使用不是必须的。</value>
  </data>
  <data name="nbf" xml:space="preserve">
    <value>“nbf”（not before，不早于）声明指出不接受处理 JWT 的最晚时间。对“nbf”声明的处理要求当前日期/时间必须在“nbf”声明所列出的最晚日期/时间之后或与之相等。考虑到时钟偏移，实现器可能会提供通常不多于几分钟的弹性时间。声明的值必须是一个包含 NumericDate 值的数值。此声明的使用不是必须的。</value>
  </data>
  <data name="iat" xml:space="preserve">
    <value>“iat”（签发时间）声明指出 JWT 签发的时间。此声明可用于确定 JWT 的存在时间。声明的值必须是一个包含 NumericDate 值的数值。此声明的使用不是必须的。</value>
  </data>
  <data name="jti" xml:space="preserve">
    <value>“jti”（JWT ID）声明为 JWT 提供独特标识符。标识符的值必须以特定方式分配，这种方式应确保相同值会以极小概率分配给另一数据对象；如果应用使用多个签发者，则还应避免不同签发者产生的值不会互相冲突。“jti”声明可用于防止 JWT 重放。“jti”值是一个字符串，区分大小写。此声明的使用不是必须的。</value>
  </data>
  <data name="name" xml:space="preserve">
    <value>最终用户的全名，displayable 形式，包括全部姓名结构，还可能包括标题和后缀，按最终用户的区域和偏好设置排序。</value>
  </data>
  <data name="given_name" xml:space="preserve">
    <value>最终用户的名。注意，在某些文化圈，一个人可以拥有多个名；多个名会以空格符分隔显示。</value>
  </data>
  <data name="family_name" xml:space="preserve">
    <value>最终用户的姓。注意，在某些文化圈，一个人可以拥有多个姓或不拥有姓；多个姓会以空格符分隔显示。</value>
  </data>
  <data name="middle_name" xml:space="preserve">
    <value>最终用户的中间名。注意，在某些文化圈，一个人可以拥有多个中间名或不拥有中间名；多个中间名会以空格符分隔显示。</value>
  </data>
  <data name="nickname" xml:space="preserve">
    <value>最终用户的昵称，其可能与 given_name 值相同或不同。例如，可能会在返回 given_name 值 Michael 的同时返回 nickname 值 Mike。</value>
  </data>
  <data name="preferred_username" xml:space="preserve">
    <value>最终用户希望在 RP 中被指代的简记名，如 janedoe 或 j.doe。该值可能是任意有效的 JSON 字符串，包含特殊字符如 @、/ 或空格。RP 不应认定该值唯一。</value>
  </data>
  <data name="profile" xml:space="preserve">
    <value>最终用户个人资料页面的 URL。此网页的内容应与最终用户有关。</value>
  </data>
  <data name="picture" xml:space="preserve">
    <value>最终用户个人资料图片的 URL。此 URL 必须指定一个图像文件（如一个 PNG、JPEG 或 GIF 图像文件）而不是包含图像的网页。注意，此 URL 应确保是一张在描述最终用户时适合展示的个人照片，而非由最终用户随意拍摄的一张照片。</value>
  </data>
  <data name="website" xml:space="preserve">
    <value>最终用户个人网页或博客的 URL。此网页应包含最终用户或其所属组织发布的信息。</value>
  </data>
  <data name="email" xml:space="preserve">
    <value>最终用户偏好的电子邮件地址。该值必须遵从 RFC 5322 addr-spec 语法。RP 不应认定该值唯一。</value>
  </data>
  <data name="email_verified" xml:space="preserve">
    <value>若最终用户的电子邮件地址已验证则为 true，否则为 false。此声明值为 true ，说明 OP 通过一定措施确认了在验证时，此电子邮件地址由最终用户控制。确认电子邮件地址已验证的方式因实际情形而异，同时取决于当事各方采用的信托框架或合同协议。</value>
  </data>
  <data name="gender" xml:space="preserve">
    <value>最终用户的性别。此规范定义的值为 female（女性）和 male（男性）。在已定义的值不适用的情形下，可以使用其他值。</value>
  </data>
  <data name="birthdate" xml:space="preserve">
    <value>最终用户的生日，依照 ISO 8601:2004 YYYY-MM-DD 格式。年份可以用 0000 表示省略。若只表示年份，允许采用 YYYY 格式。注意，取决于底层平台的日期相关函数，只提供年份可能会导致月份及日期有所出入，所以实现器需要考虑到此因素以正确处理日期。</value>
  </data>
  <data name="zoneinfo" xml:space="preserve">
    <value>zoneinfo 时区数据库字符串，代表最终用户的时区。如 Europe/Paris 或 America/Los_Angeles。</value>
  </data>
  <data name="locale" xml:space="preserve">
    <value>最终用户的区域，依照 BCP47 [RFC5646] 语言标签表示。通常组成为一个小写 ISO 639-1 Alpha-2 语言代码加上一个大写 ISO 3166-1 Alpha-2 国家代码，中间用短横线分隔。如 en-US 或 fr-CA。出于兼容性说明，某些实现使用下划线而不是短横线作为分隔符，如 en_US；依赖方可能也会接受这种区域语法。</value>
  </data>
  <data name="phone_number" xml:space="preserve">
    <value>最终用户偏好的电话号码。此声明推荐依照 E. 164 格式，如 +1 (425) 555-1212 或 +56 (2) 687 2400。如果电话号码中包含分机号，推荐该部分使用 RFC 3966 分机号语法，如 +1 (604) 555-1234;ext=5678。</value>
  </data>
  <data name="phone_number_verified" xml:space="preserve">
    <value>若最终用户的电话号码已验证则为 true，否则为 false。此声明值为 true ，说明 OP 通过一定措施确认了在验证时，此电话号码由最终用户控制。确认电话号码已验证的方式因实际情形而异，同时取决于当事各方采用的信托框架或合同协议。此声明值为 true 时，phone_number 声明必须依照 E. 164 格式，分机号必须依照 RFC 3966 格式。</value>
  </data>
  <data name="address" xml:space="preserve">
    <value>最终用户偏好的邮政地址。地址成员的值依照 JSON [RFC4627] 结构。</value>
  </data>
  <data name="updated_at" xml:space="preserve">
    <value>最终用户信息的最后更新时间。该值是一个 JSON 数值，代表从 1970-01-01T0:0:0Z 以来测量的 UTC 日期/时间对应的秒数。</value>
  </data>
  <data name="azp" xml:space="preserve">
    <value>授权方 - 签发 ID 令牌的一方。如果该声明存在，则必须包含其 OAuth 2.0 客户端 ID。此声明只在ID 令牌具有单一接收者值且接收者与授权方不同时需要给出。授权方与单一接收者相同时也可能会包含该声明。azp 值是一个包含 StringOrURI 值的字符串，区分大小写。</value>
  </data>
  <data name="nonce" xml:space="preserve">
    <value>用于将客户端回话与 ID 令牌关联并减少重放攻击的字符串值。此值不经修改地从身份验证请求传递给 ID 令牌。如果该值在 ID 令牌中存在，客户端必须验证 nonce 客户端值与身份验证请求中发送的 nonce 参数值相等。如果该值在身份验证请求中存在，身份验证服务器必须在 ID 令牌中包含 nonce 声明，声明值为身份验证请求中发送的 nonce 值。身份验证服务器不应对使用的 nonce 值做任何其他处理。nonce 值是一个区分大小写的字符串。</value>
  </data>
  <data name="auth_time" xml:space="preserve">
    <value>最终用户身份验证实施时间。该值是一个 JSON 数值，代表从 1970-01-01T0:0:0Z 以来测量的 UTC 日期/时间对应的秒数。当发出 max_age 请求或 auth_time 必须作为必要声明给出时，此声明是必需的；否则，此声明就是可选的。（auth_time 声明在语义上对应 OpenID 2.0 PAPE auth_time 响应参数。）</value>
  </data>
  <data name="at_hash" xml:space="preserve">
    <value>访问令牌散列值。此值是 access_token 值的 8 位 ASCII 形式散列值左半部分的 base64url 编码，使用的散列算法是用于 ID 令牌的 JOSE 头部的 alg 头部参数。例如，假设 alg 为 RS256，使用 SHA-256 将 access_token 值做散列运算，取出最左侧的 128 位，再使用 base64url 对其编码。at_hash 值是一个区分大小写的字符串。</value>
  </data>
  <data name="c_hash" xml:space="preserve">
    <value>code 散列值。此值是 code 值的 8 位 ASCII 形式散列值左半部分的 base64url 编码，使用的散列算法是用于 ID 令牌的 JOSE 头部的 alg 头部参数。例如，假设 alg 为 HS512，使用 SHA-512 将 code 值做散列运算，取出最左侧的 256 位，再使用 base64url 对其编码。c_hash 值是一个区分大小写的字符串。如果 ID 令牌从身份验证端附带 code 签发，且 response_type 值为 code id_token 和 code id_token token，此值是必需的；否则，此值就是可选的。</value>
  </data>
  <data name="acr" xml:space="preserve">
    <value>身份验证上下文类引用。是指定一个身份验证上下文类引用值的字符串，此值能够识别身份验证实施所满足的身份验证上下文类。值“0”表示最终用户身份验证未达到 ISO/IEC 29115 级别 1 的要求。例如，使用持久浏览器 cookie 进行身份验证是一个合适的“级别 0”的例子。级别 0 的身份验证不应用于授权访问任何货币值资源。（这对应 OpenID 2.0 PAPE nist_auth_level 0。）绝对 URI 或已注册 RFC 6711 名称应用作 acr 值；已注册名称不得使用与其本身不同的含义。使用此声明的各方需要对所使用值的含义达成一致，含义可能因上下文而异。acr 值是一个区分大小写的字符串。</value>
  </data>
  <data name="amr" xml:space="preserve">
    <value>身份验证方法引用。是在身份验证中使用的身份验证方法标识符字符串组成的 JSON 数组。例如，此值可能指出使用的密码和 OTP 身份验证方法。使用此声明的各方需要对所使用值的含义达成一致，含义可能因上下文而异。amr 值是一个数组，包含区分大小写的字符串。</value>
  </data>
  <data name="sub_jwk" xml:space="preserve">
    <value>公钥，用于检查自签发 OpenID 提供商签发的 ID 令牌签名。密钥为 JWK 格式的裸密钥（不是 X.509 证书值）。sub_jwk 值是一个 JSON 对象。当 OP 不是自签发时不推荐使用 sub_jwk 声明。</value>
  </data>
</root>
