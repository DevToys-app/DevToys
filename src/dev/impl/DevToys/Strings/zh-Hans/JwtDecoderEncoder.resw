<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>JWT 编码器 / 解码器</value>
  </data>
  <data name="MenuDisplayName" xml:space="preserve">
    <value>JWT</value>
  </data>
  <data name="JwtHeaderLabel" xml:space="preserve">
    <value>头部</value>
  </data>
  <data name="JwtTokenLabel" xml:space="preserve">
    <value>令牌</value>
  </data>
  <data name="JwtPayloadLabel" xml:space="preserve">
    <value>有效载荷</value>
  </data>
  <data name="Type" xml:space="preserve">
    <value>类型</value>
  </data>
  <data name="Value" xml:space="preserve">
    <value>值</value>
  </data>
  <data name="DescriptionHeader" xml:space="preserve">
    <value>描述</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>解码 JWT 头部、有效载荷和签名</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value/>
  </data>
  <data name="Algorithm" xml:space="preserve">
    <value>算法</value>
  </data>
  <data name="DecodeSwitchModeLabel" xml:space="preserve">
    <value>解码</value>
  </data>
  <data name="DecodeValidateTokenLabel" xml:space="preserve">
    <value>验证令牌</value>
  </data>
  <data name="DecodeValidateTokenNoLabel" xml:space="preserve">
    <value>否</value>
  </data>
  <data name="DecodeValidateTokenYesLabel" xml:space="preserve">
    <value>是</value>
  </data>
  <data name="EncodeExpirationTitle" xml:space="preserve">
    <value>访问令牌有到期日期</value>
  </data>
  <data name="EncodeExpirationMonthLabel" xml:space="preserve">
    <value>过期时间(月)</value>
  </data>
  <data name="EncodeExpirationYearLabel" xml:space="preserve">
    <value>过期时间(年)</value>
  </data>
  <data name="EncodeHashingTitle" xml:space="preserve">
    <value>令牌散列算法</value>
  </data>
  <data name="EncodeSettingsTitle" xml:space="preserve">
    <value>设置</value>
  </data>
  <data name="EncodeSwitchModeLabel" xml:space="preserve">
    <value>编码</value>
  </data>
  <data name="SettingsSwitchModeLabel" xml:space="preserve">
    <value>编码 / 解码</value>
  </data>
  <data name="SettingsTitle" xml:space="preserve">
    <value>配置</value>
  </data>
  <data name="EncodeDefaultTimeTitle" xml:space="preserve">
    <value>令牌具有默认时间</value>
  </data>
  <data name="EncodeExpirationDaysLabel" xml:space="preserve">
    <value>过期时间(日)</value>
  </data>
  <data name="EncodeExpirationHoursLabel" xml:space="preserve">
    <value>过期时间(时)</value>
  </data>
  <data name="EncodeExpirationMinutesLabel" xml:space="preserve">
    <value>过期时间(分)</value>
  </data>
  <data name="PrivateKeyLabel" xml:space="preserve">
    <value>私钥</value>
  </data>
  <data name="SignatureLabel" xml:space="preserve">
    <value>签名</value>
  </data>
  <data name="JwtNotValidated" xml:space="preserve">
    <value>令牌未验证（未选择参数）</value>
  </data>
  <data name="JwtIsValidMessage" xml:space="preserve">
    <value>令牌已验证</value>
  </data>
  <data name="InvalidPublicKeyError" xml:space="preserve">
    <value>公钥无效</value>
  </data>
  <data name="JwtInValidMessage" xml:space="preserve">
    <value>签名无效</value>
  </data>
  <data name="DecodeValidateActorLabel" xml:space="preserve">
    <value>验证执行者</value>
  </data>
  <data name="DecodeValidateAudienceLabel" xml:space="preserve">
    <value>验证接收者</value>
  </data>
  <data name="DecodeValidateIssuerSigningKey" xml:space="preserve">
    <value>验证签发者签名密钥</value>
  </data>
  <data name="DecodeValidateIssuerLabel" xml:space="preserve">
    <value>验证签发者</value>
  </data>
  <data name="DecodeValidateLifetimeLabel" xml:space="preserve">
    <value>验证生存时间</value>
  </data>
  <data name="ValidAudiencesLabel" xml:space="preserve">
    <value>有效的接收者</value>
  </data>
  <data name="ValidIssuersLabel" xml:space="preserve">
    <value>有效的签发者</value>
  </data>
  <data name="DecodeValidationSettingsDescription" xml:space="preserve">
    <value>选择要验证的令牌参数</value>
  </data>
  <data name="DecodeValidationSettingsTitle" xml:space="preserve">
    <value>令牌验证设置</value>
  </data>
  <data name="ValidAudiencesError" xml:space="preserve">
    <value>有效的接收者为空</value>
  </data>
  <data name="ValidIssuersError" xml:space="preserve">
    <value>有效的签发者为空</value>
  </data>
  <data name="PublicKeyIsPrivateKeyError" xml:space="preserve">
    <value>所提供的公钥是私钥</value>
  </data>
  <data name="EncodeAudienceLabel" xml:space="preserve">
    <value>令牌具有接收者</value>
  </data>
  <data name="EncodeIssuerLabel" xml:space="preserve">
    <value>令牌具有签发者</value>
  </data>
  <data name="EncodeSettingsDescription" xml:space="preserve">
    <value>选择令牌参数</value>
  </data>
  <data name="InvalidPrivateKeyError" xml:space="preserve">
    <value>私钥无效</value>
  </data>
  <data name="PublicKeyLabel" xml:space="preserve">
    <value>公钥</value>
  </data>
  <data name="SearchDisplayName" xml:space="preserve">
    <value>JWT 编码器 / 解码器</value>
  </data>
  <data name="InvalidSignatureError" xml:space="preserve">
    <value>无效签名</value>
  </data>
  <data name="NoDescription" xml:space="preserve">
    <value>没有描述</value>
  </data>
  <data name="iss" xml:space="preserve">
    <value>“iss”（issuer，签发者）声明指出签发 JWT 的一方。对此声明的处理一般因应用而异。“iss”值是一个包含 StringOrURI 值的字符串，区分大小写。此声明的使用不是必须的。</value>
  </data>
  <data name="sub" xml:space="preserve">
    <value>“sub”（subject，主题）声明指出 JWT 的主题。JWT 中的声明通常是与主题相关的说明。主题的值必须在签发者上下文局部或全局唯一。对此声明的处理一般因应用而异。“sub”值是一个包含 StringOrURI 值的字符串，区分大小写。此声明的使用不是必须的。</value>
  </data>
  <data name="aud" xml:space="preserve">
    <value>“aud”（audience，接收者）声明指出 JWT 预定的接收对象。希望处理 JWT 的各方必须在接收者声明中为自己指定一个值。如果处理该声明的一方在“aud”声明提交时没有在其中为自己指定一个值，JWT 就会被拒绝。通常情况下，“aud”值是一个数组，包含 StringOrURI 值的字符串，区分大小写。在 JWT 只有一个接收者的特殊情况下，“aud”值可能是包含 StringOrURI 值的单一字符串，区分大小写。对接收者值的解释一般因应用而异。此声明的使用不是必须的。</value>
  </data>
  <data name="exp" xml:space="preserve">
    <value>“exp”（expiration time，到期时间）声明指出不接受处理 JWT 的到期时间。对“exp”声明的处理要求当前日期/时间必须在“exp”声明所列出的到期日期/时间之前。考虑到时钟偏移，实现器可能会提供通常不多于几分钟的弹性时间。声明的值必须是一个包含 NumericDate 值的数值。此声明的使用不是必须的。</value>
  </data>
  <data name="nbf" xml:space="preserve">
    <value>“nbf”（not before，不早于）声明指出不接受处理 JWT 的最晚时间。对“nbf”声明的处理要求当前日期/时间必须在“nbf”声明所列出的最晚日期/时间之后或与之相等。考虑到时钟偏移，实现器可能会提供通常不多于几分钟的弹性时间。声明的值必须是一个包含 NumericDate 值的数值。此声明的使用不是必须的。</value>
  </data>
  <data name="iat" xml:space="preserve">
    <value>“iat”（签发时间）声明指出 JWT 签发的时间。此声明可用于确定 JWT 的存在时间。声明的值必须是一个包含 NumericDate 值的数值。此声明的使用不是必须的。</value>
  </data>
  <data name="jti" xml:space="preserve">
    <value>“jti”（JWT ID）声明为 JWT 提供独特标识符。标识符的值必须以特定方式分配，这种方式应确保相同值会以极小概率分配给另一数据对象；如果应用使用多个签发者，则还应避免不同签发者产生的值不会互相冲突。“jti”声明可用于防止 JWT 重放。“jti”值是一个字符串，区分大小写。此声明的使用不是必须的。</value>
  </data>
  <data name="name" xml:space="preserve">
    <value>最终用户的全名，displayable 形式，包括全部姓名结构，还可能包括标题和后缀，按最终用户的区域和偏好设置排序。</value>
  </data>
  <data name="given_name" xml:space="preserve">
    <value>最终用户的名。注意，在某些文化圈，一个人可以拥有多个名；多个名会以空格符分隔显示。</value>
  </data>
  <data name="family_name" xml:space="preserve">
    <value>最终用户的姓。注意，在某些文化圈，一个人可以拥有多个姓或不拥有姓；多个姓会以空格符分隔显示。</value>
  </data>
  <data name="middle_name" xml:space="preserve">
    <value>最终用户的中间名。注意，在某些文化圈，一个人可以拥有多个中间名或不拥有中间名；多个中间名会以空格符分隔显示。</value>
  </data>
  <data name="nickname" xml:space="preserve">
    <value>最终用户的昵称，其可能与 given_name 值相同或不同。例如，可能会在返回 given_name 值 Michael 的同时返回 nickname 值 Mike。</value>
  </data>
  <data name="preferred_username" xml:space="preserve">
    <value>最终用户希望在 RP 中被指代的简记名，如 janedoe 或 j.doe。该值可能是任意有效的 JSON 字符串，包含特殊字符如 @、/ 或空格。RP 不应认定该值唯一。</value>
  </data>
  <data name="profile" xml:space="preserve">
    <value>最终用户个人资料页面的 URL。此网页的内容应与最终用户有关。</value>
  </data>
  <data name="picture" xml:space="preserve">
    <value>最终用户个人资料图片的 URL。此 URL 必须指定一个图像文件（如一个 PNG、JPEG 或 GIF 图像文件）而不是包含图像的网页。注意，此 URL 应确保是一张在描述最终用户时适合展示的个人照片，而非由最终用户随意拍摄的一张照片。</value>
  </data>
  <data name="website" xml:space="preserve">
    <value>最终用户个人网页或博客的 URL。此网页应包含最终用户或其所属组织发布的信息。</value>
  </data>
  <data name="email" xml:space="preserve">
    <value>最终用户偏好的电子邮件地址。该值必须遵从 RFC 5322 addr-spec 语法。RP 不应认定该值唯一。</value>
  </data>
  <data name="email_verified" xml:space="preserve">
    <value>若最终用户的电子邮件地址已验证则为 true，否则为 false。此声明值为 true ，说明 OP 通过一定措施确认了在验证时，此电子邮件地址由最终用户控制。确认电子邮件地址已验证的方式因实际情形而异，同时取决于当事各方采用的信托框架或合同协议。</value>
  </data>
  <data name="gender" xml:space="preserve">
    <value>最终用户的性别。此规范定义的值为 female（女性）和 male（男性）。在已定义的值不适用的情形下，可以使用其他值。</value>
  </data>
  <data name="birthdate" xml:space="preserve">
    <value>最终用户的生日，依照 ISO 8601:2004 YYYY-MM-DD 格式。年份可以用 0000 表示省略。若只表示年份，允许采用 YYYY 格式。注意，取决于底层平台的日期相关函数，只提供年份可能会导致月份及日期有所出入，所以实现器需要考虑到此因素以正确处理日期。</value>
  </data>
  <data name="zoneinfo" xml:space="preserve">
    <value>zoneinfo 时区数据库字符串，代表最终用户的时区。如 Europe/Paris 或 America/Los_Angeles。</value>
  </data>
  <data name="locale" xml:space="preserve">
    <value>最终用户的区域，依照 BCP47 [RFC5646] 语言标签表示。通常组成为一个小写 ISO 639-1 Alpha-2 语言代码加上一个大写 ISO 3166-1 Alpha-2 国家代码，中间用短横线分隔。如 en-US 或 fr-CA。出于兼容性说明，某些实现使用下划线而不是短横线作为分隔符，如 en_US；依赖方可能也会接受这种区域语法。</value>
  </data>
  <data name="phone_number" xml:space="preserve">
    <value>最终用户偏好的电话号码。此声明推荐依照 E. 164 格式，如 +1 (425) 555-1212 或 +56 (2) 687 2400。如果电话号码中包含分机号，推荐该部分使用 RFC 3966 分机号语法，如 +1 (604) 555-1234;ext=5678。</value>
  </data>
  <data name="phone_number_verified" xml:space="preserve">
    <value>若最终用户的电话号码已验证则为 true，否则为 false。此声明值为 true ，说明 OP 通过一定措施确认了在验证时，此电话号码由最终用户控制。确认电话号码已验证的方式因实际情形而异，同时取决于当事各方采用的信托框架或合同协议。此声明值为 true 时，phone_number 声明必须依照 E. 164 格式，分机号必须依照 RFC 3966 格式。</value>
  </data>
  <data name="address" xml:space="preserve">
    <value>最终用户偏好的邮政地址。地址成员的值依照 JSON [RFC4627] 结构。</value>
  </data>
  <data name="updated_at" xml:space="preserve">
    <value>最终用户信息的最后更新时间。该值是一个 JSON 数值，代表从 1970-01-01T0:0:0Z 以来测量的 UTC 日期/时间对应的秒数。</value>
  </data>
  <data name="azp" xml:space="preserve">
    <value>Authorized party - the party to which the ID Token was issued. If present, it MUST contain the OAuth 2.0 Client ID of this party. This Claim is only needed when the ID Token has a single audience value and that audience is different than the authorized party. It MAY be included even when the authorized party is the same as the sole audience. The azp value is a case sensitive string containing a StringOrURI value.</value>
  </data>
  <data name="nonce" xml:space="preserve">
    <value>String value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. If present in the ID Token, Clients MUST verify that the nonce Claim Value is equal to the value of the nonce parameter sent in the Authentication Request. If present in the Authentication Request, Authorization Servers MUST include a nonce Claim in the ID Token with the Claim Value being the nonce value sent in the Authentication Request. Authorization Servers SHOULD perform no other processing on nonce values used. The nonce value is a case sensitive string.</value>
  </data>
  <data name="auth_time" xml:space="preserve">
    <value>Time when the End-User authentication occurred. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time. When a max_age request is made or when auth_time is requested as an Essential Claim, then this Claim is REQUIRED; otherwise, its inclusion is OPTIONAL. (The auth_time Claim semantically corresponds to the OpenID 2.0 PAPE auth_time response parameter.)</value>
  </data>
  <data name="at_hash" xml:space="preserve">
    <value>Access Token hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the access_token value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, hash the access_token value with SHA-256, then take the left-most 128 bits and base64url encode them. The at_hash value is a case sensitive string.</value>
  </data>
  <data name="c_hash" xml:space="preserve">
    <value>Code hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the code value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is HS512, hash the code value with SHA-512, then take the left-most 256 bits and base64url encode them. The c_hash value is a case sensitive string. If the ID Token is issued from the Authorization Endpoint with a code, which is the case for the response_type values code id_token and code id_token token, this is REQUIRED; otherwise, its inclusion is OPTIONAL.</value>
  </data>
  <data name="acr" xml:space="preserve">
    <value>Authentication Context Class Reference. String specifying an Authentication Context Class Reference value that identifies the Authentication Context Class that the authentication performed satisfied. The value "0" indicates the End-User authentication did not meet the requirements of ISO/IEC 29115 level 1. Authentication using a long-lived browser cookie, for instance, is one example where the use of "level 0" is appropriate. Authentications with level 0 SHOULD NOT be used to authorize access to any resource of any monetary value. (This corresponds to the OpenID 2.0 PAPE nist_auth_level 0.) An absolute URI or an RFC 6711 registered name SHOULD be used as the acr value; registered names MUST NOT be used with a different meaning than that which is registered. Parties using this claim will need to agree upon the meanings of the values used, which may be context-specific. The acr value is a case sensitive string.</value>
  </data>
  <data name="amr" xml:space="preserve">
    <value>Authentication Methods References. JSON array of strings that are identifiers for authentication methods used in the authentication. For instance, values might indicate that both password and OTP authentication methods were used. Parties using this claim will need to agree upon the meanings of the values used, which may be context-specific. The amr value is an array of case sensitive strings.</value>
  </data>
  <data name="sub_jwk" xml:space="preserve">
    <value>Public key used to check the signature of an ID Token issued by a Self-Issued OpenID Provider. The key is a bare key in JWK format (not an X.509 certificate value). The sub_jwk value is a JSON object. Use of the sub_jwk Claim is NOT RECOMMENDED when the OP is not Self-Issued.</value>
  </data>
</root>
