<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>JWT Kodierungs- und Dekodierungswerkzeug</value>
  </data>
  <data name="MenuDisplayName" xml:space="preserve">
    <value>JWT</value>
  </data>
  <data name="JwtHeaderLabel" xml:space="preserve">
    <value>Header</value>
  </data>
  <data name="JwtTokenLabel" xml:space="preserve">
    <value>Token</value>
  </data>
  <data name="JwtPayloadLabel" xml:space="preserve">
    <value>Payload</value>
  </data>
  <data name="Type" xml:space="preserve">
    <value>Typ</value>
  </data>
  <data name="Value" xml:space="preserve">
    <value>Wert</value>
  </data>
  <data name="DescriptionHeader" xml:space="preserve">
    <value>Beschreibung</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Dekodiere einen JWT header, payload und signature</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value/>
  </data>
  <data name="Algorithm" xml:space="preserve">
    <value>Algorithmus</value>
  </data>
  <data name="DecodeSwitchModeLabel" xml:space="preserve">
    <value>Dekodieren</value>
  </data>
  <data name="DecodeValidateTokenLabel" xml:space="preserve">
    <value>Validierungs-Token</value>
  </data>
  <data name="DecodeValidateTokenNoLabel" xml:space="preserve">
    <value>Nein</value>
  </data>
  <data name="DecodeValidateTokenYesLabel" xml:space="preserve">
    <value>Ja</value>
  </data>
  <data name="EncodeExpirationTitle" xml:space="preserve">
    <value>Token hat Verfallszeiten</value>
  </data>
  <data name="EncodeExpirationMonthLabel" xml:space="preserve">
    <value>Verfällt in Monat(en)</value>
  </data>
  <data name="EncodeExpirationYearLabel" xml:space="preserve">
    <value>Verfällt in Jahr(en)</value>
  </data>
  <data name="EncodeHashingTitle" xml:space="preserve">
    <value>Token-Hashing-Algorithmus</value>
  </data>
  <data name="EncodeSettingsTitle" xml:space="preserve">
    <value>Einstellungen</value>
  </data>
  <data name="EncodeSwitchModeLabel" xml:space="preserve">
    <value>Kodieren</value>
  </data>
  <data name="SettingsSwitchModeLabel" xml:space="preserve">
    <value>Kodieren / Dekodieren</value>
  </data>
  <data name="SettingsTitle" xml:space="preserve">
    <value>Konfiguration</value>
  </data>
  <data name="EncodeDefaultTimeTitle" xml:space="preserve">
    <value>Token hat Standardzeit</value>
  </data>
  <data name="EncodeExpirationDaysLabel" xml:space="preserve">
    <value>Verfällt in Tag(en)</value>
  </data>
  <data name="EncodeExpirationHoursLabel" xml:space="preserve">
    <value>Verfällt in Stunde(n)</value>
  </data>
  <data name="EncodeExpirationMinutesLabel" xml:space="preserve">
    <value>Verfällt in Minute(n)</value>
  </data>
  <data name="PrivateKeyLabel" xml:space="preserve">
    <value>Privater Schlüssel</value>
  </data>
  <data name="SignatureLabel" xml:space="preserve">
    <value>Signatur</value>
  </data>
  <data name="JwtNotValidated" xml:space="preserve">
    <value>Token nicht validiert (keine Parameter ausgewählt)</value>
  </data>
  <data name="JwtIsValidMessage" xml:space="preserve">
    <value>Token validiert</value>
  </data>
  <data name="InvalidPublicKeyError" xml:space="preserve">
    <value>Ungültiger öffentlicher Schlüssel</value>
  </data>
  <data name="JwtInValidMessage" xml:space="preserve">
    <value>Ungültige Signatur</value>
  </data>
  <data name="DecodeValidateActorLabel" xml:space="preserve">
    <value>Akteur überprüfen</value>
  </data>
  <data name="DecodeValidateAudienceLabel" xml:space="preserve">
    <value>Zielgruppe überprüfen</value>
  </data>
  <data name="DecodeValidateIssuerSigningKey" xml:space="preserve">
    <value>Signaturschlüssel des Ausstellers überprüfen</value>
  </data>
  <data name="DecodeValidateIssuerLabel" xml:space="preserve">
    <value>Ersteller überprüfen</value>
  </data>
  <data name="DecodeValidateLifetimeLabel" xml:space="preserve">
    <value>Gültigkeitsdauer überprüfen</value>
  </data>
  <data name="ValidAudiencesLabel" xml:space="preserve">
    <value>Zielgruppen überprüfen</value>
  </data>
  <data name="ValidIssuersLabel" xml:space="preserve">
    <value>Ersteller überprüfen</value>
  </data>
  <data name="DecodeValidationSettingsDescription" xml:space="preserve">
    <value>Wählen Sie die zu überprüfenden Token-Parameter</value>
  </data>
  <data name="DecodeValidationSettingsTitle" xml:space="preserve">
    <value>Token-Überprüfungseinstellungen</value>
  </data>
  <data name="ValidAudiencesError" xml:space="preserve">
    <value>Keine gültigen Zielgruppen</value>
  </data>
  <data name="ValidIssuersError" xml:space="preserve">
    <value>Keine gültigen Ersteller</value>
  </data>
  <data name="PublicKeyIsPrivateKeyError" xml:space="preserve">
    <value>Der zur Verfügung gestellte öffentliche Schlüssel ist ein privater Schlüssel</value>
  </data>
  <data name="EncodeAudienceLabel" xml:space="preserve">
    <value>Token hat Zielgruppe</value>
  </data>
  <data name="EncodeIssuerLabel" xml:space="preserve">
    <value>Token hat Ersteller</value>
  </data>
  <data name="EncodeSettingsDescription" xml:space="preserve">
    <value>Token-Parameter auswählen</value>
  </data>
  <data name="InvalidPrivateKeyError" xml:space="preserve">
    <value>Ungültiger privater Schlüssel</value>
  </data>
  <data name="PublicKeyLabel" xml:space="preserve">
    <value>Öffentlicher Schlüssel</value>
  </data>
  <data name="SearchDisplayName" xml:space="preserve">
    <value>JWT Kodierer / Dekodierer</value>
  </data>
  <data name="InvalidSignatureError" xml:space="preserve">
    <value>Ungültige Signatur</value>
  </data>
  <data name="NoDescription" xml:space="preserve">
    <value>Keine Beschreibung</value>
  </data>
  <data name="iss" xml:space="preserve">
    <value>Die "iss" (Emitter) Anforderung identifiziert den Grundsatz, der die JWT ausgestellt hat. Die Bearbeitung dieser Anforderung ist in der Regel anwendungsspezifisch. Der Wert "iss" berücksichtigt Groß-/Kleinschreibung und bestejt aus einem StringOrURI-Wert. Die Verwendung dieser Anforderung ist OPTIONAL.</value>
  </data>
  <data name="sub" xml:space="preserve">
    <value>Der "sub" (Subjekt) Claim identifiziert den Grundsatz, der Gegenstand des JWT ist Die Claims in einem JWT sind normalerweise Aussagen über das Subjekt. Der Subjekt-Wert MUSS entweder lokal einzigartig (im Kontext des Issuers) oder global einzigartig sein. Die Bearbeitung dieses Clamis ist in der Regel anwendungsspezifisch. Der "sub" Wert beachtet Groß-/Kleinschreibung und enthält einen StringOrURI Wert. Die Verwendung dieses Claims ist OPTIONAL.</value>
  </data>
  <data name="aud" xml:space="preserve">
    <value>Der "aud" (Publikum) Claim identifiziert die Empfänger, für die der JWT bestimmt ist. Jeder Klient, der den JWT verarbeiten soll, MUSS sich mit einem Wert im Publikums-Claim identifizieren. Hat sich der Klient, der den Claim verarbeitet, nicht mit einem Wert in dem "aud" Claim identifiziert, wenn der Claim präsent ist, MUSS der JWT abgelehnt werden. Im Allgemeinen ist der "aud" Wert eine Liste aus Zeichenfolgen (die Groß-/Kleinschreibung beachten), in der jeder Wert einen StringOrURI Wert enthält. Im speziellen Fall, dass der JWT ein Publikum hat, DARF der "aud" Wert eine einzelne (Groß-/Kleinschreibung beachtende) Zeichenfolge bestehend aus einer StringOrURI Wert enthalten. Die Interpretation von Publikums-Werten ist im Allgemeinen anwendungsspezifisch. Das Nutzen dieses Claims ist OPTIONAL.</value>
  </data>
  <data name="exp" xml:space="preserve">
    <value>Der "exp" (Ablaufzeitpunkt) Claim identifiziert den Ablaufzeitpunkt bei oder nach welchem der JWT NICHT MEHR zum Verarbeiten akzeptiert werden DARF. Das Verarbeiten des "exp" Claims verlangt, dass das aktuelle Datum / die aktuelle Zeit vor dem im "exp" Claim gelisteten Ablaufdatum/Ablaufzeitpunkt liegen MUSS. Implementierer KÖNNEN einen kleinen Spielraum vorsehen, der in der Regel nicht mehr als ein paar Minuten beträgt, um Zeitverzug auszugleichen. Sein Wert MUSS eine Nummer sein, die einen NumericDate Wert enthält. Das Verwenden dieses Claims ist OPTIONAL.</value>
  </data>
  <data name="nbf" xml:space="preserve">
    <value>Der "nbf" (nicht bevor) Claim identifiziert den Zeitpunkt, bevor dem der JWT NICHT zum Verarbeiten akzeptiert werden DARF. Das Verarbeiten des "nbf" Claims verlangt, dass das aktuelle Datum / die aktuelle Zeit nach oder gleichzeitig zu dem "Nicht bevor"-Datum/-Zeitpunkt, der im "nbf" Claim gelistet ist, sein MUSS. Implementierer KÖNNEN einen kleinen Spielraum vorsehen, der in der Regel nicht mehr als ein paar Minuten beträgt, um Zeitverzug auszugleichen. Sein Wert MUSS eine Nummer sein, die einen NumericDate Wert enthält. Das Verwenden dieses Claims ist OPTIONAL.</value>
  </data>
  <data name="iat" xml:space="preserve">
    <value>Die Angabe "iat" (issued at) kennzeichnet den Zeitpunkt, zu dem der JWT ausgestellt wurde. Diese Angabe kann verwendet werden, um das Alter des JWT zu bestimmen. Sein Wert MUSS eine Zahl sein, die einen NumericDate-Wert enthält. Die Verwendung dieser Angabe ist OPTIONAL.</value>
  </data>
  <data name="jti" xml:space="preserve">
    <value>Der Anspruch auf "jti" (JWT ID) stellt eine eindeutige Kennung für die JWT dar. Der Identifikatorwert MÜSSEN in einer Art und Weise zugewiesen werden, die sicherstellt, dass es eine vernachlässigbare Wahrscheinlichkeit gibt, dass der gleiche Wert einem anderen Datenobjekt zugewiesen wird; wenn die Anwendung mehrere Emittenten verwendet, MÜSSEN Kollisionen zwischen Werten, die auch von verschiedenen Emittenten erzeugt werden, verhindert werden. Der "jti"-Anspruch kann dazu benutzt werden, um zu verhindern, dass der JWT wiedergespielt wird. Der "jti"-Wert ist ein Groß-/Kleinschreibungszeichen. Die Verwendung dieses Anspruchs ist OPTIONAL.</value>
  </data>
  <data name="name" xml:space="preserve">
    <value>Vollständiger Name des Benutzers einschließlich etwaiger Titel, geordnet nach dem Gebietsschema und den Einstellungen des Benutzers.</value>
  </data>
  <data name="given_name" xml:space="preserve">
    <value>Vorname(n) des Benutzers. Beachten Sie, dass in einigen Kulturen Menschen mehrere Vornamen haben können; alle Vornamen können, durch Leerzeichen getrennt, angegeben werden.</value>
  </data>
  <data name="family_name" xml:space="preserve">
    <value>Familienname(n) oder Geburtsname des Benutzers. Beachten Sie, dass in einigen Kulturen Menschen mehrere oder keinen Familiennamen oder Geburtsname haben können; alle können, durch Leerzeichen getrennt, angegeben werden.</value>
  </data>
  <data name="middle_name" xml:space="preserve">
    <value>Zwischenname(n) des Endbenutzers. Beachten Sie, dass Menschen in einigen Kulturen mehrere Zwischennamen haben können; All diese können mit Leerzeichen getrennt angegeben werden. Beachten Sie außerdem, dass Zwischennamen in einigen Kulturen wiederum nicht verwendet werden.</value>
  </data>
  <data name="nickname" xml:space="preserve">
    <value>Gelegentlicher Name des End-Users, der möglicherweise der gleiche wie der given_name ist. Zum Beispiel kann ein Nickname-Wert von Mike neben einem given_name Wert von Michael zurückgegeben werden.</value>
  </data>
  <data name="preferred_username" xml:space="preserve">
    <value>Abgekürzter Name, mit dem der Endbenutzer auf dem RP verwiesen werden möchte, wie zum Beispiel janedoe oder j.doe. Dieser Wert darf jeder gültige JSON-String sein, einschließlich Sonderzeichen wie @, / oder Leerzeichen. Der RP ist NICHT darauf angewiesen, dass dieser Wert einzigartig ist.</value>
  </data>
  <data name="profile" xml:space="preserve">
    <value>URL der Profilseite des Endbenutzers. Der Inhalt dieser Seite SOLLTE sich auf den Endbenutzer beziehen.</value>
  </data>
  <data name="picture" xml:space="preserve">
    <value>URL des Profilbildes des Endbenutzers. Diese URL MUSS sich auf eine Bilddatei beziehen (zum Beispiel eine PNG, JPEG oder GIF Datei), anstatt auf eine Website, welche ein Bild enthält. Beachten Sie, dass diese URL sich auf ein spezifisches Bild des Endbenutzers beziehen SOLLTE, anstatt eines willkürlichen Bildes, welches vom Endbenutzer aufgenommen wurde.</value>
  </data>
  <data name="website" xml:space="preserve">
    <value>URL der Website oder des Blogs eines Endbenutzers. Diese Webseite SOLLTE Informationen die vom Endbenutzer oder einer Organisation veröffentlicht wurden enthalten, mit welchen der Endbenutzer verbunden ist.</value>
  </data>
  <data name="email" xml:space="preserve">
    <value>Die bevorzugte E-Mail-Adresse des Endbenutzers. Ihr Wert MUSS der Syntax von RFC 5322 addr-spec entsprechen. Der RP MUSS sich NICHT darauf verlassen, dass dieser Wert eindeutig ist.</value>
  </data>
  <data name="email_verified" xml:space="preserve">
    <value>Richtig, wenn die E-Mail-Adresse des Endbenutzers überprüft wurde; ansonsten falsch. Wenn dieser Anspruchswert wahr ist bedeutet dies, dass die OP positive Schritte unternommen hat, um sicherzustellen, dass diese E-Mail-Adresse zum Zeitpunkt der Überprüfung durch den Endbenutzer kontrolliert wurde. Das Mittel, mit dem eine E-Mail-Adresse überprüft wird, ist kontextspezifisch, und abhängig von dem Vertrauensrahmen oder den vertraglichen Vereinbarungen, innerhalb derer die Parteien agieren.</value>
  </data>
  <data name="gender" xml:space="preserve">
    <value>Das Geschlecht des Endnutzers. Die von dieser Spezifikation definierten Werten sind weiblich und männlich. Andere Werte dürfen verwendet werden, wenn keine der definierten Werte zutreffen.</value>
  </data>
  <data name="birthdate" xml:space="preserve">
    <value>Geburtsdatum des End-Users im Format YYYY-MM-DD nach ISO 8601:2004. Das Jahr darf 0000 sein, was anzeigt, dass es bei der Eingabe weggelassen wurde. Um nur das Jahr einzugeben ist das Format YYYY erlaubt. Beachten Sie, dass je nach der datumsbezogenen Funktion der zugrunde liegenden Plattform die Angabe nur des Jahres zu unterschiedlichen Monaten und Tagen führen kann.</value>
  </data>
  <data name="zoneinfo" xml:space="preserve">
    <value>Zeichenkette aus der zoneinfo Zeitzonen-Datenbank, die die Zeitzone des End-Users repräsentiert, zum Beispiel in Europa/Paris oder Amerika/Los_Angeles.</value>
  </data>
  <data name="locale" xml:space="preserve">
    <value>End-User's locale, represented as a BCP47 [RFC5646] language tag. This is typically an ISO 639-1 Alpha-2 language code in lowercase and an ISO 3166-1 Alpha-2 country code in uppercase, separated by a dash. For example, en-US or fr-CA. As a compatibility note, some implementations have used an underscore as the separator rather than a dash, for example, en_US; Relying Parties MAY choose to accept this locale syntax as well.</value>
  </data>
  <data name="phone_number" xml:space="preserve">
    <value>End-User's preferred telephone number. E.164 is RECOMMENDED as the format of this Claim, for example, +1 (425) 555-1212 or +56 (2) 687 2400. If the phone number contains an extension, it is RECOMMENDED that the extension be represented using the RFC 3966 extension syntax, for example, +1 (604) 555-1234;ext=5678.</value>
  </data>
  <data name="phone_number_verified" xml:space="preserve">
    <value>True if the End-User's phone number has been verified; otherwise false. When this Claim Value is true, this means that the OP took affirmative steps to ensure that this phone number was controlled by the End-User at the time the verification was performed. The means by which a phone number is verified is context-specific, and dependent upon the trust framework or contractual agreements within which the parties are operating. When true, the phone_number Claim MUST be in E.164 format and any extensions MUST be represented in RFC 3966 format.</value>
  </data>
  <data name="address" xml:space="preserve">
    <value>End-User's preferred postal address. The value of the address member is a JSON [RFC4627] structure.</value>
  </data>
  <data name="updated_at" xml:space="preserve">
    <value>Der Zeitpunkt, an dem die Informationen des End-Benutzers das letzte Mal aktualisiert wurden. Der Wert ist eine JSON-Nummer, die die Anzahl der Sekunden seit 01.01.1970 00:00 Uhr bis zum entsprechenden Zeitpunkt angibt.</value>
  </data>
  <data name="azp" xml:space="preserve">
    <value>Authorized party - the party to which the ID Token was issued. If present, it MUST contain the OAuth 2.0 Client ID of this party. This Claim is only needed when the ID Token has a single audience value and that audience is different than the authorized party. It MAY be included even when the authorized party is the same as the sole audience. The azp value is a case sensitive string containing a StringOrURI value.</value>
  </data>
  <data name="nonce" xml:space="preserve">
    <value>String value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. If present in the ID Token, Clients MUST verify that the nonce Claim Value is equal to the value of the nonce parameter sent in the Authentication Request. If present in the Authentication Request, Authorization Servers MUST include a nonce Claim in the ID Token with the Claim Value being the nonce value sent in the Authentication Request. Authorization Servers SHOULD perform no other processing on nonce values used. The nonce value is a case sensitive string.</value>
  </data>
  <data name="auth_time" xml:space="preserve">
    <value>Time when the End-User authentication occurred. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time. When a max_age request is made or when auth_time is requested as an Essential Claim, then this Claim is REQUIRED; otherwise, its inclusion is OPTIONAL. (The auth_time Claim semantically corresponds to the OpenID 2.0 PAPE auth_time response parameter.)</value>
  </data>
  <data name="at_hash" xml:space="preserve">
    <value>Access Token hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the access_token value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, hash the access_token value with SHA-256, then take the left-most 128 bits and base64url encode them. The at_hash value is a case sensitive string.</value>
  </data>
  <data name="c_hash" xml:space="preserve">
    <value>Code hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the code value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is HS512, hash the code value with SHA-512, then take the left-most 256 bits and base64url encode them. The c_hash value is a case sensitive string. If the ID Token is issued from the Authorization Endpoint with a code, which is the case for the response_type values code id_token and code id_token token, this is REQUIRED; otherwise, its inclusion is OPTIONAL.</value>
  </data>
  <data name="acr" xml:space="preserve">
    <value>Authentication Context Class Reference. String specifying an Authentication Context Class Reference value that identifies the Authentication Context Class that the authentication performed satisfied. The value "0" indicates the End-User authentication did not meet the requirements of ISO/IEC 29115 level 1. Authentication using a long-lived browser cookie, for instance, is one example where the use of "level 0" is appropriate. Authentications with level 0 SHOULD NOT be used to authorize access to any resource of any monetary value. (This corresponds to the OpenID 2.0 PAPE nist_auth_level 0.) An absolute URI or an RFC 6711 registered name SHOULD be used as the acr value; registered names MUST NOT be used with a different meaning than that which is registered. Parties using this claim will need to agree upon the meanings of the values used, which may be context-specific. The acr value is a case sensitive string.</value>
  </data>
  <data name="amr" xml:space="preserve">
    <value>Authentication Methods References. JSON array of strings that are identifiers for authentication methods used in the authentication. For instance, values might indicate that both password and OTP authentication methods were used. Parties using this claim will need to agree upon the meanings of the values used, which may be context-specific. The amr value is an array of case sensitive strings.</value>
  </data>
  <data name="sub_jwk" xml:space="preserve">
    <value>Public key used to check the signature of an ID Token issued by a Self-Issued OpenID Provider. The key is a bare key in JWK format (not an X.509 certificate value). The sub_jwk value is a JSON object. Use of the sub_jwk Claim is NOT RECOMMENDED when the OP is not Self-Issued.</value>
  </data>
</root>
