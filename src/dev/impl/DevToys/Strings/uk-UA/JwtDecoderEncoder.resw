<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Інструмент кодування та декодування JWT</value>
  </data>
  <data name="MenuDisplayName" xml:space="preserve">
    <value>JWT</value>
  </data>
  <data name="JwtHeaderLabel" xml:space="preserve">
    <value>Заголовок</value>
  </data>
  <data name="JwtTokenLabel" xml:space="preserve">
    <value>Токен</value>
  </data>
  <data name="JwtPayloadLabel" xml:space="preserve">
    <value>Корисний вміст</value>
  </data>
  <data name="Type" xml:space="preserve">
    <value>Тип</value>
  </data>
  <data name="Value" xml:space="preserve">
    <value>Значення</value>
  </data>
  <data name="DescriptionHeader" xml:space="preserve">
    <value>Опис</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Розшифровування заголовка JWT, вмісту та сигнатури</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value/>
  </data>
  <data name="Algorithm" xml:space="preserve">
    <value>Алгоритм</value>
  </data>
  <data name="DecodeSwitchModeLabel" xml:space="preserve">
    <value>Декодувати</value>
  </data>
  <data name="DecodeValidateTokenLabel" xml:space="preserve">
    <value>Перевірити токен</value>
  </data>
  <data name="DecodeValidateTokenNoLabel" xml:space="preserve">
    <value>Ні</value>
  </data>
  <data name="DecodeValidateTokenYesLabel" xml:space="preserve">
    <value>Так</value>
  </data>
  <data name="EncodeExpirationTitle" xml:space="preserve">
    <value>Токен має термін дії</value>
  </data>
  <data name="EncodeExpirationMonthLabel" xml:space="preserve">
    <value>Закінчується через місяців</value>
  </data>
  <data name="EncodeExpirationYearLabel" xml:space="preserve">
    <value>Закінчується через рік(и)</value>
  </data>
  <data name="EncodeHashingTitle" xml:space="preserve">
    <value>Алгоритм хешування токена</value>
  </data>
  <data name="EncodeSettingsTitle" xml:space="preserve">
    <value>Налаштування</value>
  </data>
  <data name="EncodeSwitchModeLabel" xml:space="preserve">
    <value>Закодувати</value>
  </data>
  <data name="SettingsSwitchModeLabel" xml:space="preserve">
    <value>Кодування / Декодування</value>
  </data>
  <data name="SettingsTitle" xml:space="preserve">
    <value>Налаштування</value>
  </data>
  <data name="EncodeDefaultTimeTitle" xml:space="preserve">
    <value>Токен має типовий час</value>
  </data>
  <data name="EncodeExpirationDaysLabel" xml:space="preserve">
    <value>Закінчується через день(и)</value>
  </data>
  <data name="EncodeExpirationHoursLabel" xml:space="preserve">
    <value>Закінчується через годин(у)</value>
  </data>
  <data name="EncodeExpirationMinutesLabel" xml:space="preserve">
    <value>Закінчується через хвилину(и)</value>
  </data>
  <data name="PrivateKeyLabel" xml:space="preserve">
    <value>Приватний ключ</value>
  </data>
  <data name="SignatureLabel" xml:space="preserve">
    <value>Підпис</value>
  </data>
  <data name="JwtNotValidated" xml:space="preserve">
    <value>Токен не підтверджено (параметри не обрано)</value>
  </data>
  <data name="JwtIsValidMessage" xml:space="preserve">
    <value>Токен перевірено</value>
  </data>
  <data name="InvalidPublicKeyError" xml:space="preserve">
    <value>Недійсний відкритий ключ</value>
  </data>
  <data name="JwtInValidMessage" xml:space="preserve">
    <value>Підпис недійсний</value>
  </data>
  <data name="DecodeValidateActorLabel" xml:space="preserve">
    <value>Перевірте актора</value>
  </data>
  <data name="DecodeValidateAudienceLabel" xml:space="preserve">
    <value>Підтвердити аудиторію</value>
  </data>
  <data name="DecodeValidateIssuerSigningKey" xml:space="preserve">
    <value>Перевірити ключ підпису емітента</value>
  </data>
  <data name="DecodeValidateIssuerLabel" xml:space="preserve">
    <value>Перевірити емітента</value>
  </data>
  <data name="DecodeValidateLifetimeLabel" xml:space="preserve">
    <value>Перевірити термін дії</value>
  </data>
  <data name="ValidAudiencesLabel" xml:space="preserve">
    <value>Підтвердити аудиторію</value>
  </data>
  <data name="ValidIssuersLabel" xml:space="preserve">
    <value>Перевірити емітента</value>
  </data>
  <data name="DecodeValidationSettingsDescription" xml:space="preserve">
    <value>Виберіть параметри токена для перевірки</value>
  </data>
  <data name="DecodeValidationSettingsTitle" xml:space="preserve">
    <value>Налаштування перевірки токена</value>
  </data>
  <data name="ValidAudiencesError" xml:space="preserve">
    <value>Дійсні емітенти порожні</value>
  </data>
  <data name="ValidIssuersError" xml:space="preserve">
    <value>Дійсні емітенти порожні</value>
  </data>
  <data name="PublicKeyIsPrivateKeyError" xml:space="preserve">
    <value>Наданий відкритий ключ є приватним ключем</value>
  </data>
  <data name="EncodeAudienceLabel" xml:space="preserve">
    <value>Token має аудиторію</value>
  </data>
  <data name="EncodeIssuerLabel" xml:space="preserve">
    <value>Маркер має емітента</value>
  </data>
  <data name="EncodeSettingsDescription" xml:space="preserve">
    <value>Вибрати параметри токена</value>
  </data>
  <data name="InvalidPrivateKeyError" xml:space="preserve">
    <value>Недійсний приватний ключ</value>
  </data>
  <data name="PublicKeyLabel" xml:space="preserve">
    <value>Публічний ключ</value>
  </data>
  <data name="SearchDisplayName" xml:space="preserve">
    <value>Кодування та декодування JWT</value>
  </data>
  <data name="InvalidSignatureError" xml:space="preserve">
    <value>Підпис недійсний</value>
  </data>
  <data name="NoDescription" xml:space="preserve">
    <value>Немає опису</value>
  </data>
  <data name="iss" xml:space="preserve">
    <value>Вимога "iss" (емітент) ідентифікує принципала, який випустив JWT. Обробка цього реквізиту, як правило, залежить від конкретної програми. Значення "iss" є чутливим до регістру рядком, що містить значення StringOrURI. Використання цього реквізиту є НЕОБОВ'ЯЗКОВИМ.</value>
  </data>
  <data name="sub" xml:space="preserve">
    <value>"Sub" (підрядне) посилання ідентифікує основне положення, яке є об'єктом JWT. Твердження в JWT зазвичай є твердженнями про об'єкт. Значення об'єкта ПОВИННО бути або локально унікальним у контексті емітента, або глобально унікальним. Обробка цієї вимоги, як правило, залежить від конкретної програми. Значення "sub" - це чутливий до регістру рядок, що містить значення StringOrURI. Використання цієї вимоги є НЕОБОВ'ЯЗКОВИМ.</value>
  </data>
  <data name="aud" xml:space="preserve">
    <value>Заява "aud" (аудиторія) ідентифікує отримувачів, для яких призначена JWT. Кожен бенефіціар, який має намір обробити JWT, ПОВИНЕН ідентифікувати себе зі значенням у реквізиті "аудиторія". Якщо довірена особа, яка обробляє заявку, не ідентифікує себе зі значенням у реквізиті " aud", коли цей реквізит присутній, то JWT МУСИТЬ бути відхилена. У загальному випадку значення "aud" є масивом чутливих до регістру рядків, кожен з яких містить значення StringOrURI. В окремому випадку, коли JWT має одну аудиторію, значення "aud" МОЖЕ бути одним рядком, чутливим до регістру, що містить значення StringOrURI. Інтерпретація значень аудиторії, як правило, залежить від конкретної програми. Використання цього пункту є НЕОБОВ'ЯЗКОВИМ.</value>
  </data>
  <data name="exp" xml:space="preserve">
    <value>Заява "exp" (термін придатності) визначає термін придатності, до або після якого JWT НЕ МОЖЕ бути прийнята до опрацювання. Обробка вимоги "exp" вимагає, щоб поточна дата/час ПОВИННА бути раніше дати/часу закінчення терміну дії, зазначеного у вимозі "exp". Виконавці МОЖУТЬ передбачити деякий невеликий запас, зазвичай не більше кількох хвилин, щоб врахувати похибку годинника. Його значенням ПОВИННО бути числом, що містить значення NumericDate. Використання цього пункту є НЕОБОВ'ЯЗКОВИМ.</value>
  </data>
  <data name="nbf" xml:space="preserve">
    <value>Вимога "nbf" (не раніше) визначає час, до якого JWT НЕ МОЖЕ бути прийнятий до обробки. Обробка вимоги "nbf" вимагає, щоб поточна дата/час була після або дорівнювала даті/часу "не раніше", зазначеному у вимозі "nbf". Виконавці МОЖУТЬ передбачити невелику похибку, зазвичай не більше кількох хвилин, щоб врахувати відхилення годинника. Його значенням ПОВИННО бути число, що містить значення NumericDate. Використання цього пункту є НЕОБОВ'ЯЗКОВИМ.</value>
  </data>
  <data name="iat" xml:space="preserve">
    <value>Реквізит "iat" (виданий при) визначає час, коли було видано JWT. Цей реквізит може бути використаний для визначення вікового діапазону JWT. Його значенням ПОВИННО бути число, що містить значення NumericDate. Використання цього поля є НЕОБОВ'ЯЗКОВИМ.</value>
  </data>
  <data name="jti" xml:space="preserve">
    <value>Твердження "jti" (ідентифікатор JWT) надає унікальний ідентифікатор для JWT. Значення ідентифікатора ПОВИННО бути призначене таким чином, щоб гарантувати, що існує незначна ймовірність того, що те саме значення буде випадково призначене іншому об'єкту даних; якщо додаток використовує декілька емітентів, ПОВИННО бути передбачено запобігання колізіям між значеннями, створеними різними емітентами. Щоб запобігти відтворенню JWT, можна використати твердження "jti". Значення "jti" є чутливим до регістру рядком. Використання цього поля є НЕОБОВ'ЯЗКОВИМ.</value>
  </data>
  <data name="name" xml:space="preserve">
    <value>Повне ім'я Кінцевого Користувача у відображуваній формі включно з усіма частинами імен, як-от титули та суфікси, впорядковане відповідно до локалізації та налаштувань Кінцевого Користувача.</value>
  </data>
  <data name="given_name" xml:space="preserve">
    <value>Власне ім'я або перше(і) ім'я (імена) кінцевого користувача. Зверніть увагу, що в деяких культурах люди можуть мати кілька власних імен; все це може бути представлено, з іменами, що розділено пробілами.</value>
  </data>
  <data name="family_name" xml:space="preserve">
    <value>Прізвище (прізвища) кінцевого користувача. Зверніть увагу, що в деяких культурах люди можуть мати кілька власних імен; все це може бути представлено, з іменами, що розділено пробілами.</value>
  </data>
  <data name="middle_name" xml:space="preserve">
    <value>Середнє ім'я (імена) кінцевого користувача. Зверніть увагу, що в деяких культурах люди можуть мати кілька середніх імен; все це може бути представлено, з іменами, що розділено пробілами. Також зверніть увагу, що в деяких культурах середні імена не використовуються.</value>
  </data>
  <data name="nickname" xml:space="preserve">
    <value>Розмовне ім'я Кінцевого Користувача, яке може бути або не бути таким самим, як given_name. Наприклад, разом з given_name Олександр може використовуватись nickname Лесь.</value>
  </data>
  <data name="preferred_username" xml:space="preserve">
    <value>Скорочене ім'я Кінцевого Користувача, яке той бажає використовувати на RP, як-от janedoe або j.doe. Це значення МОЖЕ бути будь-яким дійсним рядком JSON і включати спеціальні символи, такі як @, /, або пробіли. RP НЕ ПОВИННІ покладатися на унікальність цього значення.</value>
  </data>
  <data name="profile" xml:space="preserve">
    <value>URL сторінки профілю Кінцевого Користувача. Вміст цієї вебсторінки ПОВИНЕН стосуватися Кінцевого Користувача.</value>
  </data>
  <data name="picture" xml:space="preserve">
    <value>URL зображення профілю Кінцевого Користувача. Ця URL-адреса ПОВИННА посилатися на файл зображення (наприклад, на PNG, JPEG, або GIF файл), а не на веб-сторінку, що містить зображення. Зверніть увагу, що цей URL ПОВИНЕН посилатися саме на фото профілю Кінцевого Користувача, що підходить для його опису, а не на довільне фото, зроблене Кінцевим Користувачем.</value>
  </data>
  <data name="website" xml:space="preserve">
    <value>URL веб-сторінки або блогу Кінцевого Користувача. Ця веб-сторінка ПОВИННА містити дані, опубліковану Кінцевим Користувачем або організацією, з якою афілійований Кінцевий Користувач.</value>
  </data>
  <data name="email" xml:space="preserve">
    <value>Бажана адреса електронної пошти Кінцевого Користувача. Це значення ПОВИННЕ відповідати синтаксису RFC 5322 addr-spec. RP НЕ ПОВИННЕ покладатися на унікальність цього значення.</value>
  </data>
  <data name="email_verified" xml:space="preserve">
    <value>Істина, якщо адреса електронної пошти Кінцевого користувача була перевірена; в іншому випадку - хиба. Якщо це значення істинне, це означає, що ОП вжив позитивних заходів, щоб переконатися, що ця адреса електронної пошти контролювалася Кінцевим користувачем на момент проведення перевірки. Засоби, за допомогою яких здійснюється перевірка адреси електронної пошти, залежать від контексту і системи довіри або договірних угод, в рамках яких діють сторони.</value>
  </data>
  <data name="gender" xml:space="preserve">
    <value>Стать кінцевого користувача. Значення, визначені цією специфікацією, - жіноча чи чоловіча стать. Інші значення МОЖНА використовувати, якщо жодне з визначених значень не підходить.</value>
  </data>
  <data name="birthdate" xml:space="preserve">
    <value>День народження кінцевого користувача, представлений у форматі YYYY-MM-DD (ISO 8601:2004). Рік МОЖЕ бути 0000, що означає, що він не вказується. Для представлення тільки року допускається формат YYYY. Зауважте, що залежно від функції, пов'язаної з датою в базовій платформі, введення лише року може призвести до зміни місяця та дня, тому потрібно враховувати цей фактор для правильної обробки дат.</value>
  </data>
  <data name="zoneinfo" xml:space="preserve">
    <value>Рядок з бази даних часових поясів zoneinfo, що представляє часовий пояс Кінцевого користувача. Наприклад, Europe/Paris або America/Los_Angeles.</value>
  </data>
  <data name="locale" xml:space="preserve">
    <value>Локалізацію кінцевого користувача, представлена у вигляді мовного тегу BCP47 [RFC5646]. Зазвичай це код мови ISO 639-1 Alpha-2 малими літерами та код країни ISO 3166-1 Alpha-2 великими літерами, відокремлені тире. Наприклад, en-US або fr-CA. Як примітка щодо сумісності, в деяких реалізаціях замість тире використовується символ підкреслення, наприклад, en_US; Довірені сторони МОЖУТЬ також прийняти цей синтаксис локалізації.</value>
  </data>
  <data name="phone_number" xml:space="preserve">
    <value>Бажаний номер телефону кінцевого користувача. В якості формату РЕКОМЕНДУЄТЬСЯ використовувати E.164, наприклад, +1 (425) 555-1212 або +56 (2) 687 2400. Якщо номер телефону містить внутрішній номер, РЕКОМЕНДУЄТЬСЯ представляти його за допомогою синтаксису розширення RFC 3966, наприклад, +1 (604) 555-1234;ext=5678.</value>
  </data>
  <data name="phone_number_verified" xml:space="preserve">
    <value>Істина, якщо номер телефону Кінцевого користувача було перевірено; в іншому випадку - хиба. Якщо значення цього параметра є істинним, це означає, що оператор вжив позитивних заходів для того, щоб переконатися, що цей номер телефону контролювався кінцевим користувачем на момент проведення перевірки. Засоби, за допомогою яких перевіряється номер телефону, залежать від контексту і системи довіри або контрактних угод, в рамках яких працюють сторони. При значенні true, вимога phone_number ПОВИННА бути у форматі E.164, а будь-які розширення ПОВИННІ бути представлені у форматі RFC 3966.</value>
  </data>
  <data name="address" xml:space="preserve">
    <value>Бажана поштова адреса Кінцевого користувача. Значення елемента address є структурою JSON [RFC4627].</value>
  </data>
  <data name="updated_at" xml:space="preserve">
    <value>Час останнього оновлення інформації про кінцевого користувача. Його значення - це JSON-число, що представляє кількість секунд від 1970-01-01T0:0:0Z, виміряне в UTC, до дати/часу.</value>
  </data>
  <data name="azp" xml:space="preserve">
    <value>Уповноважена сторона - сторона, якій було видано ID-токен. Якщо присутня, вона ОБОВ'ЯЗКОВО повинна містити ідентифікатор клієнта OAuth 2.0 цієї сторони. Ця вимога необхідна лише тоді, коли ID-токен має єдине значення для аудиторії, і ця аудиторія відрізняється від уповноваженої сторони. Вона МОЖЕ бути включена, навіть якщо уповноважена сторона збігається з єдиною аудиторією. Значення azp - це чутливий до регістру рядок, що містить значення StringOrURI.</value>
  </data>
  <data name="nonce" xml:space="preserve">
    <value>Рядкове значення, що використовується для зв'язування сеансу клієнта з ідентифікатором та для запобігання атакам повторного відтворення. Значення передається без змін із Запиту на автентифікацію до Ідентифікаційного токена. Якщо це значення присутнє в ідентифікаційному токені, клієнти ПОВИННІ перевірити, що значення nonce Claim Value дорівнює значенню параметра nonce, надісланого в запиті на автентифікацію. Якщо він присутній у запиті на автентифікацію, Сервери авторизації ПОВИННІ включити вимогу nonce в ідентифікаційний токен зі значенням вимоги, що дорівнює значенню параметра nonce, надісланому в запиті на автентифікацію. Сервери авторизації НЕ ПОВИННІ виконувати ніякої іншої обробки використовуваних значень nonce. Значення nonce - це рядок, чутливий до регістру.</value>
  </data>
  <data name="auth_time" xml:space="preserve">
    <value>Час, коли відбулася автентифікація кінцевого користувача. Його значенням є JSON-число, що представляє кількість секунд від 1970-01-01T0:0:0Z, виміряне в UTC, до дати/часу. Коли робиться запит max_age або коли auth_time запитується як основний параметр, то цей параметр є ОБОВ'ЯЗКОВИМ; в іншому випадку його включення є НЕОБОВ'ЯЗКОВИМ. (Параметр auth_time семантично відповідає параметру відповіді OpenID 2.0 PAPE auth_time)</value>
  </data>
  <data name="at_hash" xml:space="preserve">
    <value>Хеш-значення токена доступу. Його значення - це кодування base64url крайньої лівої половини хешу октетів ASCII представлення значення access_token, де використаний алгоритм хешування - це алгоритм хешування, використаний у параметрі alg заголовка JOSE заголовка ID-токену. Наприклад, якщо alg - RS256, хешуйте значення access_token за допомогою SHA-256, потім візьміть крайні ліві 128 біт і закодуйте їх base64url. Значення at_hash є чутливим до регістру рядком.</value>
  </data>
  <data name="c_hash" xml:space="preserve">
    <value>Хеш-значення коду. Його значення - кодування в base64url крайньої лівої половини хешу октетів ASCII представлення значення коду, де використаний алгоритм хешування - це алгоритм хешування, використаний у параметрі alg заголовка JOSE - заголовка ідентифікаційного токену. Наприклад, якщо alg має значення HS512, хешуйте значення коду за допомогою SHA-512, потім візьміть крайні ліві 256 біт і закодуйте їх за допомогою base64url. Значення c_hash є чутливим до регістру. Якщо ID-токен видається з кінцевої точки авторизації з кодом, як у випадку зі значеннями response_type код id_token та код id_token токена, то це значення є ОБОВ'ЯЗКОВИМ, в іншому випадку його включення є НЕОБОВ'ЯЗКОВИМ.</value>
  </data>
  <data name="acr" xml:space="preserve">
    <value>Посилання на клас контексту автентифікації. Рядок, що вказує значення посилання на клас контексту автентифікації, яке ідентифікує клас контексту автентифікації, якому відповідає виконана автентифікація. Значення "0" означає, що автентифікація кінцевого користувача не відповідає вимогам ISO/IEC 29115 рівня 1. Наприклад, автентифікація з використанням довготривалих файлів cookie браузера є одним із прикладів, коли використання "рівня 0" є доречним. Автентифікація рівня 0 НЕ повинна використовуватися для авторизації доступу до будь-яких ресурсів, що мають будь-яку грошову цінність. (Це відповідає OpenID 2.0 PAPE nist_auth_level 0.) Як значення acr слід використовувати абсолютний URI або зареєстроване ім'я згідно з RFC 6711; зареєстровані імена НЕ МОЖНА використовувати з іншим значенням, що відрізняються від зареєстрованого. Сторони, які використовують це твердження, повинні узгодити значення використаних параметрів, які можуть залежати від контексту. Значення acr - це рядок, чутливий до регістру.</value>
  </data>
  <data name="amr" xml:space="preserve">
    <value>Посилання на методи автентифікації. JSON-масив рядків, які є ідентифікаторами методів автентифікації, використаних при автентифікації. Наприклад, значення можуть вказувати на те, що були використані методи автентифікації за допомогою пароля та OTP. Сторонам, які використовують це положення, потрібно буде домовитися про значення використаних даних, які можуть залежати від конкретного контексту. Значення amr - це масив рядків, чутливих до регістру.</value>
  </data>
  <data name="sub_jwk" xml:space="preserve">
    <value>Відкритий ключ, який використовується для перевірки підпису ідентифікаційного токена, виданого постачальником самоемітованих OpenID. Ключ є відкритим ключем у форматі JWK (не є значенням сертифікату X.509). Значення sub_jwk - це JSON-об'єкт. Використання вимоги sub_jwk НЕ РЕКОМЕНДУЄТЬСЯ, якщо OP не є самоемітованим.</value>
  </data>
</root>
