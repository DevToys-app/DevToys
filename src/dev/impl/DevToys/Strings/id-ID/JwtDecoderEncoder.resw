<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Alat Encoder / Decoder JWT</value>
  </data>
  <data name="MenuDisplayName" xml:space="preserve">
    <value>JWT</value>
  </data>
  <data name="JwtHeaderLabel" xml:space="preserve">
    <value>Judul</value>
  </data>
  <data name="JwtTokenLabel" xml:space="preserve">
    <value>Token</value>
  </data>
  <data name="JwtPayloadLabel" xml:space="preserve">
    <value>Muatan</value>
  </data>
  <data name="Type" xml:space="preserve">
    <value>Mengetik</value>
  </data>
  <data name="Value" xml:space="preserve">
    <value>Nilai</value>
  </data>
  <data name="DescriptionHeader" xml:space="preserve">
    <value>Deskripsi</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Decode tajuk JWT, muat dan tanda tangan</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value/>
  </data>
  <data name="Algorithm" xml:space="preserve">
    <value>Algoritma</value>
  </data>
  <data name="DecodeSwitchModeLabel" xml:space="preserve">
    <value>Dekode</value>
  </data>
  <data name="DecodeValidateTokenLabel" xml:space="preserve">
    <value>Validasi Token</value>
  </data>
  <data name="DecodeValidateTokenNoLabel" xml:space="preserve">
    <value>Tidak</value>
  </data>
  <data name="DecodeValidateTokenYesLabel" xml:space="preserve">
    <value>Iya</value>
  </data>
  <data name="EncodeExpirationTitle" xml:space="preserve">
    <value>Token memiliki kedaluwarsa</value>
  </data>
  <data name="EncodeExpirationMonthLabel" xml:space="preserve">
    <value>Berakhir dalam bulan(-bulan)</value>
  </data>
  <data name="EncodeExpirationYearLabel" xml:space="preserve">
    <value>Berakhir dalam tahun(-tahun)</value>
  </data>
  <data name="EncodeHashingTitle" xml:space="preserve">
    <value>Algoritma hashing token</value>
  </data>
  <data name="EncodeSettingsTitle" xml:space="preserve">
    <value>Pengaturan</value>
  </data>
  <data name="EncodeSwitchModeLabel" xml:space="preserve">
    <value>Enkode</value>
  </data>
  <data name="SettingsSwitchModeLabel" xml:space="preserve">
    <value>Encode / Decode</value>
  </data>
  <data name="SettingsTitle" xml:space="preserve">
    <value>Konfigurasi</value>
  </data>
  <data name="EncodeDefaultTimeTitle" xml:space="preserve">
    <value>Token memiliki waktu default</value>
  </data>
  <data name="EncodeExpirationDaysLabel" xml:space="preserve">
    <value>Kedaluwarsa dalam hari(-hari)</value>
  </data>
  <data name="EncodeExpirationHoursLabel" xml:space="preserve">
    <value>Kedaluwarsa dalam beberapa jam (jam)</value>
  </data>
  <data name="EncodeExpirationMinutesLabel" xml:space="preserve">
    <value>Kedaluwarsa dalam beberapa menit (menit)</value>
  </data>
  <data name="PrivateKeyLabel" xml:space="preserve">
    <value>Kunci Pribadi</value>
  </data>
  <data name="SignatureLabel" xml:space="preserve">
    <value>Tanda tangan</value>
  </data>
  <data name="JwtNotValidated" xml:space="preserve">
    <value>Token tidak divalidasi (tidak ada parameter yang dipilih)</value>
  </data>
  <data name="JwtIsValidMessage" xml:space="preserve">
    <value>Token divalidasi</value>
  </data>
  <data name="InvalidPublicKeyError" xml:space="preserve">
    <value>Kunci Publik tidak valid</value>
  </data>
  <data name="JwtInValidMessage" xml:space="preserve">
    <value>Tanda Tangan Tidak Valid</value>
  </data>
  <data name="DecodeValidateActorLabel" xml:space="preserve">
    <value>Validasi aktor</value>
  </data>
  <data name="DecodeValidateAudienceLabel" xml:space="preserve">
    <value>Validasi audiens</value>
  </data>
  <data name="DecodeValidateIssuerSigningKey" xml:space="preserve">
    <value>Validasi kunci penandatanganan penerbit</value>
  </data>
  <data name="DecodeValidateIssuerLabel" xml:space="preserve">
    <value>Memvalidasi penerbit</value>
  </data>
  <data name="DecodeValidateLifetimeLabel" xml:space="preserve">
    <value>Validasi seumur hidup</value>
  </data>
  <data name="ValidAudiencesLabel" xml:space="preserve">
    <value>Audiens valid</value>
  </data>
  <data name="ValidIssuersLabel" xml:space="preserve">
    <value>Penerbit valid</value>
  </data>
  <data name="DecodeValidationSettingsDescription" xml:space="preserve">
    <value>Pilih parameter token yang akan divalidasi</value>
  </data>
  <data name="DecodeValidationSettingsTitle" xml:space="preserve">
    <value>Pengaturan validasi token</value>
  </data>
  <data name="ValidAudiencesError" xml:space="preserve">
    <value>Audiens yang valid kosong</value>
  </data>
  <data name="ValidIssuersError" xml:space="preserve">
    <value>Penerbit yang valid kosong</value>
  </data>
  <data name="PublicKeyIsPrivateKeyError" xml:space="preserve">
    <value>Kunci publik yang disediakan adalah kunci pribadi</value>
  </data>
  <data name="EncodeAudienceLabel" xml:space="preserve">
    <value>Token memiliki audiens</value>
  </data>
  <data name="EncodeIssuerLabel" xml:space="preserve">
    <value>Token memiliki penerbit</value>
  </data>
  <data name="EncodeSettingsDescription" xml:space="preserve">
    <value>Pilih parameter token</value>
  </data>
  <data name="InvalidPrivateKeyError" xml:space="preserve">
    <value>Kunci Pribadi tidak valid</value>
  </data>
  <data name="PublicKeyLabel" xml:space="preserve">
    <value>Kunci Publik</value>
  </data>
  <data name="SearchDisplayName" xml:space="preserve">
    <value>Encoder / Dekoder JWT</value>
  </data>
  <data name="InvalidSignatureError" xml:space="preserve">
    <value>Tanda Tangan Tidak Valid</value>
  </data>
  <data name="NoDescription" xml:space="preserve">
    <value>Tidak ada deskripsi</value>
  </data>
  <data name="iss" xml:space="preserve">
    <value>Klaim "iss" (penerbit) mengidentifikasi prinsipal yang menerbitkan JWT. Pemrosesan klaim ini umumnya bersifat spesifik untuk aplikasi tertentu. Nilai "iss" adalah string peka huruf besar-kecil yang berisi nilai StringOrURI. Penggunaan klaim ini bersifat OPSIONAL.</value>
  </data>
  <data name="sub" xml:space="preserve">
    <value>Klaim "sub" (subjek) mengidentifikasi prinsipal yang menjadi subjek JWT. Klaim dalam JWT biasanya merupakan pernyataan tentang subjek. Nilai subjek HARUS memiliki cakupan yang unik secara lokal dalam konteks penerbit atau unik secara global. Pemrosesan klaim ini umumnya bersifat spesifik untuk aplikasi tertentu. Nilai "sub" adalah string peka huruf besar-kecil yang berisi nilai StringOrURI. Penggunaan klaim ini bersifat OPSIONAL.</value>
  </data>
  <data name="aud" xml:space="preserve">
    <value>Klaim "aud" (audiens) mengidentifikasi penerima yang menjadi tujuan JWT. Setiap prinsipal yang dimaksudkan untuk memproses JWT HARUS mengidentifikasi dirinya dengan nilai dalam klaim audiens. Jika prinsipal yang memproses klaim tidak mengidentifikasi dirinya dengan nilai dalam klaim "aud" ketika klaim ini ada, maka JWT HARUS ditolak. Dalam kasus umum, nilai "aud" adalah larik string yang peka huruf besar-kecil, masing-masing berisi nilai StringOrURI. Dalam kasus khusus ketika JWT memiliki satu audiens, nilai "aud" MUNGKIN berupa satu string peka huruf besar-kecil yang berisi nilai StringOrURI. Interpretasi nilai audiens umumnya bersifat spesifik untuk aplikasi tertentu. Penggunaan klaim ini bersifat OPSIONAL.</value>
  </data>
  <data name="exp" xml:space="preserve">
    <value>Klaim "exp" (waktu kedaluwarsa) menunjukkan waktu kedaluwarsa pada atau setelahnya di mana JWT TIDAK BOLEH diterima untuk diproses. Pemrosesan klaim "exp" mensyaratkan bahwa tanggal/waktu saat ini HARUS sebelum tanggal/waktu kedaluwarsa yang tercantum dalam klaim "exp". Pelaksana MUNGKIN memberikan kelonggaran, biasanya tidak lebih dari beberapa menit, untuk memperhitungkan kemiringan jam. Nilainya HARUS berupa angka yang mengandung nilai NumericDate. Penggunaan klaim ini bersifat OPSIONAL.</value>
  </data>
  <data name="nbf" xml:space="preserve">
    <value>Klaim "nbf" (not before) mengidentifikasi waktu sebelum JWT TIDAK BOLEH diterima untuk diproses. Pemrosesan klaim "nbf" mensyaratkan bahwa tanggal/waktu saat ini HARUS setelah atau sama dengan tanggal/waktu sebelum yang tercantum dalam klaim "nbf". Pelaksana MUNGKIN memberikan kelonggaran kecil, biasanya tidak lebih dari beberapa menit, untuk memperhitungkan kemiringan jam. Nilainya HARUS berupa angka yang mengandung nilai NumericDate. Penggunaan klaim ini bersifat OPSIONAL.</value>
  </data>
  <data name="iat" xml:space="preserve">
    <value>Klaim "iat" (diterbitkan pada) mengidentifikasi waktu penerbitan JWT. Klaim ini dapat digunakan untuk menentukan usia JWT. Nilainya HARUS berupa angka yang mengandung nilai NumericDate. Penggunaan klaim ini bersifat OPSIONAL.</value>
  </data>
  <data name="jti" xml:space="preserve">
    <value>Klaim "jti" (ID JWT) memberikan pengenal unik untuk JWT. Nilai pengenal HARUS ditetapkan dengan cara yang memastikan bahwa ada kemungkinan yang dapat diabaikan bahwa nilai yang sama akan secara tidak sengaja ditetapkan ke objek data yang berbeda; jika aplikasi menggunakan beberapa penerbit, tabrakan HARUS dicegah di antara nilai-nilai yang dihasilkan oleh penerbit yang berbeda juga. Klaim "jti" dapat digunakan untuk mencegah JWT diputar ulang. Nilai "jti" adalah string yang peka terhadap huruf besar/kecil. Penggunaan klaim ini bersifat OPSIONAL.</value>
  </data>
  <data name="name" xml:space="preserve">
    <value>Nama lengkap Pengguna Akhir dalam bentuk yang dapat ditampilkan termasuk semua bagian nama, mungkin termasuk gelar dan sufiks, diurutkan sesuai dengan lokasi dan preferensi Pengguna Akhir.</value>
  </data>
  <data name="given_name" xml:space="preserve">
    <value>Nama yang diberikan atau nama depan Pengguna Akhir. Perhatikan bahwa dalam beberapa budaya, orang dapat memiliki beberapa nama yang diberikan; semua nama dapat muncul, dengan nama yang dipisahkan oleh karakter spasi.</value>
  </data>
  <data name="family_name" xml:space="preserve">
    <value>Nama keluarga atau nama belakang Pengguna Akhir. Perhatikan bahwa dalam beberapa budaya, orang dapat memiliki beberapa nama keluarga atau tanpa nama keluarga; semua nama dapat muncul, dengan nama yang dipisahkan oleh karakter spasi.</value>
  </data>
  <data name="middle_name" xml:space="preserve">
    <value>Nama tengah Pengguna Akhir. Perhatikan bahwa di beberapa budaya, orang dapat memiliki beberapa nama tengah; semua nama dapat muncul, dengan nama yang dipisahkan oleh karakter spasi. Perhatikan juga bahwa di beberapa budaya, nama tengah tidak digunakan.</value>
  </data>
  <data name="nickname" xml:space="preserve">
    <value>Nama kasual Pengguna Akhir yang mungkin sama atau tidak sama dengan given_name. Misalnya, nilai nama panggilan Mike mungkin dikembalikan bersama dengan nilai given_name Michael.</value>
  </data>
  <data name="preferred_username" xml:space="preserve">
    <value>Nama singkatan yang ingin dirujuk oleh Pengguna Akhir di RP, seperti janedoe atau j.doe. Nilai ini MUNGKIN berupa string JSON yang valid, termasuk karakter khusus seperti @, /, atau spasi. RP TIDAK HARUS bergantung pada nilai ini sebagai nilai yang unik.</value>
  </data>
  <data name="profile" xml:space="preserve">
    <value>URL halaman profil Pengguna Akhir. Isi halaman Web ini HARUS mengenai Pengguna Akhir.</value>
  </data>
  <data name="picture" xml:space="preserve">
    <value>URL gambar profil Pengguna Akhir. URL ini HARUS merujuk ke file gambar (misalnya, file gambar PNG, JPEG, atau GIF), dan bukan ke halaman Web yang berisi gambar. Perhatikan bahwa URL ini HARUS secara khusus merujuk pada foto profil Pengguna Akhir yang sesuai untuk ditampilkan saat mendeskripsikan Pengguna Akhir, dan bukan foto sembarangan yang diambil oleh Pengguna Akhir.</value>
  </data>
  <data name="website" xml:space="preserve">
    <value>URL halaman Web atau blog Pengguna Akhir. Halaman Web ini HARUS berisi informasi yang diterbitkan oleh Pengguna Akhir atau organisasi yang berafiliasi dengan Pengguna Akhir.</value>
  </data>
  <data name="email" xml:space="preserve">
    <value>Alamat email pilihan Pengguna Akhir. Nilainya HARUS sesuai dengan sintaks addr-spec RFC 5322. RP TIDAK HARUS bergantung pada nilai ini sebagai nilai yang unik.</value>
  </data>
  <data name="email_verified" xml:space="preserve">
    <value>Benar jika alamat email Pengguna Akhir telah diverifikasi; jika tidak, salah. Jika Nilai Klaim ini benar, ini berarti OP mengambil langkah tegas untuk memastikan bahwa alamat email ini dikendalikan oleh Pengguna Akhir pada saat verifikasi dilakukan. Cara yang digunakan untuk memverifikasi alamat email bersifat spesifik untuk setiap konteks, dan bergantung pada kerangka kerja kepercayaan atau perjanjian kontrak yang digunakan oleh para pihak.</value>
  </data>
  <data name="gender" xml:space="preserve">
    <value>Jenis kelamin Pengguna Akhir. Nilai yang ditentukan oleh spesifikasi ini adalah perempuan dan laki-laki. Nilai lain MUNGKIN digunakan bila tidak ada nilai yang ditentukan yang dapat diterapkan.</value>
  </data>
  <data name="birthdate" xml:space="preserve">
    <value>Ulang tahun Pengguna Akhir, direpresentasikan sebagai format ISO 8601:2004 YYYY-MM-DD. Tahun MUNGKIN 0000, yang menunjukkan bahwa tahun tersebut dihilangkan. Untuk mewakili tahun saja, format YYYY diperbolehkan. Perhatikan bahwa tergantung pada fungsi terkait tanggal platform yang mendasari, menyediakan tahun saja dapat menghasilkan bulan dan hari yang berbeda-beda, sehingga pelaksana perlu mempertimbangkan faktor ini untuk memproses tanggal dengan benar.</value>
  </data>
  <data name="zoneinfo" xml:space="preserve">
    <value>String dari basis data zona waktu zoneinfo yang mewakili zona waktu Pengguna Akhir. Misalnya, Eropa/Paris atau Amerika/Los_Angeles.</value>
  </data>
  <data name="locale" xml:space="preserve">
    <value>Lokasi Pengguna Akhir, direpresentasikan sebagai tag bahasa BCP47 [RFC5646]. Ini biasanya berupa kode bahasa ISO 639-1 Alpha-2 dalam huruf kecil dan kode negara ISO 3166-1 Alpha-2 dalam huruf besar, dipisahkan dengan tanda hubung. Misalnya, en-US atau fr-CA. Sebagai catatan kompatibilitas, beberapa implementasi telah menggunakan garis bawah sebagai pemisah daripada tanda hubung, misalnya, en_US; Pihak yang Mengandalkan MUNGKIN memilih untuk menerima sintaks lokal ini juga.</value>
  </data>
  <data name="phone_number" xml:space="preserve">
    <value>Nomor telepon pilihan Pengguna Akhir. E.164 DIREKOMENDASIKAN sebagai format Klaim ini, misalnya, +1 (425) 555-1212 atau +56 (2) 687 2400. Jika nomor telepon berisi ekstensi, DIREKOMENDASIKAN agar ekstensi diwakili menggunakan sintaks ekstensi RFC 3966, misalnya, +1 (604) 555-1234;ext=5678.</value>
  </data>
  <data name="phone_number_verified" xml:space="preserve">
    <value>Benar jika nomor telepon Pengguna Akhir telah diverifikasi; jika tidak, salah. Jika Nilai Klaim ini benar, ini berarti OP mengambil langkah tegas untuk memastikan bahwa nomor telepon ini dikendalikan oleh Pengguna Akhir pada saat verifikasi dilakukan. Cara yang digunakan untuk memverifikasi nomor telepon bersifat spesifik dalam konteks tertentu, dan bergantung pada kerangka kerja kepercayaan atau perjanjian kontrak yang digunakan oleh para pihak. Jika benar, Klaim nomor_telepon HARUS dalam format E.164 dan ekstensi apa pun HARUS direpresentasikan dalam format RFC 3966.</value>
  </data>
  <data name="address" xml:space="preserve">
    <value>Alamat pos pilihan Pengguna Akhir. Nilai anggota alamat adalah struktur JSON [RFC4627].</value>
  </data>
  <data name="updated_at" xml:space="preserve">
    <value>Waktu informasi Pengguna Akhir terakhir kali diperbarui. Nilainya adalah angka JSON yang mewakili jumlah detik dari 1970-01-01T0:0:0Z yang diukur dalam UTC hingga tanggal/waktu.</value>
  </data>
  <data name="azp" xml:space="preserve">
    <value>Pihak yang berwenang - pihak yang mengeluarkan Token ID. Jika ada, harus berisi ID Klien OAuth 2.0 dari pihak ini. Klaim ini hanya diperlukan jika Token ID memiliki nilai audiens tunggal dan audiens tersebut berbeda dari pihak yang berwenang. Ini MUNGKIN disertakan bahkan ketika pihak yang berwenang sama dengan audiens tunggal. Nilai azp adalah string peka huruf besar/kecil yang berisi nilai StringOrURI.</value>
  </data>
  <data name="nonce" xml:space="preserve">
    <value>Nilai string yang digunakan untuk mengaitkan sesi Klien dengan Token ID, dan untuk mengurangi serangan replay. Nilai ini diteruskan tanpa modifikasi dari Permintaan Otentikasi ke Token ID. Jika ada dalam Token ID, Klien HARUS memverifikasi bahwa Nilai Klaim nonce sama dengan nilai parameter nonce yang dikirim dalam Permintaan Otentikasi. Jika ada dalam Permintaan Otentikasi, Server Otorisasi HARUS menyertakan Klaim nonce dalam Token ID dengan Nilai Klaim adalah nilai nonce yang dikirim dalam Permintaan Otentikasi. Server Otorisasi HARUS tidak melakukan pemrosesan lain pada nilai nonce yang digunakan. Nilai nonce adalah string yang peka terhadap huruf besar/kecil.</value>
  </data>
  <data name="auth_time" xml:space="preserve">
    <value>Waktu ketika autentikasi Pengguna Akhir terjadi. Nilainya adalah nomor JSON yang mewakili jumlah detik dari 1970-01-01T0:0:0Z yang diukur dalam UTC hingga tanggal/waktu. Saat permintaan max_age dibuat atau saat auth_time diminta sebagai Klaim Penting, maka Klaim ini DIWAJIBKAN; jika tidak, pencantumannya bersifat OPSI (Klaim auth_time secara semantik sesuai dengan parameter respons auth_time OpenID 2.0 PAPE)</value>
  </data>
  <data name="at_hash" xml:space="preserve">
    <value>Nilai hash Token Akses. Nilainya adalah pengkodean base64url dari setengah bagian paling kiri dari hash oktet representasi ASCII dari nilai access_token, di mana algoritme hash yang digunakan adalah algoritme hash yang digunakan pada Parameter Header alg dari Header JOSE Token ID. Sebagai contoh, jika alg adalah RS256, hash nilai access_token dengan SHA-256, kemudian ambil 128 bit paling kiri dan encode base64url. Nilai at_hash adalah string yang peka terhadap huruf besar/kecil.</value>
  </data>
  <data name="c_hash" xml:space="preserve">
    <value>Nilai hash kode. Nilainya adalah pengkodean base64url dari setengah bagian paling kiri dari hash oktet representasi ASCII dari nilai kode, di mana algoritme hash yang digunakan adalah algoritme hash yang digunakan dalam Parameter Header alg dari Header JOSE Token ID. Sebagai contoh, jika alg adalah HS512, hash nilai kode dengan SHA-512, kemudian ambil 256 bit paling kiri dan encode base64url. Nilai c_hash adalah string yang peka terhadap huruf besar/kecil. Jika Token ID dikeluarkan dari Titik Akhir Otorisasi dengan kode, yang merupakan kasus untuk nilai response_type kode id_token dan kode id_token token, ini DIPERLUKAN; jika tidak, penyertaannya bersifat OPSIONAL.</value>
  </data>
  <data name="acr" xml:space="preserve">
    <value>Referensi Kelas Konteks Otentikasi. String yang menentukan nilai Referensi Kelas Konteks Otentikasi yang mengidentifikasi Kelas Konteks Otentikasi yang telah dipenuhi oleh otentikasi yang dilakukan. Nilai "0" menunjukkan autentikasi Pengguna Akhir tidak memenuhi persyaratan ISO/IEC 29115 level 1. Autentikasi menggunakan cookie browser yang berumur panjang, misalnya, adalah salah satu contoh di mana penggunaan "level 0" sesuai. Otentikasi dengan level 0 TIDAK BOLEH digunakan untuk mengesahkan akses ke sumber daya apa pun dengan nilai uang apa pun. (Ini sesuai dengan OpenID 2.0 PAPE nist_auth_level 0.) URI absolut atau nama terdaftar RFC 6711 HARUS digunakan sebagai nilai acr; nama terdaftar TIDAK BOLEH digunakan dengan arti yang berbeda dari yang terdaftar. Pihak-pihak yang menggunakan klaim ini harus menyetujui arti dari nilai yang digunakan, yang mungkin bersifat spesifik. Nilai acr adalah string yang peka huruf besar/kecil.</value>
  </data>
  <data name="amr" xml:space="preserve">
    <value>Referensi Metode Otentikasi. Larik string JSON yang merupakan pengidentifikasi untuk metode autentikasi yang digunakan dalam autentikasi. Misalnya, nilai dapat menunjukkan bahwa metode autentikasi kata sandi dan OTP digunakan. Pihak-pihak yang menggunakan klaim ini harus menyetujui arti dari nilai yang digunakan, yang mungkin bersifat spesifik. Nilai amr adalah sebuah larik string yang peka terhadap huruf besar/kecil.</value>
  </data>
  <data name="sub_jwk" xml:space="preserve">
    <value>Kunci publik yang digunakan untuk memeriksa tanda tangan Token ID yang dikeluarkan oleh Penyedia OpenID yang diterbitkan sendiri. Kunci ini adalah kunci telanjang dalam format JWK (bukan nilai sertifikat X.509). Nilai sub_jwk adalah objek JSON. Penggunaan sub_jwk Claim TIDAK DIANJURKAN ketika OP tidak diterbitkan sendiri.</value>
  </data>
</root>
