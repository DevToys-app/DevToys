<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Narzędzie Enkodujące i Dekodujące JWT</value>
  </data>
  <data name="MenuDisplayName" xml:space="preserve">
    <value>JWT</value>
  </data>
  <data name="JwtHeaderLabel" xml:space="preserve">
    <value>Nagłówek</value>
  </data>
  <data name="JwtTokenLabel" xml:space="preserve">
    <value>Token</value>
  </data>
  <data name="JwtPayloadLabel" xml:space="preserve">
    <value>Zawartość</value>
  </data>
  <data name="Type" xml:space="preserve">
    <value>Typ</value>
  </data>
  <data name="Value" xml:space="preserve">
    <value>Wartość</value>
  </data>
  <data name="DescriptionHeader" xml:space="preserve">
    <value>Opis</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Dekoduj nagłówek JWT, jego zawartość oraz sygnaturę</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value/>
  </data>
  <data name="Algorithm" xml:space="preserve">
    <value>Algorytm</value>
  </data>
  <data name="DecodeSwitchModeLabel" xml:space="preserve">
    <value>Dekoduj</value>
  </data>
  <data name="DecodeValidateTokenLabel" xml:space="preserve">
    <value>Sprawdź token</value>
  </data>
  <data name="DecodeValidateTokenNoLabel" xml:space="preserve">
    <value>Nie</value>
  </data>
  <data name="DecodeValidateTokenYesLabel" xml:space="preserve">
    <value>Tak</value>
  </data>
  <data name="EncodeExpirationTitle" xml:space="preserve">
    <value>Token ma wygasłość</value>
  </data>
  <data name="EncodeExpirationMonthLabel" xml:space="preserve">
    <value>Wygasa za miesiąc(ce, cy)</value>
  </data>
  <data name="EncodeExpirationYearLabel" xml:space="preserve">
    <value>Wygasa za rok(lata, lat)</value>
  </data>
  <data name="EncodeHashingTitle" xml:space="preserve">
    <value>Algorytm haszowania tokenu</value>
  </data>
  <data name="EncodeSettingsTitle" xml:space="preserve">
    <value>Ustawienia</value>
  </data>
  <data name="EncodeSwitchModeLabel" xml:space="preserve">
    <value>Enkoduj</value>
  </data>
  <data name="SettingsSwitchModeLabel" xml:space="preserve">
    <value>Enkoduj / Dekoduj</value>
  </data>
  <data name="SettingsTitle" xml:space="preserve">
    <value>Konfiguracja</value>
  </data>
  <data name="EncodeDefaultTimeTitle" xml:space="preserve">
    <value>Token ma domyślny czas</value>
  </data>
  <data name="EncodeExpirationDaysLabel" xml:space="preserve">
    <value>Wygasa za dzień(dni)</value>
  </data>
  <data name="EncodeExpirationHoursLabel" xml:space="preserve">
    <value>Wygasa za godzinę(ny)</value>
  </data>
  <data name="EncodeExpirationMinutesLabel" xml:space="preserve">
    <value>Wygasa za minutę(ty)</value>
  </data>
  <data name="PrivateKeyLabel" xml:space="preserve">
    <value>Klucz prywatny</value>
  </data>
  <data name="SignatureLabel" xml:space="preserve">
    <value>Podpis</value>
  </data>
  <data name="JwtNotValidated" xml:space="preserve">
    <value>Token nie został zatwierdzony (nie wybrano żadnych parametrów)</value>
  </data>
  <data name="JwtIsValidMessage" xml:space="preserve">
    <value>Token zweryfikowany</value>
  </data>
  <data name="InvalidPublicKeyError" xml:space="preserve">
    <value>Nieprawidłowy Klucz Publiczny</value>
  </data>
  <data name="JwtInValidMessage" xml:space="preserve">
    <value>Nieprawidłowy Podpis</value>
  </data>
  <data name="DecodeValidateActorLabel" xml:space="preserve">
    <value>Zatwierdź aktora</value>
  </data>
  <data name="DecodeValidateAudienceLabel" xml:space="preserve">
    <value>Zatwierdź odbiorców</value>
  </data>
  <data name="DecodeValidateIssuerSigningKey" xml:space="preserve">
    <value>Sprawdź poprawność klucza podpisującego wystawcę</value>
  </data>
  <data name="DecodeValidateIssuerLabel" xml:space="preserve">
    <value>Zatwierdź emitenta</value>
  </data>
  <data name="DecodeValidateLifetimeLabel" xml:space="preserve">
    <value>Zatwierdź okres ważności</value>
  </data>
  <data name="ValidAudiencesLabel" xml:space="preserve">
    <value>Zatwierdź odbiorców</value>
  </data>
  <data name="ValidIssuersLabel" xml:space="preserve">
    <value>Zatwiedź emitentów</value>
  </data>
  <data name="DecodeValidationSettingsDescription" xml:space="preserve">
    <value>Wybierz, które parametry tokenu chcesz sprawdzić</value>
  </data>
  <data name="DecodeValidationSettingsTitle" xml:space="preserve">
    <value>Ustawienia weryfikacji tokenu</value>
  </data>
  <data name="ValidAudiencesError" xml:space="preserve">
    <value>Brak poprawnych odbiorców</value>
  </data>
  <data name="ValidIssuersError" xml:space="preserve">
    <value>Brak poprawnych emitentów</value>
  </data>
  <data name="PublicKeyIsPrivateKeyError" xml:space="preserve">
    <value>Podany klucz publiczny jest kluczem prywatnym</value>
  </data>
  <data name="EncodeAudienceLabel" xml:space="preserve">
    <value>Token ma odbiorcę</value>
  </data>
  <data name="EncodeIssuerLabel" xml:space="preserve">
    <value>Token ma emitenta</value>
  </data>
  <data name="EncodeSettingsDescription" xml:space="preserve">
    <value>Wybierz parametry tokena</value>
  </data>
  <data name="InvalidPrivateKeyError" xml:space="preserve">
    <value>Nieprawidłowy Klucz Prywatny</value>
  </data>
  <data name="PublicKeyLabel" xml:space="preserve">
    <value>Klucz publiczny</value>
  </data>
  <data name="SearchDisplayName" xml:space="preserve">
    <value>Enkoder / Dekoder JWT</value>
  </data>
  <data name="InvalidSignatureError" xml:space="preserve">
    <value>Nieprawidłowy Podpis</value>
  </data>
  <data name="NoDescription" xml:space="preserve">
    <value>Brak opisu</value>
  </data>
  <data name="iss" xml:space="preserve">
    <value>Oświadczenie "iss" (wystawca) identyfikuje zleceniodawcę, który wystawił JWT. Przetwarzanie tego oświadczenia jest generalnie specyficzne dla aplikacji. Wartość "iss" to rozróżniający wielkość liter ciąg znaków zawierający wartość StringOrURI. Użycie tego oświadczenia jest OPCJONALNE.</value>
  </data>
  <data name="sub" xml:space="preserve">
    <value>Oświadczenie "sub" (temat) identyfikuje podmiot, który jest przedmiotem JWT. Oświadczenia w JWT są zwykle stwierdzeniami dotyczącymi podmiotu. Wartość subject MUSI być określona tak, aby była lokalnie unikalna w kontekście wystawcy lub globalnie unikalna. Przetwarzanie tego oświadczenia jest zasadniczo specyficzne dla aplikacji. Wartość "sub" to rozróżniający wielkość liter ciąg znaków zawierający wartość StringOrURI. Użycie tego oświadczenia jest OPCJONALNE.</value>
  </data>
  <data name="aud" xml:space="preserve">
    <value>Oświadczenie "aud" (audience) identyfikuje odbiorców, dla których przeznaczony jest JWT. Każdy podmiot, który ma przetwarzać JWT, MUSI zidentyfikować się za pomocą wartości w oświadczeniu odbiorców. Jeśli podmiot przetwarzający oświadczenie nie identyfikuje się z wartością w oświadczeniu "aud", gdy to oświadczenie jest obecne, wówczas JWT MUSI zostać odrzucone. W ogólnym przypadku wartość "aud" jest tablicą łańcuchów z rozróżnianiem wielkości liter, z których każdy zawiera wartość StringOrURI. W szczególnym przypadku, gdy JWT ma jednego odbiorcę, wartość "aud" MOŻE być pojedynczym rozróżniającym wielkość liter ciągiem znaków zawierającym wartość StringOrURI. Interpretacja wartości odbiorców jest zasadniczo zależna od aplikacji. Użycie tego oświadczenia jest OPCJONALNE.</value>
  </data>
  <data name="exp" xml:space="preserve">
    <value>Oświadczenie "exp" (czas wygaśnięcia) określa czas wygaśnięcia, w którym lub po którym JWT NIE MOŻE zostać zaakceptowany do przetwarzania. Przetwarzanie oświadczenia "exp" wymaga, aby bieżąca data/godzina MUSIAŁA być wcześniejsza niż data/godzina wygaśnięcia wymieniona w oświadczeniu "exp". Implementatorzy MOGĄ zapewnić pewną niewielką swobodę, zwykle nie większą niż kilka minut, w celu uwzględnienia odchylenia zegara. Jego wartość MUSI być liczbą zawierającą wartość NumericDate. Użycie tego oświadczenia jest OPCJONALNE.</value>
  </data>
  <data name="nbf" xml:space="preserve">
    <value>Roszczenie "nbf" (nie wcześniej) określa czas, przed którym JWT nie może zostać przyjęty do przetwarzania. Przetwarzanie roszczenia "nbf" wymaga, aby bieżąca data/godzina MUSIAŁA być późniejsza lub równa dacie/godzinie niewcześniejszej wymienionej w oświadczeniu "nbf". Realizatorzy MOGĄ zapewnić niewielką swobodę, zwykle nie dłuższą niż kilka minut, aby uwzględnić przekrzywienie zegara. Jego wartość MUSI być liczbą zawierającą wartość NumericDate. Użycie tego oświadczenia jest OPCJONALNE.</value>
  </data>
  <data name="iat" xml:space="preserve">
    <value>Roszczenie "iat" (wydane w) określa czas, w którym JWT został wydany. To twierdzenie może być wykorzystane do określenia wieku JWT. Jego wartość MUSI być liczbą zawierającą wartość NumericDate. Użycie tego oświadczenia jest OPCJONALNE.</value>
  </data>
  <data name="jti" xml:space="preserve">
    <value>Oświadczenie "JTI" (JWT ID) zapewnia unikalny identyfikator JWT. Wartość identyfikatora MUSI być przypisana w sposób zapewniający znikome prawdopodobieństwo, że ta sama wartość zostanie przypadkowo przypisana do innego obiektu danych; jeśli aplikacja korzysta z wielu emitentów, należy zapobiegać kolizjom między wartościami generowanymi przez różnych emitentów. Oświadczenie "jti" może być użyte do zapobieżenia powtórzeniu JWT. Wartość "jti" jest ciągiem uwzględniającym wielkość liter. Użycie tego oświadczenia jest OPCJONALNE.</value>
  </data>
  <data name="name" xml:space="preserve">
    <value>Pełna nazwa Użytkownika końcowego w formie umożliwiającej wyświetlenie, w tym wszystkie części nazwy, ewentualnie wraz z tytułami i przyrostkami, uporządkowane zgodnie z ustawieniami regionalnymi i preferencjami Użytkownika końcowego.</value>
  </data>
  <data name="given_name" xml:space="preserve">
    <value>Imię (imiona) lub imię (imiona) Użytkownika końcowego. Zauważ, że w niektórych kulturach ludzie mogą mieć wiele imion; Wszystkie mogą być obecne, a nazwy są oddzielone znakami spacji.</value>
  </data>
  <data name="family_name" xml:space="preserve">
    <value>Nazwisko(-a) lub nazwisko(-a) Użytkownika końcowego. Zauważ, że w niektórych kulturach ludzie mogą mieć wiele nazwisk lub nie mieć nazwiska; Wszystkie mogą być obecne, a nazwy są oddzielone znakami spacji.</value>
  </data>
  <data name="middle_name" xml:space="preserve">
    <value>Drugie imię (imiona) Użytkownika końcowego. Zauważ, że w niektórych kulturach ludzie mogą mieć wiele drugich imion; Wszystkie mogą być obecne, a nazwy są oddzielone znakami spacji. Należy również pamiętać, że w niektórych kulturach drugie imiona nie są używane.</value>
  </data>
  <data name="nickname" xml:space="preserve">
    <value>Swobodna nazwa Użytkownika końcowego, która może, ale nie musi być taka sama jak given_name. Na przykład wartość pseudonimu Mike może być zwracana wraz z given_name wartością Michael.</value>
  </data>
  <data name="preferred_username" xml:space="preserve">
    <value>Skrócona nazwa, pod którą Użytkownik końcowy życzy sobie, aby zwracano się do RP, np. janedoe lub j.doe. Ta wartość MOŻE być dowolnym prawidłowym ciągiem JSON, w tym znakami specjalnymi, takimi jak @, / lub spacja. RP nie może polegać na tym, że ta wartość jest unikalna.</value>
  </data>
  <data name="profile" xml:space="preserve">
    <value>Adres URL strony profilu użytkownika końcowego. Zawartość tej strony internetowej POWINNA dotyczyć użytkownika końcowego.</value>
  </data>
  <data name="picture" xml:space="preserve">
    <value>Adres URL zdjęcia profilowego użytkownika końcowego. Ten adres URL MUSI odnosić się do pliku obrazu (np. PNG, JPEG, lub plik obrazu GIF) zamiast strony internetowej zawierającej obraz. Zauważ, że ten adres URL POWINNY odwołać się do zdjęcia profilowego użytkownika odpowiedniego do wyświetlania podczas opisywania użytkownika końcowego, zamiast arbitralnego zdjęcia zrobionego przez użytkownika końcowego.</value>
  </data>
  <data name="website" xml:space="preserve">
    <value>Adres URL strony internetowej lub blogu użytkownika końcowego. Ta strona internetowa POWINNA zawierać informacje opublikowane przez Użytkownika końcowego lub organizację, z którą Użytkownik końcowy jest powiązany.</value>
  </data>
  <data name="email" xml:space="preserve">
    <value>Preferowany adres e-mail użytkownika końcowego. Jego wartość MUSI być zgodna ze składnią RFC 5322 addr-spec. RP nie może polegać na tym, że ta wartość jest unikalna.</value>
  </data>
  <data name="email_verified" xml:space="preserve">
    <value>True, jeśli adres e-mail Użytkownika końcowego został zweryfikowany; w przeciwnym razie fałsz. Jeśli wartość oświadczenia jest prawdziwa, oznacza to, że OP podjął pozytywne kroki w celu zapewnienia, że ten adres e-mail był kontrolowany przez użytkownika końcowego w momencie przeprowadzania weryfikacji. Sposób weryfikacji adresu e-mail jest zależny od kontekstu i zależy od ram zaufania lub porozumień umownych, w ramach których działają strony.</value>
  </data>
  <data name="gender" xml:space="preserve">
    <value>Płeć użytkownika końcowego. Wartości zdefiniowane w tej specyfikacji to kobiety i mężczyźni. Inne wartości MOGĄ być używane, gdy żadna ze zdefiniowanych wartości nie ma zastosowania.</value>
  </data>
  <data name="birthdate" xml:space="preserve">
    <value>Urodziny użytkownika końcowego w formacie ISO 8601:2004 RRRR-MM-DD. Rokiem MOŻE być 0000, co oznacza, że został pominięty. Aby reprezentować tylko rok, dozwolony jest format RRRR. Należy pamiętać, że w zależności od funkcji związanej z datą platformy bazowej, podanie tylko roku może spowodować zmianę miesiąca i dnia, więc wdrożeniowcy muszą wziąć ten czynnik pod uwagę, aby poprawnie przetworzyć daty.</value>
  </data>
  <data name="zoneinfo" xml:space="preserve">
    <value>Ciąg z bazy danych stref czasowych zoneinfo reprezentujący strefę czasową użytkownika końcowego. Na przykład Europa/Paryż lub Ameryka/Los_Angeles.</value>
  </data>
  <data name="locale" xml:space="preserve">
    <value>Ustawienia regionalne użytkownika końcowego reprezentowane jako znacznik języka BCP47 [RFC5646]. Zazwyczaj jest to kod języka ISO 639-1 Alpha-2 pisany małymi literami i kod kraju ISO 3166-1 Alfa-2 pisany wielkimi literami, oddzielony myślnikiem. Na przykład en-US lub fr-CA. Jako uwaga dotycząca zgodności, niektóre implementacje używały podkreślenia jako separatora zamiast myślnika, na przykład en_US; Strony uzależnione MOGĄ również zaakceptować tę składnię ustawień regionalnych.</value>
  </data>
  <data name="phone_number" xml:space="preserve">
    <value>Preferowany numer telefonu użytkownika końcowego. E.164 jest ZALECANY jako format niniejszego Roszczenia, na przykład +1 (425) 555-1212 lub +56 (2) 687 2400. Jeśli numer telefonu zawiera rozszerzenie, ZALECA się, aby rozszerzenie było reprezentowane przy użyciu składni rozszerzenia RFC 3966, na przykład +1 (604) 555-1234;ext=5678.</value>
  </data>
  <data name="phone_number_verified" xml:space="preserve">
    <value>True, jeśli numer telefonu Użytkownika końcowego został zweryfikowany; w przeciwnym razie fałsz. Jeśli ta wartość roszczenia jest prawdziwa, oznacza to, że PO podjął pozytywne kroki w celu zapewnienia, że ten numer telefonu był kontrolowany przez użytkownika końcowego w momencie przeprowadzania weryfikacji. Sposób weryfikacji numeru telefonu jest zależny od kontekstu i zależy od ram zaufania lub porozumień umownych, w ramach których działają strony. Jeśli jest to prawda, oświadczenie phone_number MUSI być w formacie E.164, a wszelkie rozszerzenia MUSZĄ być reprezentowane w formacie RFC 3966.</value>
  </data>
  <data name="address" xml:space="preserve">
    <value>Preferowany adres pocztowy użytkownika końcowego. Wartość elementu członkowskiego adresu jest strukturą JSON [RFC4627].</value>
  </data>
  <data name="updated_at" xml:space="preserve">
    <value>Godzina ostatniej aktualizacji informacji o użytkowniku końcowym. Jego wartość jest liczbą JSON reprezentującą liczbę sekund od 1970-01-01T0:0:0Z mierzoną w UTC do daty/godziny.</value>
  </data>
  <data name="azp" xml:space="preserve">
    <value>Upoważniony - strona, której został wydany Token Identyfikacyjny. Jeśli istnieje, MUSI zawierać identyfikator klienta OAuth 2.0 tej strony. To roszczenie jest potrzebne tylko wtedy, gdy token identyfikacyjny ma jedną wartość odbiorcy, a ta grupa odbiorców jest inna niż upoważniona strona. MOŻE być włączony nawet wtedy, gdy upoważniona strona jest tą samą publicznością. Wartość azp jest ciągiem uwzględniającym wielkość liter zawierającym wartość StringOrURI.</value>
  </data>
  <data name="nonce" xml:space="preserve">
    <value>Wartość ciągu używana do kojarzenia sesji klienta z tokenem identyfikatora oraz do ograniczania ataków typu replay. Wartość jest przekazywana bez modyfikacji z żądania uwierzytelnienia do tokenu identyfikatora. Jeśli występuje w tokenie identyfikacyjnym, klienci MUSZĄ sprawdzić, czy wartość oświadczenia nonce jest równa wartości parametru nonce wysłanego w żądaniu uwierzytelnienia. Jeśli serwery autoryzacji znajdują się w żądaniu uwierzytelnienia, MUSZĄ zawierać oświadczenie nonce w tokenie identyfikacyjnym, przy czym wartość oświadczenia jest wartością jednorazową wysłaną w żądaniu uwierzytelnienia. Serwery autoryzacji NIE powinny wykonywać żadnego innego przetwarzania na używanych wartościach nonce. Wartość nonce jest ciągiem uwzględniającym wielkość liter.</value>
  </data>
  <data name="auth_time" xml:space="preserve">
    <value>Godzina wystąpienia uwierzytelniania użytkownika końcowego. Jego wartość jest liczbą JSON reprezentującą liczbę sekund od 1970-01-01T0:0:0Z mierzoną w UTC do daty/godziny. W przypadku złożenia wniosku max_age lub złożenia wniosku auth_time jako Roszczenia zasadniczego, wówczas Roszczenie to jest WYMAGANE; w przeciwnym razie jego włączenie jest OPCJONALNE. (Oświadczenie auth_time semantycznie odpowiada parametrowi odpowiedzi auth_time OpenID 2.0 PAPE).</value>
  </data>
  <data name="at_hash" xml:space="preserve">
    <value>Wartość skrótu tokenu dostępu. Jego wartość jest kodowaniem base64url skrajnej lewej połowy skrótu oktetów reprezentacji ASCII wartości access_token, gdzie algorytm skrótu jest algorytmem skrótu używanym w parametrze nagłówka ALG Header nagłówka JOSE tokena ID. Na przykład, jeśli alg to RS256, zamieszaj wartość access_token za pomocą SHA-256, a następnie weź 128 bitów z lewej strony i zakoduj je base64url. Wartość at_hash jest ciągiem uwzględniającym wielkość liter.</value>
  </data>
  <data name="c_hash" xml:space="preserve">
    <value>Wartość skrótu kodu. Jego wartość jest kodowaniem base64url skrajnej lewej połowy skrótu oktetów reprezentacji ASCII wartości kodu, gdzie algorytm skrótu jest algorytmem skrótu używanym w parametrze nagłówka JOSE tokenu alg. Na przykład, jeśli alg to HS512, zamieszaj wartość kodu za pomocą SHA-512, a następnie weź 256 bitów z lewej strony i zakoduj je base64url. Wartość c_hash jest ciągiem uwzględniającym wielkość liter. Jeśli token identyfikacyjny jest wystawiany z punktu końcowego autoryzacji z kodem, co ma miejsce w przypadku kodu wartości response_type id_token i kodu id_token tokenu, jest to WYMAGANE; w przeciwnym razie jego włączenie jest OPCJONALNE.</value>
  </data>
  <data name="acr" xml:space="preserve">
    <value>Odwołanie do klasy kontekstu uwierzytelniania. Ciąg określający wartość referencyjną klasy kontekstu uwierzytelniania, która identyfikuje klasę kontekstu uwierzytelniania, którą zostało wykonane uwierzytelnianie. Wartość "0" wskazuje, że uwierzytelnianie użytkownika końcowego nie spełniło wymagań normy ISO/IEC 29115 poziom 1. Na przykład uwierzytelnianie za pomocą długotrwałego pliku cookie przeglądarki jest jednym z przykładów, w których użycie "poziomu 0" jest właściwe. Uwierzytelnienia z poziomem 0 NIE POWINNY być używane do autoryzowania dostępu do jakichkolwiek zasobów o jakiejkolwiek wartości pieniężnej. (Odpowiada to OpenID 2.0 PAPE nist_auth_level 0.) Bezwzględny identyfikator URI lub zarejestrowana nazwa RFC 6711 POWINNA być używana jako wartość acr; zarejestrowane nazwy NIE MOGĄ być używane w innym znaczeniu niż to, które jest zarejestrowane. Strony korzystające z tego oświadczenia będą musiały uzgodnić znaczenie użytych wartości, które mogą być zależne od kontekstu. Wartość acr jest ciągiem uwzględniającym wielkość liter.</value>
  </data>
  <data name="amr" xml:space="preserve">
    <value>Odwołania do metod uwierzytelniania. Tablica JSON ciągów, które są identyfikatorami metod uwierzytelniania używanych w uwierzytelnianiu. Na przykład wartości mogą wskazywać, że użyto zarówno metody uwierzytelniania hasła, jak i OTP. Strony korzystające z tego oświadczenia będą musiały uzgodnić znaczenie użytych wartości, które mogą być zależne od kontekstu. Wartość amr jest tablicą ciągów rozróżnianych na wielkość liter.</value>
  </data>
  <data name="sub_jwk" xml:space="preserve">
    <value>Klucz publiczny używany do sprawdzania podpisu tokenu identyfikacyjnego wystawionego przez samodzielnie wydanego dostawcę OpenID. Klucz jest czystym kluczem w formacie JWK (nie wartością certyfikatu X.509). Wartość sub_jwk jest obiektem JSON. Korzystanie z oświadczenia sub_jwk NIE JEST ZALECANE, gdy PO nie jest wydawany samodzielnie.</value>
  </data>
</root>
